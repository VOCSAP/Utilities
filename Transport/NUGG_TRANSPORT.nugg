<?xml version="1.0" encoding="utf-8"?>
<nugget name="TRANSPORT">
 <CLAS CLSNAME="ZCL_IM_CLIF_TOGGLE_DISPEDI" VERSION="1" LANGU="F" DESCRIPT="Classe d&apos;implémentation pour implémentation de Business Add-" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <implementing CLSNAME="ZCL_IM_CLIF_TOGGLE_DISPEDI" REFCLSNAME="IF_EX_CLIF_TOGGLE_DISPEDIT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <interfaceMethod CLSNAME="ZCL_IM_CLIF_TOGGLE_DISPEDI" CPDNAME="IF_EX_CLIF_TOGGLE_DISPEDIT~HANDLE_CLASS_TOGGLE">
   <source>METHOD if_ex_clif_toggle_dispedit~handle_class_toggle.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Traitement
  &quot; -----------------------------------------------------------

  &quot; Suivant l&apos;Action utilisateur
  CASE access_mode.

    WHEN &apos;MODIFY&apos;.                                          &quot;#EC NOTEXT
      IF zcl_transport_request=&gt;object_edition_check( clskey-clsname ) EQ abap_true.
        &quot; L&apos;utilisateur ne souhaite pas poursuivre l&apos;édition
        RAISE no_access.

      ENDIF.

    WHEN OTHERS.
      &quot; Autres

  ENDCASE.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_IM_CLIF_TOGGLE_DISPEDI" CPDNAME="IF_EX_CLIF_TOGGLE_DISPEDIT~HANDLE_INTERFACE_TOGGLE">
   <source>METHOD if_ex_clif_toggle_dispedit~handle_interface_toggle.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Traitement
  &quot; -----------------------------------------------------------

  &quot; Suivant l&apos;Action utilisateur
  CASE access_mode.

    WHEN &apos;MODIFY&apos;.                                          &quot;#EC NOTEXT
      IF zcl_transport_request=&gt;object_edition_check( intkey-clsname ) EQ abap_true.
        &quot; L&apos;utilisateur ne souhaite pas poursuivre l&apos;édition
        RAISE no_access.

      ENDIF.

    WHEN OTHERS.
      &quot; Autres

  ENDCASE.

ENDMETHOD.</source>
  </interfaceMethod>
 </CLAS>
 <CLAS CLSNAME="ZCA_TRANSPORT_REQUEST_WORKFLOW" VERSION="1" LANGU="F" DESCRIPT="Agent Transport - Workflow" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCA_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="AGENT" VERSION="1" LANGU="F" DESCRIPT="L&apos;acteur de classe - Singleton" EXPOSURE="2" STATE="1" EDITORDER="0 " ATTDECLTYP="1" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCA_TRANSPORT_REQUEST_WORKFLOW" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCA_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" VERSION="1" STATE="1"/>
  <method CLSNAME="ZCA_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="Constructeur de classes" EXPOSURE="2" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CLASS_CONSTRUCTOR.
***BUILD 090501
************************************************************************
* Purpose        : Initialize the &apos;class&apos;.
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : Singleton is created.
*
* OO Exceptions  : -
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 1999-09-20   : (OS) Initial Version
* - 2000-03-06   : (BGR) 2.0 modified REGISTER_CLASS_AGENT
************************************************************************
* GENERATED: Do not modify
************************************************************************

  create object AGENT.

  call method AGENT-&gt;REGISTER_CLASS_AGENT
    exporting
      I_CLASS_NAME          = &apos;ZCL_TRANSPORT_REQUEST_WORKFLOW&apos;
      I_CLASS_AGENT_NAME    = &apos;ZCA_TRANSPORT_REQUEST_WORKFLOW&apos;
      I_CLASS_GUID          = &apos;0050568A04511EDAB1D1FD2A8AC8447B&apos;
      I_CLASS_AGENT_GUID    = &apos;0050568A04511EDAB1D1FD2A8AC8C47B&apos;
      I_AGENT               = AGENT
      I_STORAGE_LOCATION    = &apos;&apos;
      I_CLASS_AGENT_VERSION = &apos;2.0&apos;.

           &quot;CLASS_CONSTRUCTOR
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" VERSION="1" LANGU="F" DESCRIPT="Agent base Transport - Workflow" CATEGORY="11" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CL_OS_CA_COMMON">
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_OID" VERSION="1" LANGU="F" DESCRIPT="Type de référence objet générique" EXPOSURE="1" STATE="1" EDITORDER="0 " TYPTYPE="1" TYPE="OS_GUID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_TYPE" VERSION="1" LANGU="F" DESCRIPT="Type de référence objet" EXPOSURE="1" STATE="1" EDITORDER="0 " TYPTYPE="1" TYPE="OS_GUID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_OBJECT_REF" VERSION="1" LANGU="F" DESCRIPT="Type d&apos;un objet géré" EXPOSURE="1" STATE="1" EDITORDER="1 " TYPTYPE="3" TYPE="ZCL_TRANSPORT_REQUEST_WORKFLOW" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_BUSINESS_KEY" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" EXPOSURE="1" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="7 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="26 " TYPESRC_LENG="0 " TYPESRC="begin of TYP_BUSINESS_KEY ,
      ZEDREQNB type ZEDREQNB ,
    end of TYP_BUSINESS_KEY
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_BUSINESS_KEY_TAB" VERSION="1" LANGU="F" DESCRIPT="Type de table référence objet" EXPOSURE="1" STATE="1" EDITORDER="3 " TYPTYPE="4" TYPE="TYP_BUSINESS_KEY" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="12 " SRCCOLUMN2="49 " TYPESRC_LENG="0 " TYPESRC="TYP_BUSINESS_KEY_TAB type standard table of
      TYP_BUSINESS_KEY with non-unique default key
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_DB_DATA" VERSION="1" LANGU="F" DESCRIPT="Type de ligne données d&apos;objet permanentes" EXPOSURE="1" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="4 " SRCROW2="46 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="begin of TYP_DB_DATA ,
      ZEDREQNB type ZEDREQNB ,
      ZEDLANGU type ZEDLANGU ,
      ZEDSOURSYS type ZEDSOURSYS ,
      ZEDSOURMDT type ZEDSOURMDT ,
      ZEDTARGSYS type ZEDTARGSYS ,
      ZEDTRPDATE type ZEDTRPDATE ,
      ZEDTRPTIME type ZEDTRPTIME ,
      ZEDTRPCODE type ZEDTRPCODE ,
      ZEDTRPTYPE type ZEDTRPTYPE ,
      ZEDREQUSER type ZEDREQUSER ,
      ZEDREQDATE type ZEDREQDATE ,
      ZEDREQTIME type ZEDREQTIME ,
      ZEDMODUSER type ZEDMODUSER ,
      ZEDMODDATE type ZEDMODDATE ,
      ZEDMODTIME type ZEDMODTIME ,
      ZEDVALCODE type ZEDVALCODE ,
      ZEDVALUSER type ZEDVALUSER ,
      ZEDVALDATE type ZEDVALDATE ,
      ZEDVALTIME type ZEDVALTIME ,
      ZEDTRTDATE type ZEDTRTDATE ,
      ZEDTRTTIME type ZEDTRTTIME ,
      ZEDUGROUP type ZEDUGROUP ,
      ZEDFUNAREA type ZEDFUNAREA ,
      ZEDQUERY type ZEDQUERY ,
      ZEDQTRPCOD type ZEDQTRPCOD ,
      ZEDIMPORT type ZEDIMPORT ,
      ZEDCOMMENT type ZEDCOMMENT ,
      ZEDREPROC type ZEDREPROC ,
      ZEDVALFT2 type ZEDVALFT2 ,
      ZEDVALFT2DATE type ZEDVALFT2DATE ,
      ZEDELIGIBLE type ZEDELIGIBLE ,
    end of TYP_DB_DATA
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_DB_DATA_TAB" VERSION="1" LANGU="F" DESCRIPT="Type de table données d&apos;objet permanentes" EXPOSURE="1" STATE="1" EDITORDER="5 " TYPTYPE="4" TYPE="TYP_DB_DATA" SRCROW1="48 " SRCCOLUMN1="4 " SRCROW2="49 " SRCCOLUMN2="44 " TYPESRC_LENG="0 " TYPESRC="TYP_DB_DATA_TAB type standard table of
      TYP_DB_DATA with non-unique default key
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_OID_TAB" VERSION="1" LANGU="F" DESCRIPT="Type de table référence objet" EXPOSURE="1" STATE="1" EDITORDER="5 " TYPTYPE="4" TYPE="TYP_OID" SRCROW1="51 " SRCCOLUMN1="4 " SRCROW2="52 " SRCCOLUMN2="40 " TYPESRC_LENG="0 " TYPESRC="TYP_OID_TAB type standard table of
      TYP_OID with non-unique default key
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_OBJECT_REF_TAB" VERSION="1" LANGU="F" DESCRIPT="Type de table référence objet" EXPOSURE="1" STATE="1" EDITORDER="6 " TYPTYPE="4" TYPE="TYP_OBJECT_REF" SRCROW1="54 " SRCCOLUMN1="4 " SRCROW2="55 " SRCCOLUMN2="47 " TYPESRC_LENG="0 " TYPESRC="TYP_OBJECT_REF_TAB type standard table of
      TYP_OBJECT_REF with non-unique default key
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_SPECIAL_OBJECT_INFO" VERSION="1" LANGU="F" DESCRIPT="Type de ligne données d&apos;objet spécifiques à classe" EXPOSURE="1" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="57 " SRCCOLUMN1="4 " SRCROW2="61 " SRCCOLUMN2="33 " TYPESRC_LENG="0 " TYPESRC="begin of TYP_SPECIAL_OBJECT_INFO ,
      OBJECT_ID type TYP_INTERNAL_OID ,
      ID_STATUS type TYP_ID_STATUS ,
      BUSINESS_KEY type TYP_BUSINESS_KEY ,
    end of TYP_SPECIAL_OBJECT_INFO
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_SPECIAL_OBJECT_INFO_TAB" VERSION="1" LANGU="F" DESCRIPT="Type de table données d&apos;objet spécifiques aux classes" EXPOSURE="1" STATE="1" EDITORDER="8 " TYPTYPE="4" TYPE="TYP_SPECIAL_OBJECT_INFO" SRCROW1="63 " SRCCOLUMN1="4 " SRCROW2="65 " SRCCOLUMN2="14 " TYPESRC_LENG="0 " TYPESRC="TYP_SPECIAL_OBJECT_INFO_TAB type sorted table of
      TYP_SPECIAL_OBJECT_INFO with unique key
      OBJECT_ID
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_SPECIAL_BKEY_TAB" VERSION="1" LANGU="F" DESCRIPT="Type de table table de recherche clés de gestion" EXPOSURE="1" STATE="1" EDITORDER="9 " TYPTYPE="4" TYPE="TYP_SPECIAL_OBJECT_INFO" SRCROW1="67 " SRCCOLUMN1="4 " SRCROW2="69 " SRCCOLUMN2="17 " TYPESRC_LENG="0 " TYPESRC="TYP_SPECIAL_BKEY_TAB type sorted table of
      TYP_SPECIAL_OBJECT_INFO with unique key
      BUSINESS_KEY
"/>
  <types CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TYP_DB_DELETE_TAB" VERSION="1" LANGU="F" DESCRIPT="Type de table références pour suppression" EXPOSURE="1" STATE="1" EDITORDER="10 " TYPTYPE="4" TYPE="TYP_SPECIAL_OBJECT_INFO" SRCROW1="71 " SRCCOLUMN1="4 " SRCROW2="72 " SRCCOLUMN2="56 " TYPESRC_LENG="0 " TYPESRC="TYP_DB_DELETE_TAB type standard table of
      TYP_SPECIAL_OBJECT_INFO with non-unique default key
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CURRENT_SPECIAL_OBJECT_INFO" VERSION="1" LANGU="F" DESCRIPT="Données d&apos;objet spécifiques aux classes" EXPOSURE="1" STATE="1" EDITORDER="0 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TYP_SPECIAL_OBJECT_INFO" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SPECIAL_BKEY_TAB" VERSION="1" LANGU="F" DESCRIPT="Spécifique à classes : table de recherche clés de gestion" EXPOSURE="1" STATE="1" EDITORDER="0 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TYP_SPECIAL_BKEY_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SPECIAL_OBJECT_INFO" VERSION="1" LANGU="F" DESCRIPT="Données d&apos;objet spécifiques aux classes" EXPOSURE="1" STATE="1" EDITORDER="0 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TYP_SPECIAL_OBJECT_INFO_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="DELETE_SPECIAL_OBJECT_INFO" EXPOSURE="1"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY_TAB" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="IF_OS_CA_SERVICE~SAVE" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="IF_OS_CA_SERVICE~SAVE_IN_UPDATE_TASK" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="IF_OS_FACTORY~CREATE_PERSISTENT_BY_KEY" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="IF_OS_FACTORY~CREATE_TRANSIENT_BY_KEY" EXPOSURE="0"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="LOAD_SPECIAL_OBJECT_INFO" EXPOSURE="1"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="MAP_INVALIDATE" EXPOSURE="1"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="OS_PM_DELETE_PERSISTENT" EXPOSURE="1"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="PM_LOAD" EXPOSURE="1"/>
   <redefinition CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="CL_OS_CA_COMMON" VERSION="1" MTDNAME="SAVE_SPECIAL_OBJECT_INFO" EXPOSURE="1"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY">
   <source>method IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY.
***BUILD 093901
*      importing I_KEY type any
*      returning result type ref to object
************************************************************************
* Purpose        : Get a persistent object identified by the
*                  given business key
*
* Version        : 2.0
*
* Precondition   : The object exists with the given business key,
*                  either in memory or on database.
*
* Postcondition  : The object exists in memory, RESULT is the reference
*
* OO Exceptions  : propagates GET_PERSISTENT
*
* Implementation : call GET_PERSISTENT
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version 2.0
* - 2000-08-02   : (SB)  OO Exceptions
************************************************************************

  data: BUSINESS_KEY             type TYP_BUSINESS_KEY.

  BUSINESS_KEY = I_KEY.

*&lt; Generated from mapping:
  call method GET_PERSISTENT
       exporting I_ZEDREQNB = BUSINESS_KEY-ZEDREQNB
       receiving RESULT = RESULT.
*&gt;

           &quot;IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY_TAB">
   <source>method IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY_TAB.
***BUILD 093901
      &quot;importing I_KEY_TAB type INDEX TABLE
      &quot;returning value(RESULT) type OSREFTAB
      &quot;raising   CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get persistent objects by Business Key table
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : For each entry in the KEY table, there is a corres-
*                  ponding entry in the RESULT table. If the object was
*                  found in the cache or the database, then a reference
*                  to this object can be found in the RESULT table,
*                  if not, the reference is initial. The persistent
*                  objects are active.
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*                    (IS_TRANSIENT_BY_BKEY,DELETED_BY_BKEY)
*                  propagates PM_LOAD_AND_SET_ATTRIBUTES
*                  propagates OS_PM_LOADED_PERISISTENT
*
* Implementation : 1. Look for object in SPECIAL_OBJECT_INFO. If found,
*                     check if it is still valid
*                  2. Object found: Check PM_STATUS
*                     2a. If Status is TRANSIENT or DELETED, error!
*                     2b. If Status is NOT_LOADED, continue with 3.
*                     2c. If Status is NEW, LOADED or CHANGED, success!
*                  3. Load object data from database and set object
*                     3.a Completion in super class
*                  4. clean up
*
************************************************************************
* Changelog:
* - 2004-01-07   : (SB)  Initial version
************************************************************************

  types: begin of TYP_BUSINESS_KEY_INDEX,
           BUSINESS_KEY     type TYP_BUSINESS_KEY,
           INDEX            type SY-TABIX,
         end of TYP_BUSINESS_KEY_INDEX,
         TYP_BUSINESS_KEY_INDEX_TAB type sorted table
           of TYP_BUSINESS_KEY_INDEX with non-unique key BUSINESS_KEY.

  data: FLAG_NOT_LOADED        type OS_BOOLEAN,
        BKEY_STRING            type STRING,
        TEMP_OBJECT_REF        type TYP_OBJECT_REF,
        BUSINESS_KEY           type TYP_BUSINESS_KEY,
        BUSINESS_KEY_TAB       type TYP_BUSINESS_KEY_TAB,
        OBJECT_DATA_TAB        type TYP_DB_DATA_TAB,
        BUSINESS_KEY_INDEX     type TYP_BUSINESS_KEY_INDEX,
        BUSINESS_KEY_INDEX_TAB type TYP_BUSINESS_KEY_INDEX_TAB,
        NEXT_INDEX             type SY-TABIX.

  data: TEMP_CURRENT_OBJECT_IREF type ref to OBJECT.

  field-symbols: &lt;FS_OBJECT_DATA&gt;  type TYP_DB_DATA,
                 &lt;FS_BUSINESS_KEY&gt; type TYP_BUSINESS_KEY,
                 &lt;FS_BUSINESS_KEY_INDEX&gt; type TYP_BUSINESS_KEY_INDEX.

* * 1. Look for objects in SPECIAL_OBJECT_INFO. If found, check if they
* * are still valid

  loop at I_KEY_TAB assigning &lt;FS_BUSINESS_KEY&gt;. &quot;#EC GEN_OK

    clear CURRENT_OBJECT_IREF.

    read table SPECIAL_BKEY_TAB into CURRENT_SPECIAL_OBJECT_INFO
       with table key BUSINESS_KEY = &lt;FS_BUSINESS_KEY&gt;.

    if ( SY-SUBRC = 0 ).

      read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
           with table key
           OBJECT_ID = CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID.
      call method OS_LOAD_AND_VALIDATE_CURRENT
           exporting I_INDEX = SY-TABIX.

    endif.

    if ( not CURRENT_OBJECT_IREF is initial ).

*   * 2. Object found: Check PM_STATUS

      case CURRENT_OBJECT_INFO-PM_STATUS.

*     * 2a. If Status is TRANSIENT or DELETED, error!
      when OSCON_OSTATUS_DELETED.

*!!!!!!! Error: Object activation failed - Object marked for deletion
        TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
        BKEY_STRING  = MAP_SERIALIZE_BKEY( &lt;FS_BUSINESS_KEY&gt; ).
        call method OS_CLEAR_CURRENT.
        clear CURRENT_SPECIAL_OBJECT_INFO.
        class CX_OS_OBJECT_NOT_FOUND definition load.
        raise exception type CX_OS_OBJECT_NOT_FOUND
          exporting
            OBJECT = TEMP_CURRENT_OBJECT_IREF
            BKEY   = BKEY_STRING
            TEXTID = CX_OS_OBJECT_NOT_FOUND=&gt;DELETED_BY_BKEY.

      when OSCON_OSTATUS_TRANSIENT.

*!!!!!!! Error: Object activation failed - Object is transient
        TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
        BKEY_STRING  = MAP_SERIALIZE_BKEY( &lt;FS_BUSINESS_KEY&gt; ).
        call method OS_CLEAR_CURRENT.
        clear CURRENT_SPECIAL_OBJECT_INFO.
        class CX_OS_OBJECT_NOT_FOUND definition load.
        raise exception type CX_OS_OBJECT_NOT_FOUND
          exporting
            OBJECT = TEMP_CURRENT_OBJECT_IREF
            BKEY   = BKEY_STRING
            TEXTID = CX_OS_OBJECT_NOT_FOUND=&gt;IS_TRANSIENT_BY_BKEY.

*     * 2b. If Status is NOT_LOADED, continue with 3.
      when OSCON_OSTATUS_NOT_LOADED.

        FLAG_NOT_LOADED = OSCON_TRUE.

*     * 2c. If Status is NEW, LOADED or CHANGED, success!
      when others.

        FLAG_NOT_LOADED = OSCON_FALSE.

      endcase.

    else.&quot; ( CURRENT_OBJECT_IREF is initial )

      FLAG_NOT_LOADED = OSCON_TRUE.

    endif.

    if ( FLAG_NOT_LOADED = OSCON_TRUE ).

      append &lt;FS_BUSINESS_KEY&gt; to BUSINESS_KEY_TAB.

    endif.

    TEMP_OBJECT_REF ?= CURRENT_OBJECT_IREF.
    append TEMP_OBJECT_REF to RESULT.

    call method OS_CLEAR_CURRENT.

  endloop.

* * 3. Load object data from database and set objects

  if ( BUSINESS_KEY_TAB is not initial ).

*   * internal Undo
    append INTERNAL_NEXT_UNDO_INFO to INTERNAL_TRANSACTION_STACK.
    INTERNAL_CURRENT_TRANSACTION = SY-TABIX.

    try.
        call method MAP_LOAD_FROM_DATABASE_KEY
             exporting I_BUSINESS_KEY_TAB = BUSINESS_KEY_TAB
             receiving result = OBJECT_DATA_TAB.
      catch CX_OS_DB_SELECT.
        clear OBJECT_DATA_TAB.
    endtry.

    loop at I_KEY_TAB assigning &lt;FS_BUSINESS_KEY&gt;. &quot;EC GEN_OK
      BUSINESS_KEY_INDEX-BUSINESS_KEY = &lt;FS_BUSINESS_KEY&gt;.
      BUSINESS_KEY_INDEX-INDEX = SY-TABIX.
      insert BUSINESS_KEY_INDEX into table BUSINESS_KEY_INDEX_TAB.
    endloop.

    try.

        loop at OBJECT_DATA_TAB assigning &lt;FS_OBJECT_DATA&gt;.

          call method MAP_EXTRACT_IDENTIFIER
               exporting I_DB_DATA  = &lt;FS_OBJECT_DATA&gt;
               importing E_BUSINESS_KEY = BUSINESS_KEY.

          clear CURRENT_OBJECT_IREF.

          call method PM_CHECK_AND_SET_ATTRIBUTES
               exporting I_OBJECT_DATA  = &lt;FS_OBJECT_DATA&gt;
                         I_ID_PROVIDED  = ID_STATUS_NONE.

          TEMP_OBJECT_REF ?= CURRENT_OBJECT_IREF.

          read table BUSINESS_KEY_INDEX_TAB
               with key BUSINESS_KEY = BUSINESS_KEY
               assigning &lt;FS_BUSINESS_KEY_INDEX&gt;.

          while ( ( SY-SUBRC = 0 ) and
                  ( &lt;FS_BUSINESS_KEY_INDEX&gt;-BUSINESS_KEY =
                    BUSINESS_KEY ) ).

            NEXT_INDEX = SY-TABIX + 1.

            modify RESULT from TEMP_OBJECT_REF
                          index &lt;FS_BUSINESS_KEY_INDEX&gt;-INDEX.

            read table BUSINESS_KEY_INDEX_TAB
                 index NEXT_INDEX
                 assigning &lt;FS_BUSINESS_KEY_INDEX&gt;.

          endwhile.

*         * 3.a. Completion in super class
          call method OS_PM_LOADED_PERSISTENT.

          clear CURRENT_SPECIAL_OBJECT_INFO.

        endloop.

      cleanup.
        call method OS_INTERNAL_UNDO.
        call method OS_CLEAR_CURRENT.
        clear CURRENT_SPECIAL_OBJECT_INFO.
    endtry.

*   * Clean-up internal Undo
    delete INTERNAL_TRANSACTION_STACK
           index INTERNAL_CURRENT_TRANSACTION.
    add -1 to INTERNAL_CURRENT_TRANSACTION.
    if ( INTERNAL_TRANSACTION_STACK is initial ).
      clear INTERNAL_UNDO_INFO.
      INTERNAL_NEXT_UNDO_INFO = 1.
    endif. &quot;( INTERNAL_TRANSACTION_STACK is initial? )

  endif.

* * 4. clean up

  clear CURRENT_SPECIAL_OBJECT_INFO.


           &quot;IF_OS_CA_PERSISTENCY~GET_PERSISTENT_BY_KEY_TAB
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_CA_SERVICE~SAVE">
   <source>method IF_OS_CA_SERVICE~SAVE.
***BUILD 090501
************************************************************************
* Purpose        : Prepare data for database (buffer) transfer
*
* Version        : 2.0
*
* Precondition   : --
*
* Postcondition  : data is prepared for saving
*                  if UPDATE_MODE is direct, it is saved to DB
*                  if UPDATE_MODE is LOCAL or UPDATE_TASK,
*                    the corresponding function call is registered
*
* OO Exceptions  : propagates MAP_SAVE_TO_DATABASE
*                  propagates MAP_GET_ATTRIBUTES.
*
* Implementation :
*
************************************************************************
* Changelog:
* - 2000-03-02   : (BGR) Initial Version
* - 2000-08-02   : (SB) OO Exceptions
* - 2001-01-06   : (SB) Update with EXPORT TO DATA BUFFER
* - 2003-03-20   : (SB) post only if there dirty instances
************************************************************************

  data: NEW_OBJECT_REF_TAB       type TYP_OBJECT_REF_TAB,
        CHANGED_OBJECT_REF_TAB   type TYP_OBJECT_REF_TAB,
        INSERT_DATA_TAB          type TYP_DB_DATA_TAB ,
        INSERT_KEY_TAB           type TYP_BUSINESS_KEY_TAB,
        UPDATE_DATA_TAB          type TYP_DB_DATA_TAB ,
        UPDATE_KEY_TAB           type TYP_BUSINESS_KEY_TAB,
        DELETE_TAB               type TYP_DB_DELETE_TAB ,
        UPDATE_MODE              type OS_DMODE,
        OBJECT_REF               type TYP_OBJECT_REF,
        OBJECT_INDEX             type TYP_INDEX,
        XCONTAINER               type XSTRING.

  field-symbols:
          &lt;FS_OBJECT_INFO_ITEM&gt;         type TYP_OBJECT_INFO,
          &lt;FS_SPECIAL_OBJECT_INFO_ITEM&gt; type TYP_SPECIAL_OBJECT_INFO.

* * 1. get strong reference, BKey for all objects with status
* *    NEW, CHANGED or DELETED

  loop at OBJECT_INFO assigning &lt;FS_OBJECT_INFO_ITEM&gt; &quot;#EC CI_SORTSEQ
       where ( PM_STATUS = OSCON_OSTATUS_NEW or       &quot;#EC CI_SORTSEQ
               PM_STATUS = OSCON_OSTATUS_CHANGED or   &quot;#EC CI_SORTSEQ
               PM_STATUS = OSCON_OSTATUS_DELETED ) and &quot;#EC CI_SORTSEQ
               OM_IGNORE = OSCON_FALSE.               &quot;#EC CI_SORTSEQ

    OBJECT_INDEX = sy-tabix.

    case &lt;FS_OBJECT_INFO_ITEM&gt;-PM_STATUS.

      when OSCON_OSTATUS_NEW.

        read table SPECIAL_OBJECT_INFO
             assigning &lt;FS_SPECIAL_OBJECT_INFO_ITEM&gt;
             index OBJECT_INDEX.

        OBJECT_REF ?= &lt;FS_OBJECT_INFO_ITEM&gt;-OBJECT_IREF.
        append OBJECT_REF
            to NEW_OBJECT_REF_TAB.
        append &lt;FS_SPECIAL_OBJECT_INFO_ITEM&gt;-BUSINESS_KEY
            to INSERT_KEY_TAB.

      when OSCON_OSTATUS_CHANGED.

        read table SPECIAL_OBJECT_INFO
             assigning &lt;FS_SPECIAL_OBJECT_INFO_ITEM&gt;
             index OBJECT_INDEX.

        OBJECT_REF ?= &lt;FS_OBJECT_INFO_ITEM&gt;-OBJECT_IREF.
        append OBJECT_REF
            to CHANGED_OBJECT_REF_TAB.
        append &lt;FS_SPECIAL_OBJECT_INFO_ITEM&gt;-BUSINESS_KEY
            to UPDATE_KEY_TAB.

      when OSCON_OSTATUS_DELETED.

        read table SPECIAL_OBJECT_INFO
             assigning &lt;FS_SPECIAL_OBJECT_INFO_ITEM&gt;
             index OBJECT_INDEX.

        append &lt;FS_SPECIAL_OBJECT_INFO_ITEM&gt; to DELETE_TAB.

    endcase.&quot; Status

  endloop. &quot;at OBJECT_INFO


* * 2. get attributes for new and changed objects

* * New Objects
  if ( not NEW_OBJECT_REF_TAB is initial ).

    call method MAP_GET_ATTRIBUTES
         exporting I_OBJECT_REF_TAB  = NEW_OBJECT_REF_TAB
         importing E_OBJECT_DATA_TAB = INSERT_DATA_TAB.

    call method MAP_MERGE_IDENTIFIER
         exporting I_BUSINESS_KEY_TAB = INSERT_KEY_TAB
         changing  C_DB_DATA_TAB      = INSERT_DATA_TAB.

  endif. &quot;( not NEW_OBJECT_REF_TAB is initial ).

* * Changed Objects
  if ( not CHANGED_OBJECT_REF_TAB is initial ).

    call method MAP_GET_ATTRIBUTES
         exporting I_OBJECT_REF_TAB  = CHANGED_OBJECT_REF_TAB
         importing E_OBJECT_DATA_TAB = UPDATE_DATA_TAB.

    call method MAP_MERGE_IDENTIFIER
         exporting I_BUSINESS_KEY_TAB = UPDATE_KEY_TAB
         changing  C_DB_DATA_TAB      = UPDATE_DATA_TAB.

  endif. &quot;( not CHANGED_OBJECT_REF_TAB is initial ).

* * 3. perform or subscribe DB operations

  if ( ( INSERT_DATA_TAB is not initial ) or
       ( UPDATE_DATA_TAB is not initial ) or
       ( DELETE_TAB is not initial ) ).

    UPDATE_MODE = PERSISTENCY_MANAGER-&gt;GET_UPDATE_MODE(  ).
    if ( UPDATE_MODE = DMODE_DIRECT ).

*     * Direct DB operations
      call method MAP_SAVE_TO_DATABASE
           exporting I_INSERTS = INSERT_DATA_TAB
                     I_UPDATES = UPDATE_DATA_TAB
                     I_DELETES = DELETE_TAB.

    else.&quot; ( Update task )

*     * export data to be saved to DB to data buffer
      export
        INSERT_DATA_TAB = INSERT_DATA_TAB
        UPDATE_DATA_TAB = UPDATE_DATA_TAB
        DELETE_TAB      = DELETE_TAB
          to data buffer XCONTAINER.

*     * call update function in update task. this function
*     * calls the method if_os_ca_service~save_in_update_task
*     * of this class agent.
      call function &apos;OS_UPDATE_CLASS&apos; in update task
        exporting
          CLASSNAME = CLASS_INFO-CLASS_AGENT_NAME
          XCONTAINER = XCONTAINER.

    endif.&quot; (Update mode?)

  endif.&quot; (something to post?)

           &quot;IF_OS_CA_SERVICE~SAVE
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_CA_SERVICE~SAVE_IN_UPDATE_TASK">
   <source>method IF_OS_CA_SERVICE~SAVE_IN_UPDATE_TASK.
***BUILD 090501
     &quot; importing XCONTAINER type XSTRING optional
************************************************************************
* Purpose        : save object data to DB when running in update task
*                  mode.
*
* Version        : 2.0
*
* Precondition   : no object service environment is set, no objects
*                  exist in update task
*
* Postcondition  : data has been saved to DB
*
* OO Exceptions  : propagates MAP_SAVE_TO_DATABASE
*
* Implementation :
*
************************************************************************
* Changelog:
* - 2000-03-02   : (BGR) Initial Version
* - 2000-08-02   : (SB) OO Exceptions
* - 2001-01-06   : (SB) Update with EXPORT TO DATA BUFFER
************************************************************************

  data: INSERT_DATA_TAB       type TYP_DB_DATA_TAB ,
        UPDATE_DATA_TAB       type TYP_DB_DATA_TAB ,
        DELETE_TAB            type TYP_DB_DELETE_TAB .

* * import data to be saved to DB from data buffer
  import
    INSERT_DATA_TAB = INSERT_DATA_TAB
    UPDATE_DATA_TAB = UPDATE_DATA_TAB
    DELETE_TAB      = DELETE_TAB
      from data buffer XCONTAINER.

* * store them to DB
  call method MAP_SAVE_TO_DATABASE
       exporting I_INSERTS = INSERT_DATA_TAB
                 I_UPDATES = UPDATE_DATA_TAB
                 I_DELETES = DELETE_TAB.

           &quot;IF_OS_CA_SERVICE~SAVE_IN_UPDATE_TASK
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_FACTORY~CREATE_PERSISTENT_BY_KEY">
   <source>method IF_OS_FACTORY~CREATE_PERSISTENT_BY_KEY.
***BUILD 093901
*      importing I_KEY type any
*      returning result type ref to object
************************************************************************
* Purpose        : Create a new persistent object identified by the
*                  given business key
*
* Version        : 2.0
*
* Precondition   : No object exists with the given business key, neither
*                  in memory nor on database.
*
* Postcondition  : The object exists in memory and will result in a
*                  new entry on database when the top transaction is
*                  closed.
*
* OO Exceptions  : propagates CREATE_PERSISTENT
*
* Implementation : call CREATE_PERSISTENT
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version 2.0
* - 2000-08-02   : (SB)  OO Exceptions
************************************************************************

  data: BUSINESS_KEY             type TYP_BUSINESS_KEY.

  BUSINESS_KEY = I_KEY.

*&lt; Generated from mapping:
  call method CREATE_PERSISTENT
       exporting I_ZEDREQNB = BUSINESS_KEY-ZEDREQNB
       receiving RESULT = RESULT.
*&gt;

           &quot;IF_OS_FACTORY~CREATE_PERSISTENT_BY_KEY
  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_FACTORY~CREATE_TRANSIENT_BY_KEY">
   <source>method IF_OS_FACTORY~CREATE_TRANSIENT_BY_KEY.
***BUILD 093901
*      importing I_KEY type any
*      returning result type ref to object
************************************************************************
* Purpose        : Create a new transient object identified by the
*                  given business key
*
* Version        : 2.0
*
* Precondition   : No object exists with the given business key
*
* Postcondition  : The object exists in memory
*
* OO Exceptions  : propagates CREATE_TRANSIENT
*
* Implementation : call CREATE_TRANSIENT
*
************************************************************************
* Changelog:
* - 2001-01-01   : (SB)  Initial Version 2.0
************************************************************************

  data: BUSINESS_KEY             type TYP_BUSINESS_KEY.

  BUSINESS_KEY = I_KEY.

*&lt; Generated from mapping:
  call method CREATE_TRANSIENT
       exporting I_ZEDREQNB = BUSINESS_KEY-ZEDREQNB
       receiving RESULT = RESULT.
*&gt;

           &quot;IF_OS_FACTORY~CREATE_TRANSIENT_BY_KEY
  endmethod.</source>
  </interfaceMethod>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_PERSISTENT" VERSION="1" LANGU="F" DESCRIPT="Génère nouvel objet persistant avec clé" EXPOSURE="2" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_PERSISTENT" SCONAME="I_ZEDREQNB" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_PERSISTENT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Nouvel objet persistant généré" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TRANSPORT_REQUEST_WORKFLOW"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_PERSISTENT" SCONAME="CX_OS_OBJECT_EXISTING" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method CREATE_PERSISTENT.
***BUILD 093901
*      IMPORTING I_ZEDREQNB TYPE ZEDREQNB
*      RETURNING RESULT TYPE REF TO ZCL_TRANSPORT_REQUEST_WORKFLOW
************************************************************************
* Purpose        : Create a new persistent object identified by the
*                  given business key
*
* Version        : 2.0
*
* Precondition   : No object exists with the given business key, neither
*                  in memory nor on database.
*
* Postcondition  : The object exists in memory and will result in a
*                  new entry on database when the top transaction is
*                  closed.
*
* OO Exceptions  : CX_OS_OBJECT_EXISTING(
*                            PERSISTENT_CREATING_PERSISTENT,
*                            TRANSIENT_CREATING_PERSISTENT)
*                  propagates OS_PM_CREATED_PERSISTENT
*
* Implementation : 1. Check if there is already an object with the
*                     same key
*                  2. If there is one, let OS_PM_HANDLE_CREATE_ON_EXIST
*                     decide if it is allowed to re-use the object
*                  3. If there is none, create a new object
*                  4. Set Attributes
*                  5. Register the object as NEW and initialize it
*                  6. Clean up
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version 2.0
* - 2000-08-03   : (SB)  OO Exceptions
* - 2001-01-10   : (SB)  persistent attributes as optional parameters
* - 2001-10-30   : (SB)  type mapping
* - 2002-01-17   : (SB)  private attributes in super classes
* - 2003-04-28   : (SB)  reuse of instances reimplemented
************************************************************************

  data: THE_OBJECT   type        TYP_OBJECT_REF,
        BUSINESS_KEY type        TYP_BUSINESS_KEY,
        BKEY_STRING  type        STRING.

  data: TEMP_CURRENT_OBJECT_IREF type ref to object.

  clear CURRENT_OBJECT_IREF.

*&lt; Generated from mapping:
  BUSINESS_KEY-ZEDREQNB = I_ZEDREQNB.
*&gt;

* * 1. Check if there is already an object with this key
  read table SPECIAL_BKEY_TAB into CURRENT_SPECIAL_OBJECT_INFO
       with table key BUSINESS_KEY = BUSINESS_KEY.

  if ( SY-SUBRC = 0 ).

    read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
         with table key
         OBJECT_ID = CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID.
    call method OS_LOAD_AND_VALIDATE_CURRENT
         exporting I_INDEX = SY-TABIX.

  endif. &quot;( entry found )

  if ( not CURRENT_OBJECT_IREF is initial ).

*   * 2. Found an entry. Check if it is allowed to re-use it
    THE_OBJECT ?= CURRENT_OBJECT_IREF.

    case CURRENT_OBJECT_INFO-PM_STATUS.

    when OSCON_OSTATUS_DELETED or
        OSCON_OSTATUS_NOT_LOADED.

      try.

*&lt;  Generated from mapping:
          THE_OBJECT-&gt;ZEDREQNB = I_ZEDREQNB.
*&gt;

          call method OS_PM_HANDLE_CREATE_ON_EXIST
               exporting I_TRANSIENT = OSCON_FALSE.

        cleanup.
          clear CURRENT_SPECIAL_OBJECT_INFO.
          call method OS_CLEAR_CURRENT.
      endtry.

    when OSCON_OSTATUS_TRANSIENT.

      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_EXISTING definition load.
      raise exception type CX_OS_OBJECT_EXISTING
        exporting
          OBJECT = TEMP_CURRENT_OBJECT_IREF
          BKEY   = BKEY_STRING
          TEXTID =
            CX_OS_OBJECT_EXISTING=&gt;TRANSIENT_CREATING_PERSISTENT.

    when others.

      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_EXISTING definition load.
      raise exception type CX_OS_OBJECT_EXISTING
        exporting
          OBJECT = TEMP_CURRENT_OBJECT_IREF
          BKEY   = BKEY_STRING
          TEXTID =
            CX_OS_OBJECT_EXISTING=&gt;PERSISTENT_CREATING_PERSISTENT.

    endcase.

  else. &quot;( No entry found )

*   * 3. Create a new object
    THE_OBJECT = PM_CREATE_REPRESENTANT(
                   I_BUSINESS_KEY = BUSINESS_KEY ).

*   * 4. Set attributes
*&lt;   Generated from mapping:
*&gt;

*   * 5. register object as &apos;NEW&apos; and initialize it.
    call method OS_PM_CREATED_PERSISTENT.

  endif. &quot;( Eintrag vorhanden )

* * 6. Clean-up
  clear CURRENT_SPECIAL_OBJECT_INFO.
  RESULT = THE_OBJECT.

           &quot;CREATE_PERSISTENT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_TRANSIENT" VERSION="1" LANGU="F" DESCRIPT="Génère objet" EXPOSURE="2" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_TRANSIENT" SCONAME="I_ZEDREQNB" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_TRANSIENT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Nouvel objet provisoire généré" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TRANSPORT_REQUEST_WORKFLOW"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CREATE_TRANSIENT" SCONAME="CX_OS_OBJECT_EXISTING" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method CREATE_TRANSIENT.
***BUILD 093901
*      IMPORTING I_ZEDREQNB TYPE ZEDREQNB
*      RETURNING RESULT TYPE REF TO ZCL_TRANSPORT_REQUEST_WORKFLOW
************************************************************************
* Purpose        : Create a new transient object identified by the
*                  given business key
*
* Version        : 2.0
*
* Precondition   : No object exists with the given business key, neither
*                  in memory nor on database.
*
* Postcondition  : The object exists in memory until it is RELEASEd
*
* OO Exceptions  : CX_OS_OBJECT_EXISTING(
*                            PERSISTENT_CREATING_TRANSIENT,
*                            TRANSIENT_CREATING_TRANSIENT)
*                  propagates OS_PM_CREATED_TRANSIENT
*
* Implementation : 1. Check if there is already an object with the
*                     same key
*                  2. If there is one, let OS_PM_HANDLE_CREATE_ON_EXIST
*                     decide if it is allowed to re-use the object
*                  3. If there is none, create a new object
*                  4. Set Attributes
*                  5. Register the object as TRANSIENT and initialize it
*                  6. Clean up
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version 2.0
* - 2000-08-02   : (SB)  OO Exceptions
* - 2001-01-10   : (SB)  persistent attributes as optional parameters
* - 2001-10-30   : (SB)  type mapping
* - 2002-01-17   : (SB)  private attributes in super classes
* - 2003-04-28   : (SB)  reuse of instances reimplemented
************************************************************************

  data: THE_OBJECT   type        TYP_OBJECT_REF,
        BUSINESS_KEY type        TYP_BUSINESS_KEY,
        BKEY_STRING  type        STRING.

  data: TEMP_CURRENT_OBJECT_IREF type ref to object.

  clear CURRENT_OBJECT_IREF.

*&lt; Generated from mapping:
  BUSINESS_KEY-ZEDREQNB = I_ZEDREQNB.
*&gt;

* * 1. Check if there is already an object with the same key

  read table SPECIAL_BKEY_TAB into CURRENT_SPECIAL_OBJECT_INFO
       with table key BUSINESS_KEY = BUSINESS_KEY.

  if ( SY-SUBRC = 0 ).

    read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
         with table key
         OBJECT_ID = CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID.
    call method OS_LOAD_AND_VALIDATE_CURRENT
         exporting I_INDEX = SY-TABIX.

  endif. &quot;( entry found )

  if ( not CURRENT_OBJECT_IREF is initial ).

*   * 2. Found an entry. Check if it is allowed to re-use it
    THE_OBJECT ?= CURRENT_OBJECT_IREF.

    case CURRENT_OBJECT_INFO-PM_STATUS.

    when OSCON_OSTATUS_DELETED or
        OSCON_OSTATUS_NOT_LOADED.

      try.

*&lt;  Generated from mapping:
          THE_OBJECT-&gt;ZEDREQNB = I_ZEDREQNB.
*&gt;

          call method OS_PM_HANDLE_CREATE_ON_EXIST
               exporting I_TRANSIENT = OSCON_TRUE.

        cleanup.
          clear CURRENT_SPECIAL_OBJECT_INFO.
          call method OS_CLEAR_CURRENT.
      endtry.

    when OSCON_OSTATUS_TRANSIENT.

      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_EXISTING definition load.
      raise exception type CX_OS_OBJECT_EXISTING
        exporting
          OBJECT = TEMP_CURRENT_OBJECT_IREF
          BKEY   = BKEY_STRING
          TEXTID =
            CX_OS_OBJECT_EXISTING=&gt;TRANSIENT_CREATING_TRANSIENT.

    when others.

      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_EXISTING definition load.
      raise exception type CX_OS_OBJECT_EXISTING
        exporting
          OBJECT = TEMP_CURRENT_OBJECT_IREF
          BKEY   = BKEY_STRING
          TEXTID =
            CX_OS_OBJECT_EXISTING=&gt;PERSISTENT_CREATING_TRANSIENT.

    endcase.

  else. &quot;( Noch kein Eintrag )

*   * 3. If there is none, create a new object
    THE_OBJECT = PM_CREATE_REPRESENTANT(
                   I_BUSINESS_KEY = BUSINESS_KEY ).

*   * 4. Set attributes
*&lt;   Generated from mapping:
*&gt;

*   * 5. Register the object as TRANSIENT and initialize it
    call method OS_PM_CREATED_TRANSIENT.

  endif. &quot;( Eintrag vorhanden )

* * 6. Clean up
  clear CURRENT_SPECIAL_OBJECT_INFO.
  RESULT = THE_OBJECT.

           &quot;CREATE_TRANSIENT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="DELETE_PERSISTENT" VERSION="1" LANGU="F" DESCRIPT="Supprime objet persistant avec clé" EXPOSURE="2" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="DELETE_PERSISTENT" SCONAME="I_ZEDREQNB" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="DELETE_PERSISTENT" SCONAME="CX_OS_OBJECT_NOT_EXISTING" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method DELETE_PERSISTENT.
***BUILD 093901
*      IMPORTING I_ZEDREQNB TYPE ZEDREQNB.
*      raising   CX_OS_OBJECT_NOT_EXISTING
************************************************************************
* Purpose        : Delete persistent object. It is marked DELETED in
*                  memory and removed from DB when the top transaction
*                  is closed.
*
* Version        : 2.0
*
* Precondition   : The object is persistent (not transient)
*
* Postcondition  : Instance is marked for deletion.
*
* OO Exceptions  : CX_OS_OBJECT_NOT_EXISTING(TRANSIENT_BY_BKEY,
*                  CREATED_AND_DELETED_BY_BKEY,BY_BKEY)
*                  ( propagates PM_LOAD_AND_SET_ATTRIBUTES )
*                  propagates PM_DELETE_PERSISTENT
*
* Implementation : 1. Check if there is already an object with that
*                     business key
*                  2. If not: create representative object and check
*                     if there is an entry on DB (Need to be sure that
*                     no other object exists with the OID that belongs
*                     to the given Business Key)
*                  3. If it already exists: call PM_DELETE_PERSISTENT
*
************************************************************************
* Changelog:
* - 1999-09-21   : (OS)  Initial Version
* - 2000-03-06   : (BGR) Version 2.0
* - 2000-08-03   : (SB)  OO Exceptions
* - 2000-10-30   : (SB)  Type Mapping
************************************************************************

  data: BUSINESS_KEY type TYP_BUSINESS_KEY .
  data: EX_OS_OBJECT_NOT_FOUND type ref to CX_OS_OBJECT_NOT_FOUND.
  data: EX_OS_OBJECT_STATE type ref to CX_OS_OBJECT_STATE.
  data: BKEY_STRING type STRING.

* 1. Check if there is already an object with that business key

  clear: CURRENT_OBJECT_IREF,
         CURRENT_SPECIAL_OBJECT_INFO.

*&lt; Generated from mapping:
  BUSINESS_KEY-ZEDREQNB = I_ZEDREQNB.
*&gt;

  read table SPECIAL_BKEY_TAB into CURRENT_SPECIAL_OBJECT_INFO
       with table key BUSINESS_KEY = BUSINESS_KEY.

  if ( SY-SUBRC = 0 ).

    read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
         with table key
         OBJECT_ID = CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID.
    call method OS_LOAD_AND_VALIDATE_CURRENT
         exporting I_INDEX = SY-TABIX.

  endif.

  if ( CURRENT_OBJECT_IREF is initial ).

*   * 2. If not: create representative object and check
*   *    if there is an entry on DB (Need to be sure that
*   *    no other object exists with the OID that belongs
*   *    to the given Business Key)

    try.

        call method PM_LOAD_AND_SET_ATTRIBUTES
             exporting I_BUSINESS_KEY = BUSINESS_KEY.

      catch CX_OS_OBJECT_NOT_FOUND into EX_OS_OBJECT_NOT_FOUND.
*       * If the object is not found by key - raise object not existing
*       * by key. If a reference has a illegal class GUID (i.e. object
*       * not found by ref error) - ignore.
        if ( EX_OS_OBJECT_NOT_FOUND-&gt;TEXTID =
             CX_OS_OBJECT_NOT_FOUND=&gt;BY_BKEY ).
          call method OS_CLEAR_CURRENT.
          class CX_OS_OBJECT_NOT_EXISTING definition load.
          raise exception type CX_OS_OBJECT_NOT_EXISTING
            exporting
              BKEY   = EX_OS_OBJECT_NOT_FOUND-&gt;BKEY
              TABLE  = EX_OS_OBJECT_NOT_FOUND-&gt;TABLE
              TEXTID = CX_OS_OBJECT_NOT_EXISTING=&gt;BY_BKEY.
        endif.

      cleanup.
        call method OS_CLEAR_CURRENT.

    endtry.



  endif.&quot; ( No Entry in administrative data? )


* * 3. If it already exists: call PM_DELETE_PERSISTENT
  if not ( CURRENT_OBJECT_IREF is initial ).

    try.

        call method PM_DELETE_PERSISTENT.

      catch CX_OS_OBJECT_STATE into EX_OS_OBJECT_STATE.
      if ( EX_OS_OBJECT_STATE-&gt;TEXTID =
           CX_OS_OBJECT_STATE=&gt;TRANSIENT ).
        BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
        class CX_OS_OBJECT_NOT_EXISTING definition load.
        raise exception type CX_OS_OBJECT_NOT_EXISTING
          exporting
            BKEY   = BKEY_STRING
            TEXTID = CX_OS_OBJECT_NOT_EXISTING=&gt;TRANSIENT_BY_BKEY.
      endif.

      if ( EX_OS_OBJECT_STATE-&gt;TEXTID =
           CX_OS_OBJECT_STATE=&gt;CREATED_AND_DELETED ).
        BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
        class CX_OS_OBJECT_NOT_EXISTING definition load.
        raise exception type CX_OS_OBJECT_NOT_EXISTING
          exporting
            BKEY   = BKEY_STRING
            TEXTID =
              CX_OS_OBJECT_NOT_EXISTING=&gt;CREATED_AND_DELETED_BY_BKEY.
      endif.

    endtry.

  endif.
           &quot;DELETE_PERSISTENT
  endmethod.</source>
  </method>
  <method CLSNAME="CL_OS_CA_COMMON" CMPNAME="DELETE_SPECIAL_OBJECT_INFO" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method DELETE_SPECIAL_OBJECT_INFO.
***BUILD 090501
************************************************************************
* Purpose        : Delete current entry SPECIAL_OBJECT_INFO
*
* Version        : 2.0
*
* Precondition   : Index is set in CURRENT_OBJECT_INDEX
*
* Postcondition  : entry is deleted
*
* OO Exceptions  : --
*
* Implementation :
*
************************************************************************
* Changelog:
* - 2000-03-02   : (BGR) Initial Version
* - 2001-10-30   : (SB)  Type Mapping
************************************************************************

  read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
       index CURRENT_OBJECT_INDEX.

  delete table SPECIAL_BKEY_TAB
    with table key
      BUSINESS_KEY = CURRENT_SPECIAL_OBJECT_INFO-BUSINESS_KEY.

  delete SPECIAL_OBJECT_INFO index CURRENT_OBJECT_INDEX.
  clear CURRENT_SPECIAL_OBJECT_INFO.

           &quot;DELETE_SPECIAL_OBJECT_INFO
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_PERSISTENT" VERSION="1" LANGU="F" DESCRIPT="Accède à objet persistant avec clé" EXPOSURE="2" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_PERSISTENT" SCONAME="I_ZEDREQNB" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_PERSISTENT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Objet persistant" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TRANSPORT_REQUEST_WORKFLOW"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_PERSISTENT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method GET_PERSISTENT.
***BUILD 093901
*      importing I_ZEDREQNB TYPE ZEDREQNB.
*      returning RESULT TYPE REF TO ZCL_TRANSPORT_REQUEST_WORKFLOW
*       raising   CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get reference of an persistent object.
*
* Version        : 2.0
*
* Precondition   : --
*
* Postcondition  : Persistent object is active
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*                    (IS_TRANSIENT_BY_BKEY,DELETED_BY_BKEY)
*                  propagates PM_LOAD_AND_SET_ATTRIBUTES
*                  propagates OS_PM_LOADED_PERISISTENT
*
* Implementation : 1. Look for object in SPECIAL_OBJECT_INFO. If found,
*                     check if it is still valid
*                  2. Object found: Check PM_STATUS
*                     2a. If Status is TRANSIENT or DELETED, error!
*                     2b. If Status is NOT_LOADED, continue with 3.
*                     2c. If Status is NEW, LOADED or CHANGED, success!
*                  3. Load object data from database and set object
*                  3.a. Completion in super class
*                  4. clean up
*
************************************************************************
* Changelog:
* - 1999-09-21   : (OS)  Initial Version
* - 2000-03-07   : (BGR) Version 2.0 - Common Superclass
* - 2000-08-02   : (SB)  OO Exceptions
* - 2000-10-30   : (SB)  Type Mapping
* - 2004-01-21   : (SB)  Type Mapping Refactoring
************************************************************************

  data: BUSINESS_KEY    type TYP_BUSINESS_KEY,
        FLAG_NOT_LOADED type OS_BOOLEAN,
        BKEY_STRING     type STRING.

  data: TEMP_CURRENT_OBJECT_IREF type ref to OBJECT.

* * 1. Look for object in SPECIAL_OBJECT_INFO. If found, check if it
* * is still valid

  clear:  CURRENT_OBJECT_IREF.

*&lt; Generated from mapping:
  BUSINESS_KEY-ZEDREQNB = I_ZEDREQNB.
*&gt;

  read table SPECIAL_BKEY_TAB into CURRENT_SPECIAL_OBJECT_INFO
       with table key BUSINESS_KEY = BUSINESS_KEY.

  if ( SY-SUBRC = 0 ).

    read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
         with table key
         OBJECT_ID = CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID.
    call method OS_LOAD_AND_VALIDATE_CURRENT
         exporting I_INDEX = SY-TABIX.

  endif.

  if ( not CURRENT_OBJECT_IREF is initial ).

* * 2. Object found: Check PM_STATUS

    case CURRENT_OBJECT_INFO-PM_STATUS.

*   * 2a. If Status is TRANSIENT or DELETED, error!
    when OSCON_OSTATUS_DELETED.

*!!!!! Error: Object activation failed - Object marked for deletion
      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_NOT_FOUND definition load.
      raise exception type CX_OS_OBJECT_NOT_FOUND
        exporting
          OBJECT = TEMP_CURRENT_OBJECT_IREF
          BKEY   = BKEY_STRING
          TEXTID = CX_OS_OBJECT_NOT_FOUND=&gt;DELETED_BY_BKEY.

    when OSCON_OSTATUS_TRANSIENT.

*!!!!! Error: Object activation failed - Object is transient
      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_NOT_FOUND definition load.
      raise exception type CX_OS_OBJECT_NOT_FOUND
        exporting
          OBJECT = TEMP_CURRENT_OBJECT_IREF
          BKEY   = BKEY_STRING
          TEXTID = CX_OS_OBJECT_NOT_FOUND=&gt;IS_TRANSIENT_BY_BKEY.


*   * 2b. If Status is NOT_LOADED, continue with 3.
    when OSCON_OSTATUS_NOT_LOADED.

      FLAG_NOT_LOADED      = OSCON_TRUE.

*   * 2c. If Status is NEW, LOADED or CHANGED, success!
    when others.

      FLAG_NOT_LOADED      = OSCON_FALSE.

    endcase. &quot;PM_STATUS

  else.&quot; ( CURRENT_OBJECT_IREF is initial ).

    FLAG_NOT_LOADED      = OSCON_TRUE.

  endif.&quot; ( Entry in administrative data? )

* * 3. Load object data from database and set object

  if (  FLAG_NOT_LOADED = OSCON_TRUE ).

*   * internal Undo
    append INTERNAL_NEXT_UNDO_INFO to INTERNAL_TRANSACTION_STACK.
    INTERNAL_CURRENT_TRANSACTION = SY-TABIX.

    try.
        call method PM_LOAD_AND_SET_ATTRIBUTES
             exporting I_BUSINESS_KEY = BUSINESS_KEY.

        result ?= CURRENT_OBJECT_IREF.

*       * 3.a. Completion in super class
        call method OS_PM_LOADED_PERSISTENT.

      cleanup.
        call method OS_INTERNAL_UNDO.
        call method OS_CLEAR_CURRENT.
        clear CURRENT_SPECIAL_OBJECT_INFO.
    endtry.

*   * Clean-up internal Undo
    delete INTERNAL_TRANSACTION_STACK
           index INTERNAL_CURRENT_TRANSACTION.
    add -1 to INTERNAL_CURRENT_TRANSACTION.
    if ( INTERNAL_TRANSACTION_STACK is initial ).
      clear INTERNAL_UNDO_INFO.
      INTERNAL_NEXT_UNDO_INFO = 1.
    endif. &quot;( INTERNAL_TRANSACTION_STACK is initial? )

  else. &quot;( Object already loaded )

    RESULT ?= CURRENT_OBJECT_IREF.
    call method OS_CLEAR_CURRENT.

  endif. &quot;( Loading necessesary? )

* * 4. clean up

  clear  CURRENT_SPECIAL_OBJECT_INFO.


           &quot;GET_PERSISTENT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_TRANSIENT" VERSION="1" LANGU="F" DESCRIPT="Détermine objet provisoire avec clé" EXPOSURE="2" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_TRANSIENT" SCONAME="I_ZEDREQNB" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_TRANSIENT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Objet provisoire" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_TRANSPORT_REQUEST_WORKFLOW"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_TRANSIENT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method GET_TRANSIENT.
***BUILD 093901
*      IMPORTING I_ZEDREQNB TYPE ZEDREQNB.
*      RETURNING RESULT TYPE REF TO ZCL_TRANSPORT_REQUEST_WORKFLOW
*       raising   CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get reference of an transient object.
*
* Version        : 2.0
*
* Precondition   : object has been created transient
*
* Postcondition  : --
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*                  (TRANSIENT_BY_BKEY, IS_PERSISTENT_BY_BKEY)
*
* Implementation : 1. look for entry in SPECIAL_OBJECT_INFO and check
*                     if it is still valid
*                  2. If it not valid or no object found: Error
*                  3. If it is valid: Check state
*                    3a. Not Transient: Error!
*                    3b. Transient: Success!
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version
* - 2000-08-03   : (SB)  OO Exceptions
* - 2000-10-30   : (SB)  Type Mapping
************************************************************************

  data: BUSINESS_KEY type TYP_BUSINESS_KEY,
        BKEY_STRING  type STRING .

  data: TEMP_CURRENT_OBJECT_IREF type ref to OBJECT.

* * 1. look for entry in SPECIAL_OBJECT_INFO and check if it is
* *    still valid

  clear CURRENT_OBJECT_IREF.

*&lt; Generated from mapping:
  BUSINESS_KEY-ZEDREQNB = I_ZEDREQNB.
*&gt;

  read table SPECIAL_BKEY_TAB into CURRENT_SPECIAL_OBJECT_INFO
       with table KEY BUSINESS_KEY = BUSINESS_KEY.

  if ( SY-SUBRC = 0 ).

    read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
         with table key
         OBJECT_ID = CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID.
    call method OS_LOAD_AND_VALIDATE_CURRENT
         exporting I_INDEX = SY-TABIX.

  endif.

* * 2. If it not valid or no object found: Error
  if ( CURRENT_OBJECT_IREF is initial ).

*!!! Error: Object activation failed - no entry in administrative data
    BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
    clear CURRENT_SPECIAL_OBJECT_INFO.
    class CX_OS_OBJECT_NOT_FOUND definition load.
    raise exception type CX_OS_OBJECT_NOT_FOUND
      exporting
        BKEY   = BKEY_STRING
        TEXTID = CX_OS_OBJECT_NOT_FOUND=&gt;TRANSIENT_BY_BKEY.

  else. &quot;( Entry exists )

*   * 3. If it is valid: Check state
    if ( CURRENT_OBJECT_INFO-PM_STATUS &lt;&gt; OSCON_OSTATUS_TRANSIENT ).

*     * 3a. Not Transient: Error!
*!!!!! Error: Object is not transient
      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      BKEY_STRING  = MAP_SERIALIZE_BKEY( BUSINESS_KEY ).
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_NOT_FOUND definition load.
      raise exception type CX_OS_OBJECT_NOT_FOUND
        exporting
          OBJECT = TEMP_CURRENT_OBJECT_IREF
          BKEY   = BKEY_STRING
          TEXTID = CX_OS_OBJECT_NOT_FOUND=&gt;IS_PERSISTENT_BY_BKEY.

    endif. &quot;( PM_STATUS &lt;&gt; transient )

  endif.&quot; ( Entry in administrative data? )

* * 3b. Transient: Success!
  RESULT ?= CURRENT_OBJECT_IREF.
  call method OS_CLEAR_CURRENT.
  clear CURRENT_SPECIAL_OBJECT_INFO.

           &quot;GET_TRANSIENT
  endmethod.</source>
  </method>
  <method CLSNAME="CL_OS_CA_COMMON" CMPNAME="LOAD_SPECIAL_OBJECT_INFO" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method LOAD_SPECIAL_OBJECT_INFO.
***BUILD 090501
************************************************************************
* Purpose        : Load CURRENT_SPECIAL_OBJECT_INFO from
*                  SPECIAL_OBJECT_INFO
*
* Version        : 2.0
*
* Precondition   : Index is set in CURRENT_OBJECT_INDEX
*
* Postcondition  : entry is loaded
*
* OO Exceptions  : -
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-02   : (BGR) Initial Version
************************************************************************

  read table SPECIAL_OBJECT_INFO into CURRENT_SPECIAL_OBJECT_INFO
       index CURRENT_OBJECT_INDEX.

           &quot;LOAD_SPECIAL_OBJECT_INFO
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_EXTRACT_IDENTIFIER" VERSION="1" LANGU="F" DESCRIPT="Extrait clé de gestion de données BD" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_EXTRACT_IDENTIFIER" SCONAME="I_DB_DATA" VERSION="1" LANGU="F" DESCRIPT="Données d&apos;objet lues de la BD" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_DB_DATA"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_EXTRACT_IDENTIFIER" SCONAME="E_BUSINESS_KEY" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion extraite de données BD" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="TYP_BUSINESS_KEY"/>
   <source>method MAP_EXTRACT_IDENTIFIER.
***BUILD 093901
     &quot; importing I_DB_DATA type TYP_DB_DATA
     &quot; exporting E_BUSINESS_KEY type TYP_BUSINESS_KEY
************************************************************************
* Purpose        : Extract Business Key from given DB_DATA
*
* Version        : 2.0
*
* Precondition   : DB_DATA is a structure with object data read from
*                  DB including Keys and GUID
*
* Postcondition  : E_BUSINESS_KEY is the business key extracted from
*                  I_DB_DATA
*
* OO Exceptions  : --
*
* Implementation :
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version
* - 2000-08-02   : (SB) OO Exceptions
************************************************************************
* Generated! Do not modify!
************************************************************************

*&lt;Generated from mapping:
  E_BUSINESS_KEY-ZEDREQNB  = I_DB_DATA-ZEDREQNB.
*&gt;

           &quot;MAP_EXTRACT_IDENTIFIER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_GET_ATTRIBUTES" VERSION="1" LANGU="F" DESCRIPT="Lit attributs persistants d&apos;un objet" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_GET_ATTRIBUTES" SCONAME="I_OBJECT_REF_TAB" VERSION="1" LANGU="F" DESCRIPT="Liste des objets concernés" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_OBJECT_REF_TAB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_GET_ATTRIBUTES" SCONAME="E_OBJECT_DATA_TAB" VERSION="1" LANGU="F" DESCRIPT="Données d&apos;objet lues" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="TYP_DB_DATA_TAB"/>
   <source>method MAP_GET_ATTRIBUTES.
***BUILD 093901
     &quot; importing I_OBJECT_REF_TAB  type TYP_OBJECT_REF_TAB
     &quot; exporting value(E_OBJECT_DATA_TAB) type TYP_DB_DATA_TAB
************************************************************************
* Purpose        : Get object data from objects
*
* Version        : 2.0
*
* Precondition   : I_OBJECT_REF_TAB is a list of objects that have a
*                  valid state (new, changed)
*
* Postcondition  : E_OBJECT_DATA_TAB contains all object data of the
*                  given objects. It is a table of the same size like
*                  I_OBJECT_REF_TAB with corresponding entries.
*                  GUID (and Business Key) will be added later.
*
* OO Exceptions  : CX_OS_OBJECT_REFERENCE collects GET_OID_BY_REF
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version
* - 2000-08-03   : (SB)  OO Exceptions
* - 2002-01-17   : (SB)  private attributes in super classes
************************************************************************
* Generated! Do not modify!
************************************************************************

  data: THE_OBJECT type ref to ZCL_TRANSPORT_REQUEST_WORKFLOW,
        OBJECT_DATA_ITEM type TYP_DB_DATA,
        PM_SERVICE       type ref to IF_OS_PM_SERVICE. &quot;#EC NEEDED

  data: EX     type ref to CX_OS_ERROR, &quot;#EC NEEDED
        EX_SYS type ref to CX_OS_SYSTEM_ERROR, &quot;#EC NEEDED
        EX_TAB type OSTABLEREF.

  PM_SERVICE ?= PERSISTENCY_MANAGER.

  loop at I_OBJECT_REF_TAB into THE_OBJECT.

    clear OBJECT_DATA_ITEM.

*&lt;  Generated from mapping:
    OBJECT_DATA_ITEM-ZEDREQNB = THE_OBJECT-&gt;ZEDREQNB.
    OBJECT_DATA_ITEM-ZEDLANGU = THE_OBJECT-&gt;ZEDLANGU.
    OBJECT_DATA_ITEM-ZEDSOURSYS = THE_OBJECT-&gt;ZEDSOURSYS.
    OBJECT_DATA_ITEM-ZEDSOURMDT = THE_OBJECT-&gt;ZEDSOURMDT.
    OBJECT_DATA_ITEM-ZEDTARGSYS = THE_OBJECT-&gt;ZEDTARGSYS.
    OBJECT_DATA_ITEM-ZEDTRPDATE = THE_OBJECT-&gt;ZEDTRPDATE.
    OBJECT_DATA_ITEM-ZEDTRPTIME = THE_OBJECT-&gt;ZEDTRPTIME.
    OBJECT_DATA_ITEM-ZEDTRPCODE = THE_OBJECT-&gt;ZEDTRPCODE.
    OBJECT_DATA_ITEM-ZEDTRPTYPE = THE_OBJECT-&gt;ZEDTRPTYPE.
    OBJECT_DATA_ITEM-ZEDREQUSER = THE_OBJECT-&gt;ZEDREQUSER.
    OBJECT_DATA_ITEM-ZEDREQDATE = THE_OBJECT-&gt;ZEDREQDATE.
    OBJECT_DATA_ITEM-ZEDREQTIME = THE_OBJECT-&gt;ZEDREQTIME.
    OBJECT_DATA_ITEM-ZEDMODUSER = THE_OBJECT-&gt;ZEDMODUSER.
    OBJECT_DATA_ITEM-ZEDMODDATE = THE_OBJECT-&gt;ZEDMODDATE.
    OBJECT_DATA_ITEM-ZEDMODTIME = THE_OBJECT-&gt;ZEDMODTIME.
    OBJECT_DATA_ITEM-ZEDVALCODE = THE_OBJECT-&gt;ZEDVALCODE.
    OBJECT_DATA_ITEM-ZEDVALUSER = THE_OBJECT-&gt;ZEDVALUSER.
    OBJECT_DATA_ITEM-ZEDVALDATE = THE_OBJECT-&gt;ZEDVALDATE.
    OBJECT_DATA_ITEM-ZEDVALTIME = THE_OBJECT-&gt;ZEDVALTIME.
    OBJECT_DATA_ITEM-ZEDTRTDATE = THE_OBJECT-&gt;ZEDTRTDATE.
    OBJECT_DATA_ITEM-ZEDTRTTIME = THE_OBJECT-&gt;ZEDTRTTIME.
    OBJECT_DATA_ITEM-ZEDUGROUP = THE_OBJECT-&gt;ZEDUGROUP.
    OBJECT_DATA_ITEM-ZEDFUNAREA = THE_OBJECT-&gt;ZEDFUNAREA.
    OBJECT_DATA_ITEM-ZEDQUERY = THE_OBJECT-&gt;ZEDQUERY.
    OBJECT_DATA_ITEM-ZEDQTRPCOD = THE_OBJECT-&gt;ZEDQTRPCOD.
    OBJECT_DATA_ITEM-ZEDIMPORT = THE_OBJECT-&gt;ZEDIMPORT.
    OBJECT_DATA_ITEM-ZEDCOMMENT = THE_OBJECT-&gt;ZEDCOMMENT.
    OBJECT_DATA_ITEM-ZEDREPROC = THE_OBJECT-&gt;ZEDREPROC.
    OBJECT_DATA_ITEM-ZEDVALFT2 = THE_OBJECT-&gt;ZEDVALFT2.
    OBJECT_DATA_ITEM-ZEDVALFT2DATE = THE_OBJECT-&gt;ZEDVALFT2DATE.
    OBJECT_DATA_ITEM-ZEDELIGIBLE = THE_OBJECT-&gt;ZEDELIGIBLE.
*&gt;

    APPEND OBJECT_DATA_ITEM TO E_OBJECT_DATA_TAB.

  endloop.&quot;at I_OBJECT_REF_TAB

  if ( not EX_TAB is initial ).
    raise exception type CX_OS_OBJECT_REFERENCE
          exporting EXCEPTION_TAB = EX_TAB.
  endif.

           &quot;MAP_GET_ATTRIBUTES
endmethod.
&quot;#EC CI_VALPAR</source>
  </method>
  <method CLSNAME="CL_OS_CA_COMMON" CMPNAME="MAP_INVALIDATE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method MAP_INVALIDATE.
***BUILD 093901
     &quot; importing I_OBJECT_IREF_TAB type TYP_OBJECT_TAB
************************************************************************
* Purpose        : Invalidate state of all objects in I_OBJECT_IREF_TAB
*
* Version        : 2.0
*
* Precondition   : Objects in I_OBJECT_IREF_TAB exist
*
* Postcondition  : Their state in cleared
*
* OO Exceptions  : -
*
* Implementation : - call method IF_OS_STATE~INVALIDATE
*                  - clear object&apos;s (persistent) attributes
*
************************************************************************
* Changelog:
* - 2000-04-17   : (BGR) Initial Version
* - 2000-08-02   : (SB)  OO Exceptions
* - 2002-01-17   : (SB)  private attributes in super classes
************************************************************************

  data: OBJECT_IREF type TYP_OBJECT_IREF,
        THE_OBJECT  type ref TO ZCL_TRANSPORT_REQUEST_WORKFLOW.

  loop at I_OBJECT_IREF_TAB into OBJECT_IREF.

    if ( not OBJECT_IREF is initial ).

      call method OBJECT_IREF-&gt;INVALIDATE.

      THE_OBJECT ?= OBJECT_IREF.

*&lt;    Generated from Mapping:
      clear: THE_OBJECT-&gt;ZEDREQNB,
             THE_OBJECT-&gt;ZEDLANGU,
             THE_OBJECT-&gt;ZEDSOURSYS,
             THE_OBJECT-&gt;ZEDSOURMDT,
             THE_OBJECT-&gt;ZEDTARGSYS,
             THE_OBJECT-&gt;ZEDTRPDATE,
             THE_OBJECT-&gt;ZEDTRPTIME,
             THE_OBJECT-&gt;ZEDTRPCODE,
             THE_OBJECT-&gt;ZEDTRPTYPE,
             THE_OBJECT-&gt;ZEDREQUSER,
             THE_OBJECT-&gt;ZEDREQDATE,
             THE_OBJECT-&gt;ZEDREQTIME,
             THE_OBJECT-&gt;ZEDMODUSER,
             THE_OBJECT-&gt;ZEDMODDATE,
             THE_OBJECT-&gt;ZEDMODTIME,
             THE_OBJECT-&gt;ZEDVALCODE,
             THE_OBJECT-&gt;ZEDVALUSER,
             THE_OBJECT-&gt;ZEDVALDATE,
             THE_OBJECT-&gt;ZEDVALTIME,
             THE_OBJECT-&gt;ZEDTRTDATE,
             THE_OBJECT-&gt;ZEDTRTTIME,
             THE_OBJECT-&gt;ZEDUGROUP,
             THE_OBJECT-&gt;ZEDFUNAREA,
             THE_OBJECT-&gt;ZEDQUERY,
             THE_OBJECT-&gt;ZEDQTRPCOD,
             THE_OBJECT-&gt;ZEDIMPORT,
             THE_OBJECT-&gt;ZEDCOMMENT,
             THE_OBJECT-&gt;ZEDREPROC,
             THE_OBJECT-&gt;ZEDVALFT2,
             THE_OBJECT-&gt;ZEDVALFT2DATE,
             THE_OBJECT-&gt;ZEDELIGIBLE.
*&gt;

    endif. &quot;( not initial )

  endloop. &quot;at I_OBJECT_IREF_TAB

           &quot;MAP_INVALIDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_LOAD_FROM_DATABASE_KEY" VERSION="1" LANGU="F" DESCRIPT="Lit données d&apos;objets identifiées de BD via clé de gestion" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_LOAD_FROM_DATABASE_KEY" SCONAME="I_BUSINESS_KEY_TAB" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion relative aux données à charger" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_BUSINESS_KEY_TAB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_LOAD_FROM_DATABASE_KEY" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Données d&apos;objet lues de BD" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TYP_DB_DATA_TAB"/>
   <source>method MAP_LOAD_FROM_DATABASE_KEY.
***BUILD 093901
     &quot; importing I_BUSINESS_KEY_TAB type TYP_BUSINESS_KEY_TAB
     &quot; returning value(RESULT) type TYP_DB_DATA_TAB
************************************************************************
* Purpose        : Load object data identified by I_BUSINESS_KEY_TAB
*                  from DB to DB_DATA Table
*
* Version        : 2.0
*
* Precondition   : I_BUSINESS_KEY_TAB is a table of valid business keys
*
* Postcondition  : RESULT is the corresponding table of object
*                  attributes read from DB
*
* OO Exceptions  : CX_OS_DB_SELECT
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 1999-09-21   : (OS)  Initial Version
* - 2000-03-06   : (BGR) Version 2.0 - difference between loading 1 and
*                  many entries
* - 2000-06-15   : (BGR) Support for multi-table loading
* - 2000-08-03   : (SB)  OO Exceptions
* - 2001-03-27   : (MWI) Loading several objects (type mapping)
* - 2001-11-26   : (SB)  Refactoring Generation
* - 2002-01-17   : (SB)  Bugfix for tables with namespace
* - 2002-01-17   : (SB)  private attributes in super classes
* - 2004-01-07   : (SB)  Multi Access
* - 2005-02-22   : (SB)  Inner Joins
* - 2005-04-06   : (SB)  Single Table
************************************************************************


  data: DB_DATA           type TYP_DB_DATA.

*&lt; Generated from mapping:
  types: TYP_DB_DATA_LOCAL type ZTBREQUEST.
*&gt;

  types:
    TYP_DB_DATA_LOCAL_TAB type standard table of
      TYP_DB_DATA_LOCAL with non-unique default key .

  data: DB_DATA_LOCAL_TAB type TYP_DB_DATA_LOCAL_TAB.

  field-symbols: &lt;FS_DB_DATA_LOCAL&gt; type TYP_DB_DATA_LOCAL.

*&lt; Generated from mapping:
  field-symbols: &lt;FS_DB_ZTBREQUEST&gt; type ZTBREQUEST.
*&gt;

*&lt; Generated from mapping:
  select * from ZTBREQUEST
           into table DB_DATA_LOCAL_TAB
           for all entries in I_BUSINESS_KEY_TAB
           where ZTBREQUEST~ZEDREQNB = I_BUSINESS_KEY_TAB-ZEDREQNB.
*&gt;

* * error handling
  if ( SY-SUBRC &lt;&gt; 0 ).
    class CX_OS_DB_SELECT definition load.
    raise exception type CX_OS_DB_SELECT
         exporting TABLE  = &apos;ZTBREQUEST&apos;
                   TEXTID = CX_OS_DB_SELECT=&gt;BY_BKEYTAB.
  endif. &quot;( Error )

  loop at DB_DATA_LOCAL_TAB assigning &lt;FS_DB_DATA_LOCAL&gt;.

    assign &lt;FS_DB_DATA_LOCAL&gt; to &lt;FS_DB_ZTBREQUEST&gt;.

*&lt; Generated from mapping:
    DB_DATA-ZEDREQNB = &lt;FS_DB_ZTBREQUEST&gt;-ZEDREQNB.
    DB_DATA-ZEDLANGU = &lt;FS_DB_ZTBREQUEST&gt;-ZEDLANGU.
    DB_DATA-ZEDSOURSYS = &lt;FS_DB_ZTBREQUEST&gt;-ZEDSOURSYS.
    DB_DATA-ZEDSOURMDT = &lt;FS_DB_ZTBREQUEST&gt;-ZEDSOURMDT.
    DB_DATA-ZEDTARGSYS = &lt;FS_DB_ZTBREQUEST&gt;-ZEDTARGSYS.
    DB_DATA-ZEDTRPDATE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDTRPDATE.
    DB_DATA-ZEDTRPTIME = &lt;FS_DB_ZTBREQUEST&gt;-ZEDTRPTIME.
    DB_DATA-ZEDTRPCODE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDTRPCODE.
    DB_DATA-ZEDTRPTYPE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDTRPTYPE.
    DB_DATA-ZEDREQUSER = &lt;FS_DB_ZTBREQUEST&gt;-ZEDREQUSER.
    DB_DATA-ZEDREQDATE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDREQDATE.
    DB_DATA-ZEDREQTIME = &lt;FS_DB_ZTBREQUEST&gt;-ZEDREQTIME.
    DB_DATA-ZEDMODUSER = &lt;FS_DB_ZTBREQUEST&gt;-ZEDMODUSER.
    DB_DATA-ZEDMODDATE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDMODDATE.
    DB_DATA-ZEDMODTIME = &lt;FS_DB_ZTBREQUEST&gt;-ZEDMODTIME.
    DB_DATA-ZEDVALCODE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDVALCODE.
    DB_DATA-ZEDVALUSER = &lt;FS_DB_ZTBREQUEST&gt;-ZEDVALUSER.
    DB_DATA-ZEDVALDATE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDVALDATE.
    DB_DATA-ZEDVALTIME = &lt;FS_DB_ZTBREQUEST&gt;-ZEDVALTIME.
    DB_DATA-ZEDTRTDATE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDTRTDATE.
    DB_DATA-ZEDTRTTIME = &lt;FS_DB_ZTBREQUEST&gt;-ZEDTRTTIME.
    DB_DATA-ZEDUGROUP = &lt;FS_DB_ZTBREQUEST&gt;-ZEDUGROUP.
    DB_DATA-ZEDFUNAREA = &lt;FS_DB_ZTBREQUEST&gt;-ZEDFUNAREA.
    DB_DATA-ZEDQUERY = &lt;FS_DB_ZTBREQUEST&gt;-ZEDQUERY.
    DB_DATA-ZEDQTRPCOD = &lt;FS_DB_ZTBREQUEST&gt;-ZEDQTRPCOD.
    DB_DATA-ZEDIMPORT = &lt;FS_DB_ZTBREQUEST&gt;-ZEDIMPORT.
    DB_DATA-ZEDCOMMENT = &lt;FS_DB_ZTBREQUEST&gt;-ZEDCOMMENT.
    DB_DATA-ZEDREPROC = &lt;FS_DB_ZTBREQUEST&gt;-ZEDREPROC.
    DB_DATA-ZEDVALFT2 = &lt;FS_DB_ZTBREQUEST&gt;-ZEDVALFT2.
    DB_DATA-ZEDVALFT2DATE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDVALFT2DATE.
    DB_DATA-ZEDELIGIBLE = &lt;FS_DB_ZTBREQUEST&gt;-ZEDELIGIBLE.
*&gt;

    append DB_DATA to RESULT.

  endloop.&quot; at DB_DATA_LOCAL_TAB

           &quot;MAP_LOAD_FROM_DATABASE_KEY
endmethod.
&quot;#EC CI_VALPAR</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_MERGE_IDENTIFIER" VERSION="1" LANGU="F" DESCRIPT="Ajoute clé de gestion aux données BD" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_MERGE_IDENTIFIER" SCONAME="I_BUSINESS_KEY_TAB" VERSION="1" LANGU="F" DESCRIPT="Liste de clés de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_BUSINESS_KEY_TAB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_MERGE_IDENTIFIER" SCONAME="C_DB_DATA_TAB" VERSION="1" LANGU="F" DESCRIPT="Données d&apos;objet à ajouter aux références" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_DB_DATA_TAB"/>
   <source>method MAP_MERGE_IDENTIFIER.
***BUILD 093901
     &quot; importing I_BUSINESS_KEY_TAB type TYP_BUSINESS_KEY_TAB
     &quot; changing C_DB_DATA_TAB type TYP_DB_DATA_TAB
************************************************************************
* Purpose        : Merge Table I_BUSINESS_KEY_TAB to C_DB_DATA_TAB.
*                  The result is a complete DB_DATA table to be stored
*                  in DB.
*
* Version        : 2.0
*
* Precondition   : C_DB_DATA is a Table filled with object data
*                  I_BUSINESS_KEY_TAB is a table of the same size with
*                  corresponding entries.
*
* Postcondition  : C_DB_DATA_TAB is complete
*
* OO Exceptions  : --
*
* Implementation :
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version
************************************************************************
* Generated! Do not modify!
************************************************************************

  data: BUSINESS_KEY type TYP_BUSINESS_KEY.

  field-symbols &lt;FS_OBJECT_DATA&gt; type TYP_DB_DATA.

  loop at C_DB_DATA_TAB assigning &lt;FS_OBJECT_DATA&gt;.

    read table I_BUSINESS_KEY_TAB into BUSINESS_KEY
         index SY-TABIX.

*&lt;  Generated from mapping:
    &lt;FS_OBJECT_DATA&gt;-ZEDREQNB = BUSINESS_KEY-ZEDREQNB.
*&gt;


  endloop.&quot; at C_DB_DATA_TAB

           &quot;MAP_MERGE_IDENTIFIER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SAVE_TO_DATABASE" VERSION="1" LANGU="F" DESCRIPT="Sauvegarde données d&apos;objet dans BD" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SAVE_TO_DATABASE" SCONAME="I_DELETES" VERSION="1" LANGU="F" DESCRIPT="Clé des données à supprimer" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_DB_DELETE_TAB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SAVE_TO_DATABASE" SCONAME="I_INSERTS" VERSION="1" LANGU="F" DESCRIPT="Nouvelles données à créer" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_DB_DATA_TAB"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SAVE_TO_DATABASE" SCONAME="I_UPDATES" VERSION="1" LANGU="F" DESCRIPT="Données à modifier" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_DB_DATA_TAB"/>
   <source>method MAP_SAVE_TO_DATABASE.
***BUILD 093901
     &quot; importing I_DELETES type TYP_DB_DELETE_TAB
     &quot;           I_INSERTS type TYP_DB_DATA_TAB
     &quot;           I_UPDATES type TYP_DB_DATA_TAB
************************************************************************
* Purpose        : Do database operations:
*                  Insert new object data from I_INSERTS,
*                  Update changed object data from I_UPDATES and
*                  Delete entries for deleted objects from I_DELETES
*
* Version        : 2.0
*
* Precondition   : I_DELETES,I_INSERTS and I_UPDATES contain ALL
*                  necessary information (Keys, Data)
*                  If this method is called in update task, there
*                  is NO MORE information, no objects exist anymore.
*
* Postcondition  : All database operations have been performed.
*
* OO Exceptions  : CX_OS_DB_INSERT, CX_OS_DB_UPDATE, CX_OS_DB_DELETE
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 1999-09-21   : (OS)  Initial Version
* - 2000-03-06   : (BGR) Version 2.0
* - 2001-11-26   : (SB)  Refactoring Generation
* - 2002-01-17   : (SB)  private attributes in super classes
************************************************************************

*&lt; Generated from mapping:

* * ZTBREQUEST: internal tables for mass operation
  data DB_ITB_ZTBREQUEST type STANDARD TABLE OF ZTBREQUEST.
  data DB_UTB_ZTBREQUEST type STANDARD TABLE OF ZTBREQUEST.
  data DB_DTB_ZTBREQUEST type STANDARD TABLE OF ZTBREQUEST.

* * ZTBREQUEST: headlines for tables
  data DB_ILN_ZTBREQUEST type ZTBREQUEST.
  data DB_ULN_ZTBREQUEST type ZTBREQUEST.
  data DB_DLN_ZTBREQUEST type ZTBREQUEST.

*&gt;

  field-symbols &lt;FS_INSERT&gt; type TYP_DB_DATA.
  field-symbols &lt;FS_UPDATE&gt; type TYP_DB_DATA.
  field-symbols &lt;FS_DELETE&gt; type TYP_SPECIAL_OBJECT_INFO.

* * Collect Inserts
  loop at I_INSERTS assigning &lt;FS_INSERT&gt;.

*&lt; Generated from mapping:


   DB_ILN_ZTBREQUEST-ZEDLANGU = &lt;FS_INSERT&gt;-ZEDLANGU.
   DB_ILN_ZTBREQUEST-ZEDSOURSYS = &lt;FS_INSERT&gt;-ZEDSOURSYS.
   DB_ILN_ZTBREQUEST-ZEDSOURMDT = &lt;FS_INSERT&gt;-ZEDSOURMDT.
   DB_ILN_ZTBREQUEST-ZEDTARGSYS = &lt;FS_INSERT&gt;-ZEDTARGSYS.
   DB_ILN_ZTBREQUEST-ZEDTRPDATE = &lt;FS_INSERT&gt;-ZEDTRPDATE.
   DB_ILN_ZTBREQUEST-ZEDTRPTIME = &lt;FS_INSERT&gt;-ZEDTRPTIME.
   DB_ILN_ZTBREQUEST-ZEDTRPCODE = &lt;FS_INSERT&gt;-ZEDTRPCODE.
   DB_ILN_ZTBREQUEST-ZEDTRPTYPE = &lt;FS_INSERT&gt;-ZEDTRPTYPE.
   DB_ILN_ZTBREQUEST-ZEDREQUSER = &lt;FS_INSERT&gt;-ZEDREQUSER.
   DB_ILN_ZTBREQUEST-ZEDREQDATE = &lt;FS_INSERT&gt;-ZEDREQDATE.
   DB_ILN_ZTBREQUEST-ZEDREQTIME = &lt;FS_INSERT&gt;-ZEDREQTIME.
   DB_ILN_ZTBREQUEST-ZEDMODUSER = &lt;FS_INSERT&gt;-ZEDMODUSER.
   DB_ILN_ZTBREQUEST-ZEDMODDATE = &lt;FS_INSERT&gt;-ZEDMODDATE.
   DB_ILN_ZTBREQUEST-ZEDMODTIME = &lt;FS_INSERT&gt;-ZEDMODTIME.
   DB_ILN_ZTBREQUEST-ZEDVALCODE = &lt;FS_INSERT&gt;-ZEDVALCODE.
   DB_ILN_ZTBREQUEST-ZEDVALUSER = &lt;FS_INSERT&gt;-ZEDVALUSER.
   DB_ILN_ZTBREQUEST-ZEDVALDATE = &lt;FS_INSERT&gt;-ZEDVALDATE.
   DB_ILN_ZTBREQUEST-ZEDVALTIME = &lt;FS_INSERT&gt;-ZEDVALTIME.
   DB_ILN_ZTBREQUEST-ZEDTRTDATE = &lt;FS_INSERT&gt;-ZEDTRTDATE.
   DB_ILN_ZTBREQUEST-ZEDTRTTIME = &lt;FS_INSERT&gt;-ZEDTRTTIME.
   DB_ILN_ZTBREQUEST-ZEDUGROUP = &lt;FS_INSERT&gt;-ZEDUGROUP.
   DB_ILN_ZTBREQUEST-ZEDFUNAREA = &lt;FS_INSERT&gt;-ZEDFUNAREA.
   DB_ILN_ZTBREQUEST-ZEDQUERY = &lt;FS_INSERT&gt;-ZEDQUERY.
   DB_ILN_ZTBREQUEST-ZEDQTRPCOD = &lt;FS_INSERT&gt;-ZEDQTRPCOD.
   DB_ILN_ZTBREQUEST-ZEDIMPORT = &lt;FS_INSERT&gt;-ZEDIMPORT.
   DB_ILN_ZTBREQUEST-ZEDCOMMENT = &lt;FS_INSERT&gt;-ZEDCOMMENT.
   DB_ILN_ZTBREQUEST-ZEDREPROC = &lt;FS_INSERT&gt;-ZEDREPROC.
   DB_ILN_ZTBREQUEST-ZEDVALFT2 = &lt;FS_INSERT&gt;-ZEDVALFT2.
   DB_ILN_ZTBREQUEST-ZEDVALFT2DATE = &lt;FS_INSERT&gt;-ZEDVALFT2DATE.
   DB_ILN_ZTBREQUEST-ZEDELIGIBLE = &lt;FS_INSERT&gt;-ZEDELIGIBLE.


   DB_ILN_ZTBREQUEST-ZEDREQNB = &lt;FS_INSERT&gt;-ZEDREQNB.
   append DB_ILN_ZTBREQUEST to DB_ITB_ZTBREQUEST.
*&gt;

  endloop. &quot;at I_INSERTS

* * Collect Updates
  loop at I_UPDATES assigning &lt;FS_UPDATE&gt;.

*&lt; Generated from mapping:


   DB_ULN_ZTBREQUEST-ZEDLANGU = &lt;FS_UPDATE&gt;-ZEDLANGU.
   DB_ULN_ZTBREQUEST-ZEDSOURSYS = &lt;FS_UPDATE&gt;-ZEDSOURSYS.
   DB_ULN_ZTBREQUEST-ZEDSOURMDT = &lt;FS_UPDATE&gt;-ZEDSOURMDT.
   DB_ULN_ZTBREQUEST-ZEDTARGSYS = &lt;FS_UPDATE&gt;-ZEDTARGSYS.
   DB_ULN_ZTBREQUEST-ZEDTRPDATE = &lt;FS_UPDATE&gt;-ZEDTRPDATE.
   DB_ULN_ZTBREQUEST-ZEDTRPTIME = &lt;FS_UPDATE&gt;-ZEDTRPTIME.
   DB_ULN_ZTBREQUEST-ZEDTRPCODE = &lt;FS_UPDATE&gt;-ZEDTRPCODE.
   DB_ULN_ZTBREQUEST-ZEDTRPTYPE = &lt;FS_UPDATE&gt;-ZEDTRPTYPE.
   DB_ULN_ZTBREQUEST-ZEDREQUSER = &lt;FS_UPDATE&gt;-ZEDREQUSER.
   DB_ULN_ZTBREQUEST-ZEDREQDATE = &lt;FS_UPDATE&gt;-ZEDREQDATE.
   DB_ULN_ZTBREQUEST-ZEDREQTIME = &lt;FS_UPDATE&gt;-ZEDREQTIME.
   DB_ULN_ZTBREQUEST-ZEDMODUSER = &lt;FS_UPDATE&gt;-ZEDMODUSER.
   DB_ULN_ZTBREQUEST-ZEDMODDATE = &lt;FS_UPDATE&gt;-ZEDMODDATE.
   DB_ULN_ZTBREQUEST-ZEDMODTIME = &lt;FS_UPDATE&gt;-ZEDMODTIME.
   DB_ULN_ZTBREQUEST-ZEDVALCODE = &lt;FS_UPDATE&gt;-ZEDVALCODE.
   DB_ULN_ZTBREQUEST-ZEDVALUSER = &lt;FS_UPDATE&gt;-ZEDVALUSER.
   DB_ULN_ZTBREQUEST-ZEDVALDATE = &lt;FS_UPDATE&gt;-ZEDVALDATE.
   DB_ULN_ZTBREQUEST-ZEDVALTIME = &lt;FS_UPDATE&gt;-ZEDVALTIME.
   DB_ULN_ZTBREQUEST-ZEDTRTDATE = &lt;FS_UPDATE&gt;-ZEDTRTDATE.
   DB_ULN_ZTBREQUEST-ZEDTRTTIME = &lt;FS_UPDATE&gt;-ZEDTRTTIME.
   DB_ULN_ZTBREQUEST-ZEDUGROUP = &lt;FS_UPDATE&gt;-ZEDUGROUP.
   DB_ULN_ZTBREQUEST-ZEDFUNAREA = &lt;FS_UPDATE&gt;-ZEDFUNAREA.
   DB_ULN_ZTBREQUEST-ZEDQUERY = &lt;FS_UPDATE&gt;-ZEDQUERY.
   DB_ULN_ZTBREQUEST-ZEDQTRPCOD = &lt;FS_UPDATE&gt;-ZEDQTRPCOD.
   DB_ULN_ZTBREQUEST-ZEDIMPORT = &lt;FS_UPDATE&gt;-ZEDIMPORT.
   DB_ULN_ZTBREQUEST-ZEDCOMMENT = &lt;FS_UPDATE&gt;-ZEDCOMMENT.
   DB_ULN_ZTBREQUEST-ZEDREPROC = &lt;FS_UPDATE&gt;-ZEDREPROC.
   DB_ULN_ZTBREQUEST-ZEDVALFT2 = &lt;FS_UPDATE&gt;-ZEDVALFT2.
   DB_ULN_ZTBREQUEST-ZEDVALFT2DATE = &lt;FS_UPDATE&gt;-ZEDVALFT2DATE.
   DB_ULN_ZTBREQUEST-ZEDELIGIBLE = &lt;FS_UPDATE&gt;-ZEDELIGIBLE.


   DB_ULN_ZTBREQUEST-ZEDREQNB = &lt;FS_UPDATE&gt;-ZEDREQNB.
   append DB_ULN_ZTBREQUEST TO DB_UTB_ZTBREQUEST.
*&gt;

  endloop. &quot;at I_UPDATES

* * Collect Deletes
  loop at I_DELETES assigning &lt;FS_DELETE&gt;.

    DB_DLN_ZTBREQUEST-ZEDREQNB = &lt;FS_DELETE&gt;-BUSINESS_KEY-ZEDREQNB.

    append DB_DLN_ZTBREQUEST TO DB_DTB_ZTBREQUEST.

  endloop. &quot;at I_DELETES

* * Perform DB Operations:

*&lt; Generated from mapping:

* * DB Deletes
  delete ZTBREQUEST FROM TABLE DB_DTB_ZTBREQUEST.
  if SY-SUBRC &lt;&gt; 0.
    raise exception type CX_OS_DB_DELETE
      exporting
        TABLE = &apos;ZTBREQUEST&apos;.
  endif.

* * DB Inserts
  insert ZTBREQUEST FROM TABLE DB_ITB_ZTBREQUEST
    accepting duplicate keys.
  if SY-SUBRC &lt;&gt; 0.
    raise exception type CX_OS_DB_INSERT
      exporting
        TABLE = &apos;ZTBREQUEST&apos;.
  endif.

* * DB Updates
  update ZTBREQUEST FROM TABLE DB_UTB_ZTBREQUEST.
  if SY-SUBRC &lt;&gt; 0.
    raise exception type CX_OS_DB_UPDATE
      exporting
        TABLE = &apos;ZTBREQUEST&apos;.
  endif.

*&gt;
           &quot;MAP_SAVE_TO_DATABASE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SERIALIZE_BKEY" VERSION="1" LANGU="F" DESCRIPT="Sérialise la clé de gestion" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SERIALIZE_BKEY" SCONAME="I_BUSINESS_KEY" VERSION="1" LANGU="F" DESCRIPT="Clé gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_BUSINESS_KEY"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SERIALIZE_BKEY" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Clé gestion com. chaîne" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
   <source>method MAP_SERIALIZE_BKEY.
***BUILD 093901
     &quot; importing I_BUSINESS_KEY type TYP_BUSINESS_KEY
     &quot; returning value(RESULT) type STRING
************************************************************************
* Purpose        : Concatenate business keys into string.
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : -
*
* OO Exceptions  : -
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-11-23   : (SB)  initial versiuon
* - 2009-06-03   : (SB)  correct order if edit order is used
************************************************************************
* Generated! Do not modify!
************************************************************************

  data: COMP_STRING type STRING.

*&lt; Generated from mapping:
  COMP_STRING = I_BUSINESS_KEY-ZEDREQNB.
  concatenate RESULT COMP_STRING into RESULT.
*&gt;

           &quot; MAP_SERIALIZE_BKEY
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SET_ATTRIBUTES" VERSION="1" LANGU="F" DESCRIPT="Définit attributs persistants d&apos;un objet" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SET_ATTRIBUTES" SCONAME="I_OBJECT_DATA" VERSION="1" LANGU="F" DESCRIPT="Données d&apos;objet à définir" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_DB_DATA"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SET_ATTRIBUTES" SCONAME="I_OBJECT_REF" VERSION="1" LANGU="F" DESCRIPT="Objet concerné" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_OBJECT_REF"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAP_SET_ATTRIBUTES" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method MAP_SET_ATTRIBUTES.
***BUILD 093901
     &quot; importing I_OBJECT_DATA type TYP_DB_DATA
     &quot;           I_OBJECT_REF  type TYP_OBJECT_REF
     &quot; raising   CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set objects from given object data
*
* Version        : 2.0
*
* Precondition   : I_OBJECT_REF is a reference to the object that will
*                  be set with data from I_OBJECT_DATA
*
* Postcondition  : The object&apos;s attributes are set.
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version
* - 2000-08-03   : (SB)  OO Exceptions
* - 2002-01-17   : (SB)  private attributes in super classes
************************************************************************
* Generated! Do not modify!
************************************************************************

  data: THE_OBJECT type ref to ZCL_TRANSPORT_REQUEST_WORKFLOW,
        AN_OBJECT  type ref to object, &quot;#EC NEEDED
        PM_SERVICE type ref to IF_OS_PM_SERVICE. &quot;#EC NEEDED

  PM_SERVICE ?= PERSISTENCY_MANAGER.
  THE_OBJECT = I_OBJECT_REF.

*&lt;  Generated from mapping:
  THE_OBJECT-&gt;ZEDREQNB = I_OBJECT_DATA-ZEDREQNB.
  THE_OBJECT-&gt;ZEDLANGU = I_OBJECT_DATA-ZEDLANGU.
  THE_OBJECT-&gt;ZEDSOURSYS = I_OBJECT_DATA-ZEDSOURSYS.
  THE_OBJECT-&gt;ZEDSOURMDT = I_OBJECT_DATA-ZEDSOURMDT.
  THE_OBJECT-&gt;ZEDTARGSYS = I_OBJECT_DATA-ZEDTARGSYS.
  THE_OBJECT-&gt;ZEDTRPDATE = I_OBJECT_DATA-ZEDTRPDATE.
  THE_OBJECT-&gt;ZEDTRPTIME = I_OBJECT_DATA-ZEDTRPTIME.
  THE_OBJECT-&gt;ZEDTRPCODE = I_OBJECT_DATA-ZEDTRPCODE.
  THE_OBJECT-&gt;ZEDTRPTYPE = I_OBJECT_DATA-ZEDTRPTYPE.
  THE_OBJECT-&gt;ZEDREQUSER = I_OBJECT_DATA-ZEDREQUSER.
  THE_OBJECT-&gt;ZEDREQDATE = I_OBJECT_DATA-ZEDREQDATE.
  THE_OBJECT-&gt;ZEDREQTIME = I_OBJECT_DATA-ZEDREQTIME.
  THE_OBJECT-&gt;ZEDMODUSER = I_OBJECT_DATA-ZEDMODUSER.
  THE_OBJECT-&gt;ZEDMODDATE = I_OBJECT_DATA-ZEDMODDATE.
  THE_OBJECT-&gt;ZEDMODTIME = I_OBJECT_DATA-ZEDMODTIME.
  THE_OBJECT-&gt;ZEDVALCODE = I_OBJECT_DATA-ZEDVALCODE.
  THE_OBJECT-&gt;ZEDVALUSER = I_OBJECT_DATA-ZEDVALUSER.
  THE_OBJECT-&gt;ZEDVALDATE = I_OBJECT_DATA-ZEDVALDATE.
  THE_OBJECT-&gt;ZEDVALTIME = I_OBJECT_DATA-ZEDVALTIME.
  THE_OBJECT-&gt;ZEDTRTDATE = I_OBJECT_DATA-ZEDTRTDATE.
  THE_OBJECT-&gt;ZEDTRTTIME = I_OBJECT_DATA-ZEDTRTTIME.
  THE_OBJECT-&gt;ZEDUGROUP = I_OBJECT_DATA-ZEDUGROUP.
  THE_OBJECT-&gt;ZEDFUNAREA = I_OBJECT_DATA-ZEDFUNAREA.
  THE_OBJECT-&gt;ZEDQUERY = I_OBJECT_DATA-ZEDQUERY.
  THE_OBJECT-&gt;ZEDQTRPCOD = I_OBJECT_DATA-ZEDQTRPCOD.
  THE_OBJECT-&gt;ZEDIMPORT = I_OBJECT_DATA-ZEDIMPORT.
  THE_OBJECT-&gt;ZEDCOMMENT = I_OBJECT_DATA-ZEDCOMMENT.
  THE_OBJECT-&gt;ZEDREPROC = I_OBJECT_DATA-ZEDREPROC.
  THE_OBJECT-&gt;ZEDVALFT2 = I_OBJECT_DATA-ZEDVALFT2.
  THE_OBJECT-&gt;ZEDVALFT2DATE = I_OBJECT_DATA-ZEDVALFT2DATE.
  THE_OBJECT-&gt;ZEDELIGIBLE = I_OBJECT_DATA-ZEDELIGIBLE.
*&gt;

           &quot;MAP_SET_ATTRIBUTES
  endmethod.</source>
  </method>
  <method CLSNAME="CL_OS_CA_COMMON" CMPNAME="OS_PM_DELETE_PERSISTENT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method OS_PM_DELETE_PERSISTENT.
***BUILD 090501
************************************************************************
* Purpose        : Delete persistent object. It is marked DELETED in
*                  memory and removed from DB when the top transaction
*                  is closed.
*
* Version        : 2.0
*
* Precondition   : The object is persistent (not transient), CURRENT
*                  is set
*
* Postcondition  : Instance is marked for deletion.
*
* OO Exceptions  : propagates PM_DELETE_PERSISTENT
*
* Implementation : load special object info and
*                  call PM_DELETE_PERSISTENT
*
************************************************************************
* Changelog:
* - 2001-12-14   : (SB)  Initial Version
************************************************************************

  call method LOAD_SPECIAL_OBJECT_INFO( ).

  call method PM_DELETE_PERSISTENT( ).

           &quot;OS_PM_DELETE_PERSISTENT .
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CHECK_AND_SET_ATTRIBUTES" VERSION="1" LANGU="F" DESCRIPT="Contrôle et définit des attributs persistants" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CHECK_AND_SET_ATTRIBUTES" SCONAME="I_BUSINESS_KEY" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_BUSINESS_KEY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CHECK_AND_SET_ATTRIBUTES" SCONAME="I_ID_PROVIDED" VERSION="1" LANGU="F" DESCRIPT="Chargement et contrôle avec quelles identifications" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_ID_STATUS" PARVALUE="0" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CHECK_AND_SET_ATTRIBUTES" SCONAME="I_OBJECT_DATA" VERSION="1" LANGU="F" DESCRIPT="Données chargées de BD" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_DB_DATA"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CHECK_AND_SET_ATTRIBUTES" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method PM_CHECK_AND_SET_ATTRIBUTES.
***BUILD 090501
     &quot; importing I_OBJECT_DATA  type TYP_DB_DATA
     &quot; importing I_BUSINESS_KEY type TYP_BUSINESS_KEY optional
     &quot;           I_ID_PROVIDED type TYP_ID_STATUS default ID_STATUS_NONE
************************************************************************
* Purpose        : check loaded object data of a persistent object and
*                  set object&apos;s attributes
*                  if CURRENT is clear, create new representant,
*                  if CURRENT is set, use this object to set the loaded
*                  data
*                  If I_ID_PROVIDED is set to ID_STATUS_NONE, Look for
*                  an entry in SPECIAL_OBJECT_INFO with the given
*                  Business Key
*
* Version        : 2.0
*
* Precondition   :
*
* Postcondition  : Persistent object data is checked and object
*                  attributes are set. CURRENT is set.
*
* OO Exception   : CX_OS_OBJECT_STATE(INTERNAL_CHANGED,INTERNAL_DELETED,
*                                     INTERNAL_TRANSIENT, INTERNAL_NEW)
*                  propagates MAP_SET_ATTRIBUTES
*
* Implementation : 1. If CURRENT is clear:
*                   1a. I_ID_PROVIDED = ID_STATUS_NONE?:
*                       Check if another object exists with this
*                       Business Key
*                   1b. I_ID_PROVIDED &lt;&gt; ID_STATUS_NONE or no entry
*                       found:
*                       Create a new Representative object
*                   1c. If an object has been found:
*                       Check if it is allowed to set it
*                  2. set PM_DBSTATUS EXISTING
*                  3. Temporarily save CURRENT_*
*                  4. set object attributes (resolving references)
*                  5. restore CURRENT_*
*
************************************************************************
* Changelog:
* - 2000-05-17   : (BGR) Initial Version 2.0
* - 2000-08-03   : (SB) OO Exceptions
************************************************************************

  data: LOADED_BUSINESS_KEY       type TYP_BUSINESS_KEY.

  data: TEMP_CURRENT_OBJECT_INFO  type TYP_OBJECT_INFO,
        TEMP_CURRENT_OBJECT_INDEX type TYP_INDEX,
        TEMP_CURRENT_SPECIAL_OI   type TYP_SPECIAL_OBJECT_INFO,
        TEMP_CURRENT_OBJECT_IREF  type TYP_OBJECT_IREF,
        INTERNAL_UNDO_INFO_ITEM   type TYP_INTERNAL_UNDO_INFO,
        TEMP_OBJECT_REF           type TYP_OBJECT_REF.

* * Get both Business Key from DB data
  call method MAP_EXTRACT_IDENTIFIER
       exporting I_DB_DATA      = I_OBJECT_DATA
       importing E_BUSINESS_KEY = LOADED_BUSINESS_KEY.

  if ( CURRENT_OBJECT_IREF is initial ).

*   * 1. If CURRENT is clear:

    if ( I_ID_PROVIDED = ID_STATUS_NONE ).

*   * 1a. Check if another object exists with this Business Key

      read table SPECIAL_BKEY_TAB into TEMP_CURRENT_SPECIAL_OI
           with table key BUSINESS_KEY = LOADED_BUSINESS_KEY.
      if ( sy-subrc = 0 ).

        read table SPECIAL_OBJECT_INFO into
             CURRENT_SPECIAL_OBJECT_INFO
             with table key
             OBJECT_ID = TEMP_CURRENT_SPECIAL_OI-OBJECT_ID.
        call method OS_LOAD_AND_VALIDATE_CURRENT
             exporting I_INDEX = sy-tabix.

      endif. &quot; ( Entry found for BKEY? )

    endif. &quot;( no ID Provided )

    if ( CURRENT_OBJECT_IREF is initial ).

*     * 1b. Create a new Representative object and a new entry
      call method PM_CREATE_REPRESENTANT
           exporting I_BUSINESS_KEY = LOADED_BUSINESS_KEY.

    else. &quot;( Found an entry for the business key )

*     * Now we know an entry exists on DB
      CURRENT_OBJECT_INFO-PM_DBSTATUS = OSCON_DBSTATUS_EXISTING.
      modify OBJECT_INFO from CURRENT_OBJECT_INFO
             index CURRENT_OBJECT_INDEX.

*     * 1c. Check if it is allowed to use the found object.
      case CURRENT_OBJECT_INFO-PM_STATUS.

*       * PM_STATUS = NOT_LOADED: re-use entry and object
        when OSCON_OSTATUS_NOT_LOADED.

*       * PM_STATUS = LOADED: re-use entry and object
        when OSCON_OSTATUS_LOADED.

*       *  other PM_STATUS: Error!
        when OSCON_OSTATUS_NEW.

*!!!!!!!!!! Error! Object already exists on DB
*         * This NEW object should be created on DB by the next
*         * COMMIT. Now an entry was found with the same key!
          class CX_OS_OBJECT_STATE definition load.
          raise exception type CX_OS_OBJECT_STATE
               exporting OBJECT = CURRENT_OBJECT_IREF
                         TEXTID = CX_OS_OBJECT_STATE=&gt;INTERNAL_NEW.

        when OSCON_OSTATUS_CHANGED.

*!!!!!!!!!!! Error: Object has a DB relevant status
          class CX_OS_OBJECT_STATE definition load.
          raise exception type CX_OS_OBJECT_STATE
               exporting OBJECT = CURRENT_OBJECT_IREF
                         TEXTID = CX_OS_OBJECT_STATE=&gt;INTERNAL_CHANGED.

        when OSCON_OSTATUS_DELETED.

*!!!!!!!!!!! Error: Object marked for deletion
          class CX_OS_OBJECT_STATE definition load.
          raise exception type CX_OS_OBJECT_STATE
               exporting OBJECT = CURRENT_OBJECT_IREF
                         TEXTID = CX_OS_OBJECT_STATE=&gt;INTERNAL_DELETED.

        when OSCON_OSTATUS_TRANSIENT.

*!!!!!!!!!!! Error: Object is transient
          class CX_OS_OBJECT_STATE definition load.
          raise exception type CX_OS_OBJECT_STATE
               exporting OBJECT = CURRENT_OBJECT_IREF
                        TEXTID = CX_OS_OBJECT_STATE=&gt;INTERNAL_TRANSIENT.

      endcase.

    endif. &quot;( CURRENT initial? )
  endif. &quot;( CURRENT initial? )

* * 2. set PM_DBSTATUS EXISTING
  CURRENT_OBJECT_INFO-PM_DBSTATUS          = OSCON_DBSTATUS_EXISTING.

* * internal Undo entry:
  INTERNAL_UNDO_INFO_ITEM-OBJECT_INDEX = CURRENT_OBJECT_INDEX.
  INTERNAL_UNDO_INFO_ITEM-OBJECT_INFO  = CURRENT_OBJECT_INFO.
  append INTERNAL_UNDO_INFO_ITEM to INTERNAL_UNDO_INFO.
  INTERNAL_NEXT_UNDO_INFO = sy-tabix + 1.

* * To avoid recursive loading of the same object (INIT method)
* * temporarily set status &apos;LOADING&apos;
  CURRENT_OBJECT_INFO-PM_STATUS = OSCON_OSTATUS_LOADING.
  modify OBJECT_INFO from CURRENT_OBJECT_INFO
         index CURRENT_OBJECT_INDEX.

* * 3. Temporarily save CURRENT_*
  TEMP_CURRENT_OBJECT_IREF  = CURRENT_OBJECT_IREF.
  TEMP_CURRENT_OBJECT_INFO  = CURRENT_OBJECT_INFO.
  TEMP_CURRENT_OBJECT_INDEX = CURRENT_OBJECT_INDEX.
  TEMP_CURRENT_SPECIAL_OI   = CURRENT_SPECIAL_OBJECT_INFO.

* * 4. set object attributes (resolving references)
  TEMP_OBJECT_REF ?= CURRENT_OBJECT_IREF .

  call method MAP_SET_ATTRIBUTES
       exporting I_OBJECT_DATA = I_OBJECT_DATA
                 I_OBJECT_REF  = TEMP_OBJECT_REF.

* * 5. restore CURRENT_*
  CURRENT_OBJECT_INFO          = TEMP_CURRENT_OBJECT_INFO.
  CURRENT_OBJECT_INDEX         = TEMP_CURRENT_OBJECT_INDEX.
  CURRENT_SPECIAL_OBJECT_INFO  = TEMP_CURRENT_SPECIAL_OI.
  CURRENT_OBJECT_IREF          = TEMP_CURRENT_OBJECT_IREF.

* * the method call get_ref_by_oid in map_set_attributes
* * eventually creates new entries in the
* * administrative data tables, it is necessary to
* * to recalculate the index
  read table OBJECT_INFO transporting no fields
     with table key OBJECT_ID = CURRENT_OBJECT_INFO-OBJECT_ID.
  CURRENT_OBJECT_INDEX = sy-tabix.

           &quot;PM_CHECK_AND_SET_ATTRIBUTES
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CREATE_REPRESENTANT" VERSION="1" LANGU="F" DESCRIPT="Génère nouvel objet enveloppe et entrée de gestion" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CREATE_REPRESENTANT" SCONAME="I_BUSINESS_KEY" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_BUSINESS_KEY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_CREATE_REPRESENTANT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Nouvel objet enveloppe généré" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TYP_OBJECT_REF"/>
   <source>method PM_CREATE_REPRESENTANT.
***BUILD 093901
     &quot; importing I_BUSINESS_KEY type TYP_BUSINESS_KEY
     &quot; returning result         type TYP_OBJECT_REF
************************************************************************
* Purpose        : Create a new representative object including a new
*                  entry in administrative data (OBJECT_INFO and
*                  SPECIAL_OBJECT_INFO)
*
* Version        : 2.0
*
* Precondition   : No object exists with the same Business Key
*
* Postcondition  : A new object exists, corresponding entries in
*                  OBJECT_INFO and SPECIAL_OBJECT_INFO have been
*                  inserted, CURRENT is set
*
* OO Exceptions  : --
*
* Implementation : 1. Create object and set BKey attributes
*                  2. Get internal OID for the new object
*                  3. Create new entry in SPECIAL_OBJECT_INFO
*                  4. Let super class create a new entry in OBJECT_INFO
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version 2.0
* - 2000-08-02   : (SB)  OO Exceptions
* - 2001-10-30   : (SB)  Type Mapping
************************************************************************

  data: NEW_OBJECT type ref to ZCL_TRANSPORT_REQUEST_WORKFLOW.

* * 1. Create object and set BKey attributes
  create object NEW_OBJECT.

* &lt; Generated from mapping:
  NEW_OBJECT-&gt;ZEDREQNB = I_BUSINESS_KEY-ZEDREQNB.
* &gt;

* * 2. Get internal OID for the new object and set CURRENT_SPECIAL_OI
  clear CURRENT_SPECIAL_OBJECT_INFO.

  CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID =
      OS_GET_INTERNAL_OID_BY_REF( I_OBJECT = NEW_OBJECT ).
  CURRENT_SPECIAL_OBJECT_INFO-BUSINESS_KEY = I_BUSINESS_KEY.
  CURRENT_SPECIAL_OBJECT_INFO-ID_STATUS = ID_STATUS_COMPLETE.

* * 3. Create new entry in SPECIAL_OBJECT_INFO
  insert CURRENT_SPECIAL_OBJECT_INFO into table SPECIAL_OBJECT_INFO.
  insert CURRENT_SPECIAL_OBJECT_INFO into table SPECIAL_BKEY_TAB.

* * 4. Let super class create a new entry in OBJECT_INFO
  call method OS_CREATE_NEW_ENTRY_FOR_REPR
       exporting I_OBJECT = NEW_OBJECT
                 I_INTERNAL_OID = CURRENT_SPECIAL_OBJECT_INFO-OBJECT_ID.

  RESULT = NEW_OBJECT.

           &quot;PM_CREATE_REPRESENTANT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_DELETE_PERSISTENT" VERSION="1" LANGU="F" DESCRIPT="Supprime objet persistant de BD" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <source>method PM_DELETE_PERSISTENT.
***BUILD 090501
************************************************************************
* Purpose        : Delete persistent object. It is marked DELETED in
*                  memory and removed from DB when the top transaction
*                  is closed.
*
* Version        : 2.0
*
* Precondition   : The object is persistent (not transient), CURRENT
*                  is set
*
* Postcondition  : Instance is marked for deletion.
*
* OO Exception   : CX_OS_OBJECT_STATE(CREATED_AND_DELETED,TRANSIENT)
*                  propagates OS_PM_DELETED_PERSISTENT
*                  ( propagates MAP_LOAD_FROM_DATABASE_KEY )
*
* Implementation : 1. Check the state of the object:
*                    1a. Object is already deleted - done
*                    1b. Object is transient - Error
*                    1c. Object is new, loaded or changed - continue
*                    1d. Object is not_loaded:
*                        Check DBSTATUS:
*                       1d1. DBSTATUS Unknown/Existing - continue
*                       1d2. DBSTATUS Not existing - Error
*                   2. Completion: call OS_PM_DELETED_PERSISTENT
*
************************************************************************
* Changelog:
* - 2000-03-06   : (BGR) Initial Version 2.0
* - 2000-08-03   : (SB) OO Exceptions
************************************************************************

  data: TEMP_CURRENT_OBJECT_IREF type TYP_OBJECT_IREF .

* * 1. Check the state of the object:
  case CURRENT_OBJECT_INFO-PM_STATUS.

  when OSCON_OSTATUS_DELETED.

*   * 1a. Object is already deleted - done
    call method OS_CLEAR_CURRENT.
    clear CURRENT_SPECIAL_OBJECT_INFO.
    exit.


  when OSCON_OSTATUS_TRANSIENT.

*   * 1b. Object is transient - Error
*!! error: object already exists transient
    TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
    call method OS_CLEAR_CURRENT.
    clear CURRENT_SPECIAL_OBJECT_INFO.
    class CX_OS_OBJECT_STATE definition load.
    raise exception type CX_OS_OBJECT_STATE
         exporting OBJECT = TEMP_CURRENT_OBJECT_IREF
                   TEXTID = CX_OS_OBJECT_STATE=&gt;TRANSIENT.


  when OSCON_OSTATUS_NEW     or
       OSCON_OSTATUS_CHANGED or
       OSCON_OSTATUS_LOADED.

*   * 1c. Object is new, loaded or changed - continue


  when OSCON_OSTATUS_NOT_LOADED.

*   * 1d. Object is not_loaded: Check DBSTATUS:
    case CURRENT_OBJECT_INFO-PM_DBSTATUS.


    when OSCON_DBSTATUS_EXISTING
      or OSCON_DBSTATUS_UNKNOWN.

*     * 1d1. DBSTATUS Existing/Unknown - continue


    when OSCON_DBSTATUS_NOT_EXISTING.
*     * 1d2. DBSTATUS Not existing - Error
*!!!! error: No DB entry for the object
      TEMP_CURRENT_OBJECT_IREF = CURRENT_OBJECT_IREF.
      call method OS_CLEAR_CURRENT.
      clear CURRENT_SPECIAL_OBJECT_INFO.
      class CX_OS_OBJECT_STATE definition load.
      raise exception type CX_OS_OBJECT_STATE
           exporting OBJECT = TEMP_CURRENT_OBJECT_IREF
                     TEXTID = CX_OS_OBJECT_STATE=&gt;CREATED_AND_DELETED.

    endcase. &quot;PM_DBSTATUS
  endcase. &quot;PM_STATUS

* * 2. Completion: call OS_PM_DELETED_PERSISTENT
  call method OS_PM_DELETED_PERSISTENT.

  clear CURRENT_SPECIAL_OBJECT_INFO.

           &quot;PM_DELETE_PERSISTENT
  endmethod.</source>
  </method>
  <method CLSNAME="CL_OS_CA_COMMON" CMPNAME="PM_LOAD" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method PM_LOAD.
***BUILD 090501
************************************************************************
* Purpose        : Load data from DB into Object specified by CURRENT
*
* Version        : 2.0
*
* Precondition   : CURRENT_* is set
*
* Postcondition  : object is loaded or exceptions is raised
*
* OO Exceptions  : propagates PM_LOAD_AND_SET_ATTRIBUTES
*
* Implementation : call PM_LOAD_AND_SET_ATTRIBUTES
*
************************************************************************
* Changelog:
* - 2000-03-02   : (BGR) Initial Version
* - 2000-08-03   : (SB)  OO Exceptions
* - 2001-11-14   : (SB)  Type mapping
************************************************************************

  call method PM_LOAD_AND_SET_ATTRIBUTES
       exporting I_BUSINESS_KEY =
                         CURRENT_SPECIAL_OBJECT_INFO-BUSINESS_KEY.

           &quot;PM_LOAD
  endmethod.</source>
  </method>
  <method CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_LOAD_AND_SET_ATTRIBUTES" VERSION="1" LANGU="F" DESCRIPT="Charge et définit des attributs persistants" EXPOSURE="1" STATE="1" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_LOAD_AND_SET_ATTRIBUTES" SCONAME="I_BUSINESS_KEY" VERSION="1" LANGU="F" DESCRIPT="Clé de gestion" CMPTYPE="1" MTDTYPE="0" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TYP_BUSINESS_KEY" PAROPTIONL="X"/>
   <exception CLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="PM_LOAD_AND_SET_ATTRIBUTES" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="0" EDITORDER="0 "/>
   <source>method PM_LOAD_AND_SET_ATTRIBUTES.
***BUILD 090501
     &quot; importing I_BUSINESS_KEY type TYP_BUSINESS_KEY optional

************************************************************************
* Purpose        : Load object data of a persistent object and set
*                  object&apos;s attributes
*                  if CURRENT is clear, load data using I_BUSINESS_KEY.
*                  if CURRENT is set, use the BKEY stored there.
*
* Version        : 2.0
*
* Precondition   : An entry for the given Business Key exists on
*                  database. CURRENT can be set (use this
*                  object to set attributes to) or clear.
*
* Postcondition  : Persistent object data is loaded and object
*                  attributes are set. CURRENT is set.
*
* OO Exceptions  : propagates PM_CHECK_AND_SET_ATTRIBUTES
*                  propagates MAP_LOAD_FROM_DATABASE_KEY/GUID
*
* Implementation : 1. Check Source of DB Keys: Business Key from
*                     CURRENT_SPECIAL_OBJECT_INFO or from I_BUSINESS_KEY
*                  2. Load from Database
*                  2.a. Type Mapping: Set E_TYPE and return if case of
*                       type mismatch
*                  3. Check loaded data and set object&apos;s attributes
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version 2.0
* - 2000-05-17   : (BGR) use PM_CHECK_AND_SET_ATTRIBUTES
* - 2000-08-03   : (SB) OO Exceptions
* - 2004-01-21   : (SB) Type Mapping Refactoring
* - 2005-02-22   : (SB) Set Exception parameters
************************************************************************

  data: OBJECT_DATA_TAB     type TYP_DB_DATA_TAB,
        OBJECT_DATA         type TYP_DB_DATA,
        BUSINESS_KEY        type TYP_BUSINESS_KEY,
        BUSINESS_KEY_TAB    type TYP_BUSINESS_KEY_TAB.

  data: SERIALIZED_BUSINESS_KEY  type STRING .

* * 1. Check Source of DB Keys: Business Key from
* *    CURRENT_SPECIAL_OBJECT_INFO or from I_BUSINESS_KEY?
  if ( CURRENT_OBJECT_IREF is initial ).

    BUSINESS_KEY = I_BUSINESS_KEY.

  else. &quot;( CURRENT is set ).

*   * Get BKey from CURRENT_SPECIAL_OBJECT_INFO
    BUSINESS_KEY = CURRENT_SPECIAL_OBJECT_INFO-BUSINESS_KEY.

  endif. &quot;( CURRENT set? ).


* * 2. Load from Database
  try.
      append BUSINESS_KEY to BUSINESS_KEY_TAB.
      call method MAP_LOAD_FROM_DATABASE_KEY
           exporting I_BUSINESS_KEY_TAB = BUSINESS_KEY_TAB
           receiving result = OBJECT_DATA_TAB.
    catch CX_OS_DB_SELECT.
      class CX_OS_OBJECT_NOT_FOUND definition load.
      call method MAP_SERIALIZE_BKEY
           exporting I_BUSINESS_KEY = BUSINESS_KEY
           receiving RESULT = SERIALIZED_BUSINESS_KEY.
      raise exception type CX_OS_OBJECT_NOT_FOUND
        exporting
          BKEY   = SERIALIZED_BUSINESS_KEY
          TEXTID = CX_OS_OBJECT_NOT_FOUND=&gt;BY_BKEY.
  endtry.

  read table OBJECT_DATA_TAB into OBJECT_DATA index 1.


* * 3. Now Check the loaded data and set the Object.
  call method PM_CHECK_AND_SET_ATTRIBUTES
       exporting I_OBJECT_DATA  = OBJECT_DATA
                 I_BUSINESS_KEY = BUSINESS_KEY
                 I_ID_PROVIDED  = ID_STATUS_COMPLETE.

           &quot;PM_LOAD_AND_SET_ATTRIBUTES
  endmethod.</source>
  </method>
  <method CLSNAME="CL_OS_CA_COMMON" CMPNAME="SAVE_SPECIAL_OBJECT_INFO" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SAVE_SPECIAL_OBJECT_INFO.
***BUILD 090501
************************************************************************
* Purpose        : Save CURRENT_SPECIAL_OBJECT_INFO into
*                  SPECIAL_OBJECT_INFO
*
* Version        : 2.0
*
* Precondition   : Index is set in CURRENT_OBJECT_INDEX
*
* Postcondition  : entry is saved
*
* OO Exceptions  : -
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-02   : (BGR) Initial Version
************************************************************************

  modify SPECIAL_OBJECT_INFO from CURRENT_SPECIAL_OBJECT_INFO
         index CURRENT_OBJECT_INDEX.

           &quot;SAVE_SPECIAL_OBJECT_INFO
  endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" VERSION="1" LANGU="F" DESCRIPT="Transport - Workflow" CATEGORY="10" EXPOSURE="1" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TS_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="7 " SRCCOLUMN2="23 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_instance,
      instid     TYPE sibfinstid,
      o_instance TYPE REF TO zcl_transport_request_workflow,
    END OF   ts_instance
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TT_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="62 " TYPESRC_LENG="0 " TYPESRC="tt_instance TYPE SORTED TABLE OF ts_instance
                  WITH UNIQUE KEY primary_key COMPONENTS instid
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="TS_WORK_AREA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="18 " SRCCOLUMN2="24 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_work_area,
      o_hardcode TYPE REF TO zcl_hardcode,
      initiator_user  TYPE sy-uname,
      initiator_email TYPE ad_smtpadr,
      validator_email TYPE ad_smtpadr,
    END OF   ts_work_area
"/>
  <friends CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="ZCB_TRANSPORT_REQUEST_WORKFLOW" FRIENDTYPE="0" VERSION="1" STATE="1"/>
  <implementing CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="IF_PT_REQ_ITEM_WF" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="5 "/>
  <implementing CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="IF_PT_REQ_ITEM" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="4 "/>
  <implementing CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" REFCLSNAME="IF_OS_STATE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <events CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_START" VERSION="1" LANGU="F" DESCRIPT="Evénement - Validation - Envoyée" EXPOSURE="2" STATE="1" EDITORDER="1 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_START" SCONAME="IS_REQUEST" VERSION="1" LANGU="F" DESCRIPT="Demande de Transport" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTBREQUEST"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_START" SCONAME="IV_INITIATOR_EMAIL" VERSION="1" LANGU="F" DESCRIPT="Initiateur - Adresse e-mail" CMPTYPE="2" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="AD_SMTPADR"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_START" SCONAME="IV_VALIDATOR_EMAIL" VERSION="1" LANGU="F" DESCRIPT="Validateurs - Adresse e-mail" CMPTYPE="2" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="AD_SMTPADR"/>
  </events>
  <events CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_DONE" VERSION="1" LANGU="F" DESCRIPT="Evénement - Validation - Effectuée" EXPOSURE="2" STATE="1" EDITORDER="2 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_DONE" SCONAME="IS_REQUEST" VERSION="1" LANGU="F" DESCRIPT="Demande de Transport" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTBREQUEST"/>
  </events>
  <events CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_DONE_FT2" VERSION="1" LANGU="F" DESCRIPT="Evénement - Validation - Express - Effectuée" EXPOSURE="2" STATE="1" EDITORDER="3 " EVTDECLTYP="0" BCEVTCAT="00">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_DONE_FT2" SCONAME="IS_REQUEST" VERSION="1" LANGU="F" DESCRIPT="Demande de Transport" CMPTYPE="2" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTBREQUEST"/>
  </events>
  <events CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_STOP" VERSION="1" LANGU="F" DESCRIPT="Evénement - Validation - Arrêt" EXPOSURE="2" STATE="1" EDITORDER="4 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <events CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WF_VALIDATION_EVENT_RESEND" VERSION="1" LANGU="F" DESCRIPT="Evénement - Validation - Renvoi" EXPOSURE="2" STATE="1" EDITORDER="5 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeClasDef CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" TYPEGROUP="CL_OS_SYSTEM" VERSION="1" TPUTYPE="1"/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MC_WORKFLOW_EVENT" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="21 " SRCCOLUMN1="4 " SRCROW2="28 " SRCCOLUMN2="28 " TYPESRC_LENG="599 " TYPESRC="BEGIN OF mc_workflow_event,
      objtype                   TYPE char50 VALUE &apos;ZCL_TRANSPORT_REQUEST_WORKFLOW&apos;, ##NOTEXT
      event_validation_start    TYPE char50 VALUE &apos;WF_VALIDATION_EVENT_START&apos;, ##NOTEXT
      event_validation_stop     TYPE char50 VALUE &apos;WF_VALIDATION_EVENT_STOP&apos;, ##NOTEXT
      event_validation_done     TYPE char50 VALUE &apos;WF_VALIDATION_EVENT_DONE&apos;, ##NOTEXT
      event_validation_done_ft2 TYPE char50 VALUE &apos;WF_VALIDATION_EVENT_DONE_FT2&apos;, ##NOTEXT
      event_validation_resend TYPE char50 VALUE &apos;WF_VALIDATION_EVENT_RESEND&apos;, ##NOTEXT
    END OF  mc_workflow_event
"/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MS_WORK_AREA" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TRANSPORT_REQUEST_WORKFLOW=&gt;TS_WORK_AREA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MT_INSTANCE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TRANSPORT_REQUEST_WORKFLOW=&gt;TT_INSTANCE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDCOMMENT" VERSION="1" LANGU="F" DESCRIPT="Commentaires" EXPOSURE="1" STATE="1" EDITORDER="27 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDCOMMENT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDELIGIBLE" VERSION="1" LANGU="F" DESCRIPT="Eligible" EXPOSURE="1" STATE="1" EDITORDER="31 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDELIGIBLE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDFUNAREA" VERSION="1" LANGU="F" DESCRIPT="Query Domaine Fonctionnel" EXPOSURE="1" STATE="1" EDITORDER="23 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDFUNAREA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDIMPORT" VERSION="1" LANGU="F" DESCRIPT="Query Import Code" EXPOSURE="1" STATE="1" EDITORDER="26 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDIMPORT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDLANGU" VERSION="1" LANGU="F" DESCRIPT="Langue de la demande" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDLANGU" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDMODDATE" VERSION="1" LANGU="F" DESCRIPT="Modifié le" EXPOSURE="1" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDMODDATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDMODTIME" VERSION="1" LANGU="F" DESCRIPT="Modifié à" EXPOSURE="1" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDMODTIME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDMODUSER" VERSION="1" LANGU="F" DESCRIPT="Modifié par" EXPOSURE="1" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDMODUSER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDQTRPCOD" VERSION="1" LANGU="F" DESCRIPT="Query Code Transport" EXPOSURE="1" STATE="1" EDITORDER="25 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDQTRPCOD" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDQUERY" VERSION="1" LANGU="F" DESCRIPT="Nom Query" EXPOSURE="1" STATE="1" EDITORDER="24 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDQUERY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDREPROC" VERSION="1" LANGU="F" DESCRIPT="Demande Retransportée" EXPOSURE="1" STATE="1" EDITORDER="28 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDREPROC" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDREQDATE" VERSION="1" LANGU="F" DESCRIPT="Date Demande" EXPOSURE="1" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDREQDATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDREQNB" VERSION="1" LANGU="F" DESCRIPT="N° Demande" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="7" TYPTYPE="1" TYPE="ZEDREQNB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDREQTIME" VERSION="1" LANGU="F" DESCRIPT="Heure Demande" EXPOSURE="1" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDREQTIME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDREQUSER" VERSION="1" LANGU="F" DESCRIPT="Demandeur" EXPOSURE="1" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDREQUSER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDSOURMDT" VERSION="1" LANGU="F" DESCRIPT="Mandant Source" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDSOURMDT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDSOURSYS" VERSION="1" LANGU="F" DESCRIPT="Système Source" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDSOURSYS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDTARGSYS" VERSION="1" LANGU="F" DESCRIPT="Système Cible" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDTARGSYS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDTRPCODE" VERSION="1" LANGU="F" DESCRIPT="Code Transport Spécial" EXPOSURE="1" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDTRPCODE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDTRPDATE" VERSION="1" LANGU="F" DESCRIPT="Date Transport" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDTRPDATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDTRPTIME" VERSION="1" LANGU="F" DESCRIPT="Heure Transport" EXPOSURE="1" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDTRPTIME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDTRPTYPE" VERSION="1" LANGU="F" DESCRIPT="Type de Transport" EXPOSURE="1" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDTRPTYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDTRTDATE" VERSION="1" LANGU="F" DESCRIPT="Traitée le" EXPOSURE="1" STATE="1" EDITORDER="20 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDTRTDATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDTRTTIME" VERSION="1" LANGU="F" DESCRIPT="Traitée à" EXPOSURE="1" STATE="1" EDITORDER="21 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDTRTTIME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDUGROUP" VERSION="1" LANGU="F" DESCRIPT="Query Groupe" EXPOSURE="1" STATE="1" EDITORDER="22 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDUGROUP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDVALCODE" VERSION="1" LANGU="F" DESCRIPT='&quot;A valider&quot;' EXPOSURE="1" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDVALCODE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDVALDATE" VERSION="1" LANGU="F" DESCRIPT="Valider le" EXPOSURE="1" STATE="1" EDITORDER="18 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDVALDATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDVALFT2" VERSION="1" LANGU="F" DESCRIPT="Process FT2 Validé" EXPOSURE="1" STATE="1" EDITORDER="29 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDVALFT2" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDVALFT2DATE" VERSION="1" LANGU="F" DESCRIPT="Valider le" EXPOSURE="1" STATE="1" EDITORDER="30 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDVALFT2DATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDVALTIME" VERSION="1" LANGU="F" DESCRIPT="Valider à" EXPOSURE="1" STATE="1" EDITORDER="19 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDVALTIME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="ZEDVALUSER" VERSION="1" LANGU="F" DESCRIPT="Valider par" EXPOSURE="1" STATE="1" EDITORDER="17 " ATTDECLTYP="0" ATTPERSIST="X" ATTEXPVIRT="2" TYPTYPE="1" TYPE="ZEDVALUSER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_STATE~GET">
   <source>method IF_OS_STATE~GET.
***BUILD 090501
     &quot; returning result type ref to object
************************************************************************
* Purpose        : Get state.
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : -
*
* OO Exceptions  : -
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version 2.0
************************************************************************
* GENERATED: Do not modify
************************************************************************

  data: STATE_OBJECT type ref to CL_OS_STATE.

  create object STATE_OBJECT.
  call method STATE_OBJECT-&gt;SET_STATE_FROM_OBJECT( ME ).
  result = STATE_OBJECT.

  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_STATE~HANDLE_EXCEPTION">
   <source>method IF_OS_STATE~HANDLE_EXCEPTION.
***BUILD 090501
     &quot; importing I_EXCEPTION type ref to IF_OS_EXCEPTION_INFO optional
     &quot; importing I_EX_OS type ref to CX_OS_OBJECT_NOT_FOUND optional
************************************************************************
* Purpose        : Handles exceptions during attribute access.
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : -
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : If an exception is raised during attribut access,
*                  this method is called and the exception is passed
*                  as a paramater. The default is to raise the exception
*                  again, so that the caller can handle the exception.
*                  But it is also possible to handle the exception
*                  here in the callee.
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version 2.0
* - 2000-08-02   : (SB)  OO Exceptions
************************************************************************
* Modify if you like
************************************************************************

  if i_ex_os is not initial.
    raise exception i_ex_os.
  endif.

  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_STATE~INIT">
   <source>method IF_OS_STATE~INIT.
***BUILD 090501
&quot;#EC NEEDED
************************************************************************
* Purpose        : Initialisation of the transient state partition.
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : Transient state is initial.
*
* OO Exceptions  : -
*
* Implementation : Caution!: Avoid Throwing ACCESS Events.
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version 2.0
************************************************************************
* Modify if you like
************************************************************************

  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_STATE~INVALIDATE">
   <source>method IF_OS_STATE~INVALIDATE.
***BUILD 090501
&quot;#EC NEEDED
************************************************************************
* Purpose        : Do something before all persistent attributes are
*                  cleared.
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : -
*
* OO Exceptions  : -
*
* Implementation : Whatever you like to do.
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version 2.0
************************************************************************
* Modify if you like
************************************************************************

  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_OS_STATE~SET">
   <source>method IF_OS_STATE~SET.
***BUILD 090501
     &quot; importing I_STATE type ref to object
************************************************************************
* Purpose        : Set state.
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : -
*
* OO Exceptions  : -
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-07   : (BGR) Initial Version 2.0
************************************************************************
* GENERATED: Do not modify
************************************************************************

  data: STATE_OBJECT type ref to CL_OS_STATE.

  STATE_OBJECT ?= I_STATE.
  call method STATE_OBJECT-&gt;SET_OBJECT_FROM_STATE( ME ).

  endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="BI_OBJECT~DEFAULT_ATTRIBUTE_VALUE">
   <source>METHOD bi_object~default_attribute_value.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="BI_OBJECT~EXECUTE_DEFAULT_METHOD">
   <source>METHOD bi_object~execute_default_method.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="BI_OBJECT~RELEASE">
   <source>METHOD bi_object~release.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="BI_PERSISTENT~FIND_BY_LPOR">
   <source>METHOD bi_persistent~find_by_lpor.
***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_transport_request TYPE REF TO zcl_transport_request_workflow.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération instance Singleton
  &quot; -----------------------------------------------------------

  &quot; Récupération instance ST
  READ TABLE zcl_transport_request_workflow=&gt;mt_instance
  WITH TABLE KEY instid = lpor-instid
       ASSIGNING FIELD-SYMBOL(&lt;lfs_s_instance&gt;).
  IF sy-subrc NE 0.
    &quot; Aucune correspondance
    TRY.
        &quot;&quot;  --&gt; Récupération instance basée sur DB
        lo_transport_request = zca_transport_request_workflow=&gt;agent-&gt;get_persistent( CONV #( lpor-instid ) ).

      CATCH cx_root.
        &quot; Erreur
        &quot;&quot;  --&gt; Création instance
        CREATE OBJECT lo_transport_request.
*        lo_transport_request = NEW #(
*          iv_reqnb = CONV #( lpor-instid )
*        ).

    ENDTRY.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée &amp; création de l&apos;instance
    INSERT VALUE #(
      instid     = lpor-instid
      o_instance = lo_transport_request
    ) INTO TABLE zcl_transport_request_workflow=&gt;mt_instance
       ASSIGNING &lt;lfs_s_instance&gt;.

  ENDIF.

  &quot; Retourne instance
  result ?= &lt;lfs_s_instance&gt;-o_instance.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="BI_PERSISTENT~LPOR">
   <source>METHOD bi_persistent~lpor.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne information WorkItem
  &quot; -----------------------------------------------------------

  result-instid         = me-&gt;get_zedreqnb( ).
  result-objtype-catid  = cl_swf_evt_event=&gt;mc_objcateg_cl.
  result-objtype-typeid = &apos;ZCL_TRANSPORT_REQUEST_WORKFLOW&apos;. &quot;#EC NOTEXT

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="BI_PERSISTENT~REFRESH">
   <source>METHOD bi_persistent~refresh.
ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_PT_REQ_ITEM~COMPARE_DB_TO_OBJECT">
   <source>METHOD if_pt_req_item~compare_db_to_object.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_transport_workflow TYPE REF TO zcl_transport_request_workflow.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_field TYPE string.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_source&gt; TYPE any,
    &lt;lfs_target&gt; TYPE any.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  &quot; Témoin indentique
  ret_identical = abap_true.

  &quot; Move-Cast
  lo_transport_workflow ?= im_compare_item.

  &quot; Récupération des Attributs
  SELECT cmpname  FROM vseocompdf
   WHERE clsname    EQ &apos;ZCL_TRANSPORT_REQUEST_WORKFLOW&apos; ##NOTEXT
     AND attpersist EQ @abap_true
    INTO TABLE @DATA(lt_attributes).

  &quot; -----------------------------------------------------------
  &quot; Compare les données
  &quot; -----------------------------------------------------------

  LOOP AT lt_attributes ASSIGNING FIELD-SYMBOL(&lt;lfs_s_attributes&gt;).

    &quot; Récupération valeur objet courant
    ASSIGN me-&gt;(&lt;lfs_s_attributes&gt;-cmpname) TO &lt;lfs_source&gt;.
    IF sy-subrc EQ 0.
      &quot; Récupération valeur objet comparé
      lv_field = |lo_transport_workflow-&gt;{ &lt;lfs_s_attributes&gt;-cmpname }|. ##NOTEXT
      ASSIGN (lv_field) TO &lt;lfs_target&gt;.

    ENDIF.
    IF sy-subrc NE 0.
      &quot; Pas de correspondance
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    IF &lt;lfs_source&gt; NE &lt;lfs_target&gt;.
      &quot; Valeur divergente
      &quot;&quot;  --&gt; Initialisation témoin
      ret_identical = abap_false.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    &quot; Réinitialisation
    UNASSIGN : &lt;lfs_target&gt;, &lt;lfs_source&gt;.

  ENDLOOP.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_PT_REQ_ITEM~GET_ALL_ITEM_ATTRIBS">
   <source>METHOD if_pt_req_item~get_all_item_attribs.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_workflow_data TYPE ztbrequest.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_structdescr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_method TYPE string.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
                 &lt;lfs_attribute&gt; TYPE any.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation tables des Attributs
  &quot; -----------------------------------------------------------

  &quot; Récupération description de la structure
  lo_structdescr ?= cl_abap_structdescr=&gt;describe_by_data( ls_workflow_data ).

  LOOP AT lo_structdescr-&gt;components ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).

    &quot; Nom de la méthode
    lv_method = |GET_{ &lt;lfs_s_components&gt;-name CASE = UPPER }|. &quot;#EC NOTEXT

    &quot; Initialisation pointeur sur l&apos;Attribut
    ASSIGN (&lt;lfs_s_components&gt;-name) TO &lt;lfs_attribute&gt;.
    IF sy-subrc NE 0.
      &quot; Aucune corrspondance
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    TRY.
        &quot; Appel de la méthode dynamiquement
        CALL METHOD me-&gt;(lv_method)
          RECEIVING
            result = &lt;lfs_attribute&gt;.

      CATCH cx_sy_dyn_call_illegal_method.
        &quot; Méthode inexistante

    ENDTRY.

    &quot; Ajout dans la table des Attributs / Valeurs
    APPEND VALUE #(
      name  = &lt;lfs_s_components&gt;-name
      value = &lt;lfs_attribute&gt;
    ) TO ex_attribs_tab.

    &quot; Réinitialisation
    CLEAR    : lv_method.
    UNASSIGN : &lt;lfs_attribute&gt;.

  ENDLOOP.

  &quot; Iniialisation Attribut WF
  CALL METHOD me-&gt;if_pt_req_item_wf~set_all_item_wf_attribs.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_PT_REQ_ITEM~GET_ITEM_ID">
   <source>METHOD if_pt_req_item~get_item_id.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Retourne ID
  &quot; -----------------------------------------------------------

  result = me-&gt;get_zedreqnb( ).

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_PT_REQ_ITEM~SET_ALL_ITEM_ATTRIBS">
   <source>METHOD if_pt_req_item~set_all_item_attribs.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
      lt_parameter_table TYPE abap_parmbind_tab.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_method TYPE string.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
        &lt;lfs_value&gt; TYPE any.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation des Attributs
  &quot; -----------------------------------------------------------

  LOOP AT im_attribs_tab ASSIGNING FIELD-SYMBOL(&lt;lfs_s_attribts_tab&gt;).

    &quot; Initialisation pointeur sur la valeur
    ASSIGN (&lt;lfs_s_attribts_tab&gt;-name) TO &lt;lfs_value&gt;.
    IF sy-subrc NE 0.
      &quot; Pointeur non initialisé
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    &quot; Nom de la méthode
    lv_method = |SET_{ &lt;lfs_s_attribts_tab&gt;-name CASE = UPPER }|. &quot;#EC NOTEXT

    &quot; Initialisation paramètre d&apos;appel de la méthode
    lt_parameter_table = VALUE #(
      (
        name  = |I_{ &lt;lfs_s_attribts_tab&gt;-name CASE = UPPER }| &quot;#EC NOTEXT
        value = REF #( &lt;lfs_value&gt; )
      )
    ).

    TRY.
        &quot; Appel de la méthde dynamniquement
        CALL METHOD me-&gt;(lv_method)
          PARAMETER-TABLE lt_parameter_table.

      CATCH cx_sy_dyn_call_illegal_method.
        &quot; Méthode inexistante
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

    ENDTRY.

    &quot; Réinitialisation
    CLEAR   : lv_method.
    REFRESH : lt_parameter_table.

  ENDLOOP.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Initialisation des Attributs
      &quot; -----------------------------------------------------------

      DATA(lv_id) = me-&gt;if_pt_req_item~get_item_id( ).

    CATCH cx_os_object_not_found.

  ENDTRY.

  &quot; -----------------------------------------------------------
  &quot; Initialisation des Attributs Workflow
  &quot; -----------------------------------------------------------

  me-&gt;if_pt_req_item_wf~set_all_item_wf_attribs( ).

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_PT_REQ_ITEM~SET_ITEM_ID">
   <source>METHOD if_pt_req_item~set_item_id.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation ID
  &quot; -----------------------------------------------------------

  &quot; Initialisation ID
  me-&gt;zedreqnb = im_item_id.

ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CPDNAME="IF_PT_REQ_ITEM_WF~SET_ALL_ITEM_WF_ATTRIBS">
   <source>METHOD if_pt_req_item_wf~set_all_item_wf_attribs.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_workflow_data TYPE ztbrequest.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
        lo_structdescr TYPE REF TO cl_abap_structdescr.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_method TYPE string.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
                 &lt;lfs_attribute&gt; TYPE any.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation tables des Attributs
  &quot; -----------------------------------------------------------

*  &quot; Récupération description de la structure
*  lo_structdescr ?= cl_abap_structdescr=&gt;describe_by_data(  ).
*
*  LOOP AT lo_structdescr-&gt;components ASSIGNING FIELD-SYMBOL(&lt;lfs_s_components&gt;).
*
*    &quot; Nom de la méthode
*    lv_method = |GET_{ &lt;lfs_s_components&gt;-name CASE = UPPER }|. &quot;#EC NOTEXT
*
*    &quot; Initialisation pointeur sur l&apos;Attribut
*    ASSIGN (&lt;lfs_s_components&gt;-name) TO &lt;lfs_attribute&gt;.
*    IF sy-subrc NE 0.
*      &quot; Aucune corrspondance
*      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
*      CONTINUE.
*
*    ENDIF.
*
*    TRY.
*        &quot; Appel de la méthode dynamiquement
*        CALL METHOD me-&gt;(lv_method)
*          RECEIVING
*            result = &lt;lfs_attribute&gt;.
*
*      CATCH cx_sy_dyn_call_illegal_method.
*        &quot; Méthode inexistante
*
*    ENDTRY.
*
*    &quot; Ajout dans la table des Valeurs
*    APPEND &lt;lfs_attribute&gt; TO if_pt_req_item_wf~attsval.
*
*    &quot; Ajout dans la table des Attributs
*    APPEND &lt;lfs_s_components&gt;-name TO if_pt_req_item_wf~attsname.
*
*    &quot; Ajout dans la table des Attributs / Valeurs
*    APPEND VALUE #(
*      name  = &lt;lfs_s_components&gt;-name
*      value = &lt;lfs_attribute&gt;
*    ) TO if_pt_req_item_wf~atts.
*
*    &quot; Réinitialisation
*    CLEAR    : lv_method.
*    UNASSIGN : &lt;lfs_attribute&gt;.
*
*  ENDLOOP.

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="32 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD constructor.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : CONSTRUCTOR                                       *
*&amp; Classe          : ZCL_TRANSPORT_REQUEST_WORKFLOW                    *
*&amp; Description     : Constructeur                                      *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 16/07/2020                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation Attributs
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Hardcode
      me-&gt;ms_work_area-o_hardcode = zcl_hardcode=&gt;get_instance( &apos;ZCL_TRANSPORT_REQUEST_WORKFLOW&apos; ). &quot;#EC NOTEXT

      TRY.
          &quot; Mail Validateur
          me-&gt;ms_work_area-validator_email = me-&gt;ms_work_area-o_hardcode-&gt;attribute_value_get(
             iv_parameter_name = &apos;CONFIGURATION&apos;            &quot;#EC NOTEXT
             iv_attribute_name = &apos;VALIDATOR_EMAIL&apos;          &quot;#EC NOTEXT
         )-key1.

        CATCH zcx_hardcode.
          &quot; Paramétrage non existant

      ENDTRY.

    CATCH zcx_hardcode.
      &quot; Hardcode non trouvée
      CLEAR : me-&gt;ms_work_area-validator_email.

  ENDTRY.

  IF me-&gt;ms_work_area-validator_email IS INITIAL.
    &quot; Initialisation données Validateur
    me-&gt;ms_work_area-validator_email = &apos;team_sap_tech@celio.com&apos;. ##NOTEXT

  ENDIF.

  &quot; Initialisation données initiateur (Nom &amp; eMail)
  me-&gt;ms_work_area-initiator_user = sy-uname.
  SELECT SINGLE adr6~smtp_addr
    FROM usr21 INNER JOIN adr6
                       ON adr6~addrnumber EQ usr21~addrnumber
                      AND adr6~persnumber EQ usr21~persnumber
   WHERE usr21~bname EQ @sy-uname
    INTO @me-&gt;ms_work_area-initiator_email.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="DATA_RETURN" VERSION="1" LANGU="F" DESCRIPT="Retourne données" EXPOSURE="2" STATE="1" EDITORDER="67 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="DATA_RETURN" SCONAME="RS_REQUEST" VERSION="1" LANGU="F" DESCRIPT="Demande de Transport" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTBREQUEST"/>
   <source>METHOD data_return.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
    &lt;lfs_value_me&gt;      TYPE any,
    &lt;lfs_value_request&gt; TYPE any.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  &quot; Récupération des Attributs
  SELECT cmpname  FROM vseocompdf
   WHERE clsname    EQ &apos;ZCL_TRANSPORT_REQUEST_WORKFLOW&apos; ##NOTEXT
     AND attpersist EQ @abap_true
    INTO TABLE @DATA(lt_attributes).

  &quot; -----------------------------------------------------------
  &quot; Initialisation des données
  &quot; -----------------------------------------------------------

  &quot; Traite tous les attributs publiques
  LOOP AT lt_attributes ASSIGNING FIELD-SYMBOL(&lt;lfs_s_attributes&gt;).

    &quot; Récupération valeur attribut
    ASSIGN me-&gt;(&lt;lfs_s_attributes&gt;-cmpname) TO &lt;lfs_value_me&gt;.
    IF sy-subrc EQ 0.
      &quot; Initialisation pointeur sur la données
      ASSIGN COMPONENT &lt;lfs_s_attributes&gt;-cmpname
          OF STRUCTURE rs_request
                    TO &lt;lfs_value_request&gt;.

    ENDIF.
    IF sy-subrc NE 0.
      &quot; Erreur initialisation pointeur
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    &quot; Initialisation de la valeur
    &lt;lfs_value_request&gt; = &lt;lfs_value_me&gt;.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDCOMMENT" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDCOMMENT" EXPOSURE="2" STATE="1" EDITORDER="33 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDCOMMENT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDCOMMENT"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDCOMMENT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDCOMMENT.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDCOMMENT
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDCOMMENT.

           &quot; GET_ZEDCOMMENT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDELIGIBLE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDELIGIBLE" EXPOSURE="2" STATE="1" EDITORDER="34 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDELIGIBLE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDELIGIBLE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDELIGIBLE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDELIGIBLE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDELIGIBLE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDELIGIBLE.

           &quot; GET_ZEDELIGIBLE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDFUNAREA" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDFUNAREA" EXPOSURE="2" STATE="1" EDITORDER="35 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDFUNAREA" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDFUNAREA"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDFUNAREA" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDFUNAREA.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDFUNAREA
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDFUNAREA.

           &quot; GET_ZEDFUNAREA
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDIMPORT" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDIMPORT" EXPOSURE="2" STATE="1" EDITORDER="36 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDIMPORT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDIMPORT"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDIMPORT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDIMPORT.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDIMPORT
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDIMPORT.

           &quot; GET_ZEDIMPORT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDLANGU" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDLANGU" EXPOSURE="2" STATE="1" EDITORDER="37 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDLANGU" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDLANGU"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDLANGU" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDLANGU.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDLANGU
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDLANGU.

           &quot; GET_ZEDLANGU
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODDATE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDMODDATE" EXPOSURE="2" STATE="1" EDITORDER="38 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODDATE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDMODDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDMODDATE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDMODDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDMODDATE.

           &quot; GET_ZEDMODDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODTIME" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDMODTIME" EXPOSURE="2" STATE="1" EDITORDER="39 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODTIME" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDMODTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDMODTIME.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDMODTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDMODTIME.

           &quot; GET_ZEDMODTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODUSER" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDMODUSER" EXPOSURE="2" STATE="1" EDITORDER="40 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODUSER" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDMODUSER"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDMODUSER" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDMODUSER.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDMODUSER
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDMODUSER.

           &quot; GET_ZEDMODUSER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDQTRPCOD" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDQTRPCOD" EXPOSURE="2" STATE="1" EDITORDER="41 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDQTRPCOD" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDQTRPCOD"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDQTRPCOD" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDQTRPCOD.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDQTRPCOD
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDQTRPCOD.

           &quot; GET_ZEDQTRPCOD
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDQUERY" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDQUERY" EXPOSURE="2" STATE="1" EDITORDER="42 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDQUERY" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDQUERY"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDQUERY" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDQUERY.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDQUERY
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDQUERY.

           &quot; GET_ZEDQUERY
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREPROC" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDREPROC" EXPOSURE="2" STATE="1" EDITORDER="43 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREPROC" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDREPROC"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREPROC" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDREPROC.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDREPROC
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDREPROC.

           &quot; GET_ZEDREPROC
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQDATE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDREQDATE" EXPOSURE="2" STATE="1" EDITORDER="44 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQDATE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDREQDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDREQDATE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDREQDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDREQDATE.

           &quot; GET_ZEDREQDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQNB" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDREQNB" EXPOSURE="2" STATE="1" EDITORDER="45 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQNB" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQNB" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDREQNB.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDREQNB
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDREQNB.

           &quot; GET_ZEDREQNB
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQTIME" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDREQTIME" EXPOSURE="2" STATE="1" EDITORDER="46 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQTIME" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDREQTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDREQTIME.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDREQTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDREQTIME.

           &quot; GET_ZEDREQTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQUSER" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDREQUSER" EXPOSURE="2" STATE="1" EDITORDER="47 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQUSER" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDREQUSER"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDREQUSER" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDREQUSER.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDREQUSER
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDREQUSER.

           &quot; GET_ZEDREQUSER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDSOURMDT" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDSOURMDT" EXPOSURE="2" STATE="1" EDITORDER="48 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDSOURMDT" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDSOURMDT"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDSOURMDT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDSOURMDT.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDSOURMDT
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDSOURMDT.

           &quot; GET_ZEDSOURMDT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDSOURSYS" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDSOURSYS" EXPOSURE="2" STATE="1" EDITORDER="49 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDSOURSYS" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDSOURSYS"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDSOURSYS" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDSOURSYS.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDSOURSYS
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDSOURSYS.

           &quot; GET_ZEDSOURSYS
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTARGSYS" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDTARGSYS" EXPOSURE="2" STATE="1" EDITORDER="50 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTARGSYS" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDTARGSYS"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTARGSYS" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDTARGSYS.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDTARGSYS
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDTARGSYS.

           &quot; GET_ZEDTARGSYS
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPCODE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDTRPCODE" EXPOSURE="2" STATE="1" EDITORDER="51 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPCODE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDTRPCODE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPCODE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDTRPCODE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDTRPCODE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDTRPCODE.

           &quot; GET_ZEDTRPCODE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPDATE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDTRPDATE" EXPOSURE="2" STATE="1" EDITORDER="52 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPDATE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDTRPDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDTRPDATE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDTRPDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDTRPDATE.

           &quot; GET_ZEDTRPDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPTIME" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDTRPTIME" EXPOSURE="2" STATE="1" EDITORDER="53 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPTIME" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDTRPTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDTRPTIME.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDTRPTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDTRPTIME.

           &quot; GET_ZEDTRPTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPTYPE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDTRPTYPE" EXPOSURE="2" STATE="1" EDITORDER="54 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPTYPE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDTRPTYPE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRPTYPE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDTRPTYPE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDTRPTYPE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDTRPTYPE.

           &quot; GET_ZEDTRPTYPE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRTDATE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDTRTDATE" EXPOSURE="2" STATE="1" EDITORDER="55 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRTDATE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDTRTDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRTDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDTRTDATE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDTRTDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDTRTDATE.

           &quot; GET_ZEDTRTDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRTTIME" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDTRTTIME" EXPOSURE="2" STATE="1" EDITORDER="56 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRTTIME" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDTRTTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDTRTTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDTRTTIME.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDTRTTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDTRTTIME.

           &quot; GET_ZEDTRTTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDUGROUP" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDUGROUP" EXPOSURE="2" STATE="1" EDITORDER="57 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDUGROUP" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDUGROUP"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDUGROUP" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDUGROUP.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDUGROUP
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDUGROUP.

           &quot; GET_ZEDUGROUP
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALCODE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDVALCODE" EXPOSURE="2" STATE="1" EDITORDER="58 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALCODE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDVALCODE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALCODE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDVALCODE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDVALCODE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDVALCODE.

           &quot; GET_ZEDVALCODE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALDATE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDVALDATE" EXPOSURE="2" STATE="1" EDITORDER="59 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALDATE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDVALDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDVALDATE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDVALDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDVALDATE.

           &quot; GET_ZEDVALDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALFT2" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDVALFT2" EXPOSURE="2" STATE="1" EDITORDER="60 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALFT2" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDVALFT2"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALFT2" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDVALFT2.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDVALFT2
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDVALFT2.

           &quot; GET_ZEDVALFT2
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALFT2DATE" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDVALFT2DATE" EXPOSURE="2" STATE="1" EDITORDER="61 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALFT2DATE" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDVALFT2DATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALFT2DATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDVALFT2DATE.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDVALFT2DATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDVALFT2DATE.

           &quot; GET_ZEDVALFT2DATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALTIME" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDVALTIME" EXPOSURE="2" STATE="1" EDITORDER="62 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALTIME" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDVALTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDVALTIME.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDVALTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDVALTIME.

           &quot; GET_ZEDVALTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALUSER" VERSION="1" LANGU="F" DESCRIPT="Lit l&apos;attribut ZEDVALUSER" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="4" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALUSER" SCONAME="RESULT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="4" EDITORDER="0 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDVALUSER"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="GET_ZEDVALUSER" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="4" EDITORDER="0 "/>
   <source>method GET_ZEDVALUSER.
***BUILD 090501
     &quot; returning RESULT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Get Attribute ZEDVALUSER
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, result is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
************************************************************************

* * Inform class agent and handle exceptions
  state_read_access.

  result = ZEDVALUSER.

           &quot; GET_ZEDVALUSER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" VERSION="1" LANGU="F" DESCRIPT="Mail - Notification" EXPOSURE="2" STATE="1" EDITORDER="68 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="EXPRESS" VERSION="1" LANGU="F" DESCRIPT="Envoyer par express" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOS04-L_SEX" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="SIGN" VERSION="1" LANGU="F" DESCRIPT="Envoyer par express" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOS04-S_SEX" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="ENCRYPT" VERSION="1" LANGU="F" DESCRIPT="Envoyer par express" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOS04-S_SEX" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="TYPEID" VERSION="1" LANGU="F" DESCRIPT="Indication d&apos;un type de destinataire" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SOS04-L_ART" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="ADDRESSSTRINGS" VERSION="1" LANGU="F" DESCRIPT="Notification recievers" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="USMD_T_NOTIF_RECIVERS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="ATTACHMENTS" VERSION="1" LANGU="F" DESCRIPT="SAPoffice : Dossier Contenu" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="SOFM" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="_ATTACH_OBJECTS" VERSION="1" LANGU="F" DESCRIPT="SAPoffice : Dossier Contenu" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SWF_UTL_PORB_TAB" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="_ATTACH_COMMENT_OBJECTS" VERSION="1" LANGU="F" DESCRIPT="SAPoffice : Dossier Contenu" CMPTYPE="1" MTDTYPE="0" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SWF_UTL_PORB_TAB" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="MAIL_NOTIFICATION" SCONAME="IV_WI_ID" VERSION="1" LANGU="F" DESCRIPT="ID du work item" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SWW_TASK" PAROPTIONL="X"/>
   <source>METHOD mail_notification.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
   DATA :
     lo_handle    TYPE REF TO if_swf_run_wim_internal,
     lo_container TYPE REF TO if_swf_cnt_container.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
   DATA :
     lt_command_lines    TYPE tline_t,
     lt_html_text_lines  TYPE htmltable,
     lt_ascii_text_lines TYPE tline_t.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
   DATA :
         lv_task TYPE rhobjects-object.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

   WHILE 1 = 1.ENDWHILE.

   TRY.
       &quot; -----------------------------------------------------------
       &quot; Récupération paramétrage du Mail
       &quot; -----------------------------------------------------------

       &quot; Récupération de la Tâche
*       lo_handle = cl_swf_run_wim_factory=&gt;find_by_wiid( iv_wi_id ).

       &quot; Récupération Container
       lo_container = lo_handle-&gt;get_wi_container( ).

       &quot; Récupération Tâche
       lv_task = |TS{ lo_handle-&gt;m_sww_wihead-wi_rh_task+2 }|. &quot;#EC NOTEXT

       &quot; Récupération Objet de la Tâche
       CALL FUNCTION &apos;SWU_GET_TASK_TEXTLINES&apos;
         EXPORTING
           task              = lv_task
           usage             = &apos;W&apos; ##NOTEXT
           linewidth         = 132
           language          = SWITCH sy-langu( lo_handle-&gt;m_sww_wihead-wi_lang
            WHEN space THEN sy-langu ELSE lo_handle-&gt;m_sww_wihead-wi_rh_task
           )
           container_handle  = lo_container
         TABLES
           command_lines     = lt_command_lines
           html_text_lines   = lt_html_text_lines
           ascii_text_lines  = lt_ascii_text_lines
         EXCEPTIONS
           wrong_usage       = 01
           text_not_found    = 02
           text_system_error = 03.



     CATCH cx_root.

   ENDTRY.
 ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDCOMMENT" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDCOMMENT" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDCOMMENT" SCONAME="I_ZEDCOMMENT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDCOMMENT"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDCOMMENT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDCOMMENT.
***BUILD 090501
     &quot; importing I_ZEDCOMMENT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDCOMMENT
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDCOMMENT &lt;&gt; ZEDCOMMENT ).

    ZEDCOMMENT = I_ZEDCOMMENT.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDCOMMENT &lt;&gt; ZEDCOMMENT )

           &quot; GET_ZEDCOMMENT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDELIGIBLE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDELIGIBLE" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDELIGIBLE" SCONAME="I_ZEDELIGIBLE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDELIGIBLE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDELIGIBLE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDELIGIBLE.
***BUILD 090501
     &quot; importing I_ZEDELIGIBLE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDELIGIBLE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDELIGIBLE &lt;&gt; ZEDELIGIBLE ).

    ZEDELIGIBLE = I_ZEDELIGIBLE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDELIGIBLE &lt;&gt; ZEDELIGIBLE )

           &quot; GET_ZEDELIGIBLE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDFUNAREA" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDFUNAREA" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDFUNAREA" SCONAME="I_ZEDFUNAREA" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDFUNAREA"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDFUNAREA" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDFUNAREA.
***BUILD 090501
     &quot; importing I_ZEDFUNAREA
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDFUNAREA
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDFUNAREA &lt;&gt; ZEDFUNAREA ).

    ZEDFUNAREA = I_ZEDFUNAREA.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDFUNAREA &lt;&gt; ZEDFUNAREA )

           &quot; GET_ZEDFUNAREA
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDIMPORT" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDIMPORT" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDIMPORT" SCONAME="I_ZEDIMPORT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDIMPORT"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDIMPORT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDIMPORT.
***BUILD 090501
     &quot; importing I_ZEDIMPORT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDIMPORT
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDIMPORT &lt;&gt; ZEDIMPORT ).

    ZEDIMPORT = I_ZEDIMPORT.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDIMPORT &lt;&gt; ZEDIMPORT )

           &quot; GET_ZEDIMPORT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDLANGU" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDLANGU" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDLANGU" SCONAME="I_ZEDLANGU" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDLANGU"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDLANGU" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDLANGU.
***BUILD 090501
     &quot; importing I_ZEDLANGU
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDLANGU
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDLANGU &lt;&gt; ZEDLANGU ).

    ZEDLANGU = I_ZEDLANGU.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDLANGU &lt;&gt; ZEDLANGU )

           &quot; GET_ZEDLANGU
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODDATE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDMODDATE" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODDATE" SCONAME="I_ZEDMODDATE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDMODDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDMODDATE.
***BUILD 090501
     &quot; importing I_ZEDMODDATE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDMODDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDMODDATE &lt;&gt; ZEDMODDATE ).

    ZEDMODDATE = I_ZEDMODDATE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDMODDATE &lt;&gt; ZEDMODDATE )

           &quot; GET_ZEDMODDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODTIME" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDMODTIME" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODTIME" SCONAME="I_ZEDMODTIME" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDMODTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDMODTIME.
***BUILD 090501
     &quot; importing I_ZEDMODTIME
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDMODTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDMODTIME &lt;&gt; ZEDMODTIME ).

    ZEDMODTIME = I_ZEDMODTIME.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDMODTIME &lt;&gt; ZEDMODTIME )

           &quot; GET_ZEDMODTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODUSER" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDMODUSER" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODUSER" SCONAME="I_ZEDMODUSER" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDMODUSER"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDMODUSER" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDMODUSER.
***BUILD 090501
     &quot; importing I_ZEDMODUSER
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDMODUSER
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDMODUSER &lt;&gt; ZEDMODUSER ).

    ZEDMODUSER = I_ZEDMODUSER.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDMODUSER &lt;&gt; ZEDMODUSER )

           &quot; GET_ZEDMODUSER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDQTRPCOD" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDQTRPCOD" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDQTRPCOD" SCONAME="I_ZEDQTRPCOD" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDQTRPCOD"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDQTRPCOD" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDQTRPCOD.
***BUILD 090501
     &quot; importing I_ZEDQTRPCOD
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDQTRPCOD
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDQTRPCOD &lt;&gt; ZEDQTRPCOD ).

    ZEDQTRPCOD = I_ZEDQTRPCOD.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDQTRPCOD &lt;&gt; ZEDQTRPCOD )

           &quot; GET_ZEDQTRPCOD
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDQUERY" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDQUERY" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDQUERY" SCONAME="I_ZEDQUERY" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDQUERY"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDQUERY" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDQUERY.
***BUILD 090501
     &quot; importing I_ZEDQUERY
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDQUERY
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDQUERY &lt;&gt; ZEDQUERY ).

    ZEDQUERY = I_ZEDQUERY.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDQUERY &lt;&gt; ZEDQUERY )

           &quot; GET_ZEDQUERY
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREPROC" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDREPROC" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREPROC" SCONAME="I_ZEDREPROC" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREPROC"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREPROC" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDREPROC.
***BUILD 090501
     &quot; importing I_ZEDREPROC
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDREPROC
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDREPROC &lt;&gt; ZEDREPROC ).

    ZEDREPROC = I_ZEDREPROC.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDREPROC &lt;&gt; ZEDREPROC )

           &quot; GET_ZEDREPROC
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQDATE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDREQDATE" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQDATE" SCONAME="I_ZEDREQDATE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDREQDATE.
***BUILD 090501
     &quot; importing I_ZEDREQDATE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDREQDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDREQDATE &lt;&gt; ZEDREQDATE ).

    ZEDREQDATE = I_ZEDREQDATE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDREQDATE &lt;&gt; ZEDREQDATE )

           &quot; GET_ZEDREQDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQTIME" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDREQTIME" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQTIME" SCONAME="I_ZEDREQTIME" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDREQTIME.
***BUILD 090501
     &quot; importing I_ZEDREQTIME
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDREQTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDREQTIME &lt;&gt; ZEDREQTIME ).

    ZEDREQTIME = I_ZEDREQTIME.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDREQTIME &lt;&gt; ZEDREQTIME )

           &quot; GET_ZEDREQTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQUSER" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDREQUSER" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQUSER" SCONAME="I_ZEDREQUSER" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQUSER"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDREQUSER" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDREQUSER.
***BUILD 090501
     &quot; importing I_ZEDREQUSER
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDREQUSER
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDREQUSER &lt;&gt; ZEDREQUSER ).

    ZEDREQUSER = I_ZEDREQUSER.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDREQUSER &lt;&gt; ZEDREQUSER )

           &quot; GET_ZEDREQUSER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDSOURMDT" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDSOURMDT" EXPOSURE="2" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDSOURMDT" SCONAME="I_ZEDSOURMDT" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDSOURMDT"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDSOURMDT" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDSOURMDT.
***BUILD 090501
     &quot; importing I_ZEDSOURMDT
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDSOURMDT
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDSOURMDT &lt;&gt; ZEDSOURMDT ).

    ZEDSOURMDT = I_ZEDSOURMDT.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDSOURMDT &lt;&gt; ZEDSOURMDT )

           &quot; GET_ZEDSOURMDT
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDSOURSYS" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDSOURSYS" EXPOSURE="2" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDSOURSYS" SCONAME="I_ZEDSOURSYS" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDSOURSYS"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDSOURSYS" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDSOURSYS.
***BUILD 090501
     &quot; importing I_ZEDSOURSYS
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDSOURSYS
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDSOURSYS &lt;&gt; ZEDSOURSYS ).

    ZEDSOURSYS = I_ZEDSOURSYS.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDSOURSYS &lt;&gt; ZEDSOURSYS )

           &quot; GET_ZEDSOURSYS
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTARGSYS" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDTARGSYS" EXPOSURE="2" STATE="1" EDITORDER="18 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTARGSYS" SCONAME="I_ZEDTARGSYS" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDTARGSYS"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTARGSYS" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDTARGSYS.
***BUILD 090501
     &quot; importing I_ZEDTARGSYS
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDTARGSYS
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDTARGSYS &lt;&gt; ZEDTARGSYS ).

    ZEDTARGSYS = I_ZEDTARGSYS.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDTARGSYS &lt;&gt; ZEDTARGSYS )

           &quot; GET_ZEDTARGSYS
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPCODE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDTRPCODE" EXPOSURE="2" STATE="1" EDITORDER="19 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPCODE" SCONAME="I_ZEDTRPCODE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDTRPCODE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPCODE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDTRPCODE.
***BUILD 090501
     &quot; importing I_ZEDTRPCODE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDTRPCODE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDTRPCODE &lt;&gt; ZEDTRPCODE ).

    ZEDTRPCODE = I_ZEDTRPCODE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDTRPCODE &lt;&gt; ZEDTRPCODE )

           &quot; GET_ZEDTRPCODE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPDATE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDTRPDATE" EXPOSURE="2" STATE="1" EDITORDER="20 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPDATE" SCONAME="I_ZEDTRPDATE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDTRPDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDTRPDATE.
***BUILD 090501
     &quot; importing I_ZEDTRPDATE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDTRPDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDTRPDATE &lt;&gt; ZEDTRPDATE ).

    ZEDTRPDATE = I_ZEDTRPDATE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDTRPDATE &lt;&gt; ZEDTRPDATE )

           &quot; GET_ZEDTRPDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPTIME" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDTRPTIME" EXPOSURE="2" STATE="1" EDITORDER="21 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPTIME" SCONAME="I_ZEDTRPTIME" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDTRPTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDTRPTIME.
***BUILD 090501
     &quot; importing I_ZEDTRPTIME
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDTRPTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDTRPTIME &lt;&gt; ZEDTRPTIME ).

    ZEDTRPTIME = I_ZEDTRPTIME.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDTRPTIME &lt;&gt; ZEDTRPTIME )

           &quot; GET_ZEDTRPTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPTYPE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDTRPTYPE" EXPOSURE="2" STATE="1" EDITORDER="22 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPTYPE" SCONAME="I_ZEDTRPTYPE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDTRPTYPE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRPTYPE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDTRPTYPE.
***BUILD 090501
     &quot; importing I_ZEDTRPTYPE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDTRPTYPE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDTRPTYPE &lt;&gt; ZEDTRPTYPE ).

    ZEDTRPTYPE = I_ZEDTRPTYPE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDTRPTYPE &lt;&gt; ZEDTRPTYPE )

           &quot; GET_ZEDTRPTYPE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRTDATE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDTRTDATE" EXPOSURE="2" STATE="1" EDITORDER="23 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRTDATE" SCONAME="I_ZEDTRTDATE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDTRTDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRTDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDTRTDATE.
***BUILD 090501
     &quot; importing I_ZEDTRTDATE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDTRTDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDTRTDATE &lt;&gt; ZEDTRTDATE ).

    ZEDTRTDATE = I_ZEDTRTDATE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDTRTDATE &lt;&gt; ZEDTRTDATE )

           &quot; GET_ZEDTRTDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRTTIME" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDTRTTIME" EXPOSURE="2" STATE="1" EDITORDER="24 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRTTIME" SCONAME="I_ZEDTRTTIME" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDTRTTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDTRTTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDTRTTIME.
***BUILD 090501
     &quot; importing I_ZEDTRTTIME
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDTRTTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDTRTTIME &lt;&gt; ZEDTRTTIME ).

    ZEDTRTTIME = I_ZEDTRTTIME.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDTRTTIME &lt;&gt; ZEDTRTTIME )

           &quot; GET_ZEDTRTTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDUGROUP" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDUGROUP" EXPOSURE="2" STATE="1" EDITORDER="25 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDUGROUP" SCONAME="I_ZEDUGROUP" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDUGROUP"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDUGROUP" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDUGROUP.
***BUILD 090501
     &quot; importing I_ZEDUGROUP
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDUGROUP
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDUGROUP &lt;&gt; ZEDUGROUP ).

    ZEDUGROUP = I_ZEDUGROUP.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDUGROUP &lt;&gt; ZEDUGROUP )

           &quot; GET_ZEDUGROUP
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALCODE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDVALCODE" EXPOSURE="2" STATE="1" EDITORDER="26 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALCODE" SCONAME="I_ZEDVALCODE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDVALCODE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALCODE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDVALCODE.
***BUILD 090501
     &quot; importing I_ZEDVALCODE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDVALCODE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDVALCODE &lt;&gt; ZEDVALCODE ).

    ZEDVALCODE = I_ZEDVALCODE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDVALCODE &lt;&gt; ZEDVALCODE )

           &quot; GET_ZEDVALCODE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALDATE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDVALDATE" EXPOSURE="2" STATE="1" EDITORDER="27 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALDATE" SCONAME="I_ZEDVALDATE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDVALDATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALDATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDVALDATE.
***BUILD 090501
     &quot; importing I_ZEDVALDATE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDVALDATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDVALDATE &lt;&gt; ZEDVALDATE ).

    ZEDVALDATE = I_ZEDVALDATE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDVALDATE &lt;&gt; ZEDVALDATE )

           &quot; GET_ZEDVALDATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALFT2" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDVALFT2" EXPOSURE="2" STATE="1" EDITORDER="28 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALFT2" SCONAME="I_ZEDVALFT2" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDVALFT2"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALFT2" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDVALFT2.
***BUILD 090501
     &quot; importing I_ZEDVALFT2
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDVALFT2
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDVALFT2 &lt;&gt; ZEDVALFT2 ).

    ZEDVALFT2 = I_ZEDVALFT2.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDVALFT2 &lt;&gt; ZEDVALFT2 )

           &quot; GET_ZEDVALFT2
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALFT2DATE" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDVALFT2DATE" EXPOSURE="2" STATE="1" EDITORDER="29 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALFT2DATE" SCONAME="I_ZEDVALFT2DATE" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDVALFT2DATE"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALFT2DATE" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDVALFT2DATE.
***BUILD 090501
     &quot; importing I_ZEDVALFT2DATE
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDVALFT2DATE
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDVALFT2DATE &lt;&gt; ZEDVALFT2DATE ).

    ZEDVALFT2DATE = I_ZEDVALFT2DATE.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDVALFT2DATE &lt;&gt; ZEDVALFT2DATE )

           &quot; GET_ZEDVALFT2DATE
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALTIME" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDVALTIME" EXPOSURE="2" STATE="1" EDITORDER="30 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALTIME" SCONAME="I_ZEDVALTIME" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDVALTIME"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALTIME" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDVALTIME.
***BUILD 090501
     &quot; importing I_ZEDVALTIME
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDVALTIME
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDVALTIME &lt;&gt; ZEDVALTIME ).

    ZEDVALTIME = I_ZEDVALTIME.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDVALTIME &lt;&gt; ZEDVALTIME )

           &quot; GET_ZEDVALTIME
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALUSER" VERSION="1" LANGU="F" DESCRIPT="Active l&apos;attribut ZEDVALUSER" EXPOSURE="2" STATE="1" EDITORDER="31 " DISPID="0 " MTDTYPE="5" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALUSER" SCONAME="I_ZEDVALUSER" VERSION="1" LANGU="F" DESCRIPT="Valeur attribut" CMPTYPE="1" MTDTYPE="5" EDITORDER="0 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDVALUSER"/>
   <exception CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="SET_ZEDVALUSER" SCONAME="CX_OS_OBJECT_NOT_FOUND" VERSION="1" LANGU="F" DESCRIPT="Exception services d&apos;objet" MTDTYPE="5" EDITORDER="0 "/>
   <source>method SET_ZEDVALUSER.
***BUILD 090501
     &quot; importing I_ZEDVALUSER
     &quot; raising CX_OS_OBJECT_NOT_FOUND
************************************************************************
* Purpose        : Set attribute ZEDVALUSER
*
* Version        : 2.0
*
* Precondition   : -
*
* Postcondition  : The object state is loaded, attribute is set
*
* OO Exceptions  : CX_OS_OBJECT_NOT_FOUND
*
* Implementation : -
*
************************************************************************
* Changelog:
* - 2000-03-14   : (BGR) Version 2.0
* - 2000-07-28   : (SB)  OO Exceptions
* - 2000-10-04   : (SB)  Namespaces
************************************************************************

* * Inform class agent and handle exceptions
  state_write_access.

  if ( I_ZEDVALUSER &lt;&gt; ZEDVALUSER ).

    ZEDVALUSER = I_ZEDVALUSER.

*   * Inform class agent and handle exceptions
    state_changed.

  endif. &quot;( I_ZEDVALUSER &lt;&gt; ZEDVALUSER )

           &quot; GET_ZEDVALUSER
  endmethod.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_DONE" VERSION="1" LANGU="F" DESCRIPT="Workflow - Validation - Effectuée" EXPOSURE="2" STATE="1" EDITORDER="65 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_DONE" SCONAME="IV_REQNB" VERSION="1" LANGU="F" DESCRIPT="N° Demande" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_DONE" SCONAME="RV_RAISED" VERSION="1" LANGU="F" DESCRIPT="Evénement généré" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD workflow_validation_done.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_container         TYPE REF TO if_swf_ifs_parameter_container,
    lo_transport_request TYPE REF TO zcl_transport_request_workflow.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_event TYPE char50.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération instance Transport
      &quot; -----------------------------------------------------------

      &quot; Récupération instance Transport
      lo_transport_request ?= zcl_transport_request_workflow=&gt;bi_persistent~find_by_lpor( VALUE #(
        instid = iv_reqnb
      ) ).

    CATCH cx_root.

  ENDTRY.
  IF NOT lo_transport_request IS BOUND.
    &quot; Instance non trouvée
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Trigger Event Validation effectuée
      &quot; -----------------------------------------------------------

      IF lo_transport_request-&gt;get_zedeligible( ) EQ abap_false.
        &quot; Demande &quot;normal&quot;
        &quot;&quot;  --&gt; Lance évenement fin de traitement &quot;classique&quot;
        lv_event = zcl_transport_request_workflow=&gt;mc_workflow_event-event_validation_done.

      ELSE.
        &quot; Demande &quot;express&quot;
        &quot;&quot;  --&gt; Lance évenement fin de traitement Express
        lv_event = zcl_transport_request_workflow=&gt;mc_workflow_event-event_validation_done_ft2.

      ENDIF.

      TRY.
          &quot; -----------------------------------------------------------
          &quot; Préparation Container WF
          &quot; -----------------------------------------------------------


          &quot; Création instance Container du WF
          lo_container = cl_swf_evt_event=&gt;get_event_container(
              im_event    = lv_event
              im_objcateg = cl_swf_evt_event=&gt;mc_objcateg_cl
              im_objtype  = zcl_transport_request_workflow=&gt;mc_workflow_event-objtype
          ).

          IF lo_container IS BOUND.
            &quot; Ajout dans le Container
            lo_container-&gt;set(
                name  = &apos;IS_REQUEST&apos;
                value = lo_transport_request-&gt;data_return( )
            ).

          ENDIF.

        CATCH cx_root.

      ENDTRY.

      &quot; -----------------------------------------------------------
      &quot; Lancement Workflow
      &quot; -----------------------------------------------------------

      &quot; Déclenche l&apos;évènement de démarrage du WorkFlow
      cl_swf_evt_event=&gt;raise(
        im_event           = lv_event
        im_objkey          = CONV char8( iv_reqnb )
        im_objcateg        = cl_swf_evt_event=&gt;mc_objcateg_cl
        im_objtype         = zcl_transport_request_workflow=&gt;mc_workflow_event-objtype
        im_event_container = lo_container
      ).

      &quot; Commit
      COMMIT WORK.

    CATCH : cx_swf_evt_invalid_objtype, cx_swf_evt_invalid_event.
      &quot; Erreur génération WF
      &quot;&quot;  --&gt; Tant pis

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_RESEND" VERSION="1" LANGU="F" DESCRIPT="Workflow - Validation - Renvoi notification" EXPOSURE="2" STATE="1" EDITORDER="66 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_RESEND" SCONAME="IV_REQNB" VERSION="1" LANGU="F" DESCRIPT="N° Demande" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_RESEND" SCONAME="RV_RAISED" VERSION="1" LANGU="F" DESCRIPT="Evénement levée" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD workflow_validation_resend.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_transport_request TYPE REF TO zcl_transport_request_workflow.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération instance Transport
  &quot; -----------------------------------------------------------

  &quot; Récupération instance Transport
  lo_transport_request ?= zcl_transport_request_workflow=&gt;bi_persistent~find_by_lpor( VALUE #(
    instid = iv_reqnb
  ) ).
  IF NOT lo_transport_request IS BOUND.
    &quot; Instance non trouvée
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Lancement Workflow
      &quot; -----------------------------------------------------------

      &quot; Déclenche l&apos;évènement de démarrage du WorkFlow
      cl_swf_evt_event=&gt;raise(
        im_objcateg        = cl_swf_evt_event=&gt;mc_objcateg_cl
        im_objtype         = zcl_transport_request_workflow=&gt;mc_workflow_event-objtype
        im_event           = zcl_transport_request_workflow=&gt;mc_workflow_event-event_validation_resend
        im_objkey          = CONV char8( iv_reqnb )
      ).

      &quot; Evénement levée
      rv_raised = abap_true.

      &quot; Commit
      COMMIT WORK.

    CATCH : cx_swf_evt_invalid_objtype, cx_swf_evt_invalid_event.
      &quot; Erreur génération WF
      &quot;&quot;  --&gt; Tant pis

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_START" VERSION="1" LANGU="F" DESCRIPT="Workflow - Validation - Lancement" EXPOSURE="2" STATE="1" EDITORDER="64 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_START" SCONAME="IV_REQNB" VERSION="1" LANGU="F" DESCRIPT="N° Demande" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_START" SCONAME="RV_RAISED" VERSION="1" LANGU="F" DESCRIPT="Evénement généré" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD workflow_validation_start.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_container         TYPE REF TO if_swf_ifs_parameter_container,
    lo_transport_request TYPE REF TO zcl_transport_request_workflow.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération instance Transport
  &quot; -----------------------------------------------------------

  &quot; Récupération instance Transport
  lo_transport_request ?= zcl_transport_request_workflow=&gt;bi_persistent~find_by_lpor( VALUE #(
    instid = iv_reqnb
  ) ).
  IF NOT lo_transport_request IS BOUND.
    &quot; Instance non trouvée
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF lo_transport_request-&gt;get_zedtrpcode( ) EQ zcl_transport_request_celio=&gt;mc_request_type-authorization.
    &quot; Demande de Transport Authorisation
    &quot;&quot;  --&gt; Pas de Workflow
    RETURN.

  ENDIF.

  TRY.
      TRY.
          &quot; -----------------------------------------------------------
          &quot; Préparation Container WF
          &quot; -----------------------------------------------------------

          &quot; Création instance Container du WF
          lo_container = cl_swf_evt_event=&gt;get_event_container(
              im_objcateg  = cl_swf_evt_event=&gt;mc_objcateg_cl
              im_objtype  = zcl_transport_request_workflow=&gt;mc_workflow_event-objtype
              im_event    = zcl_transport_request_workflow=&gt;mc_workflow_event-event_validation_start
          ).

          IF lo_container IS BOUND.
            &quot; Ajout dans le Container
            &quot;&quot;  --&gt; Données Demande
            lo_container-&gt;set(
                name  = &apos;IS_REQUEST&apos; ##NOTEXT
                value = lo_transport_request-&gt;data_return( )
            ).

            &quot;&quot;  --&gt; Mail Initiateur
            lo_container-&gt;set(
                name  = &apos;IV_INITIATOR_EMAIL&apos; ##NOTEXT
                value = lo_transport_request-&gt;ms_work_area-initiator_email
            ).

            &quot;&quot;  --&gt; Mail Validateur
            lo_container-&gt;set(
                name  = &apos;IV_VALIDATOR_EMAIL&apos; ##NOTEXT
                value = lo_transport_request-&gt;ms_work_area-validator_email
            ).

          ENDIF.

        CATCH cx_root.

      ENDTRY.

      &quot; -----------------------------------------------------------
      &quot; Lancement Workflow
      &quot; -----------------------------------------------------------

      &quot; Déclenche l&apos;évènement de démarrage du WorkFlow
      cl_swf_evt_event=&gt;raise(
        im_objcateg        = cl_swf_evt_event=&gt;mc_objcateg_cl
        im_objtype         = zcl_transport_request_workflow=&gt;mc_workflow_event-objtype
        im_event           = zcl_transport_request_workflow=&gt;mc_workflow_event-event_validation_start
        im_objkey          = CONV char8( iv_reqnb )
        im_event_container = lo_container
      ).

      &quot; Evénement levée
      rv_raised = abap_true.

      &quot; Commit
      COMMIT WORK.

    CATCH : cx_swf_evt_invalid_objtype, cx_swf_evt_invalid_event.
      &quot; Erreur génération WF
      &quot;&quot;  --&gt; Tant pis

  ENDTRY.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_STOP" VERSION="1" LANGU="F" DESCRIPT="Workflow - Validation - Fin" EXPOSURE="2" STATE="1" EDITORDER="63 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_STOP" SCONAME="IV_REQNB" VERSION="1" LANGU="F" DESCRIPT="N° Demande" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_WORKFLOW" CMPNAME="WORKFLOW_VALIDATION_STOP" SCONAME="RV_RAISED" VERSION="1" LANGU="F" DESCRIPT="Evénement levée" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD workflow_validation_stop.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Lancement Workflow
      &quot; -----------------------------------------------------------

      &quot; Déclenche l&apos;évènement de démarrage du WorkFlow
      cl_swf_evt_event=&gt;raise(
        im_objcateg        = cl_swf_evt_event=&gt;mc_objcateg_cl
        im_objtype         = zcl_transport_request_workflow=&gt;mc_workflow_event-objtype
        im_event           = zcl_transport_request_workflow=&gt;mc_workflow_event-event_validation_stop
        im_objkey          = CONV char8( iv_reqnb )
*        im_event_container = lo_container
      ).

      &quot; Evénement levée
      rv_raised = abap_true.

      &quot; Commit
      COMMIT WORK.

    CATCH : cx_swf_evt_invalid_objtype, cx_swf_evt_invalid_event.
      &quot; Erreur génération WF
      &quot;&quot;  --&gt; Tant pis

  ENDTRY.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TRANSPORT_REQUEST" VERSION="1" LANGU="F" DESCRIPT="OT - Classe utilitaire" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TS_COFILE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="21 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_cofile,
      trkorr          TYPE e070-trkorr,
      s_cofile_header TYPE tstrfcofih,
      t_cofile        TYPE tr_cofilines,
    END OF   ts_cofile
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TT_COFILE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="10 " SRCROW2="11 " SRCCOLUMN2="62 " TYPESRC_LENG="0 " TYPESRC="tt_cofile TYPE SORTED TABLE OF ts_cofile
                  WITH UNIQUE KEY primary_key COMPONENTS trkorr
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TS_OBJECT_EDITION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="4 " SRCROW2="20 " SRCCOLUMN2="29 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_object_edition,
      object         TYPE string,
      first_edit     TYPE xsdboolean,
      trkorr         TYPE e071-trkorr,
      as4text        TYPE e07t-as4text,
      user_cancelled TYPE xsdboolean,
    END OF   ts_object_edition
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TT_OBJECT_EDITION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="22 " SRCCOLUMN1="10 " SRCROW2="23 " SRCCOLUMN2="66 " TYPESRC_LENG="0 " TYPESRC="tt_object_edition TYPE SORTED TABLE OF ts_object_edition
                  WITH NON-UNIQUE KEY primary_key COMPONENTS object
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_TRANSPORT_REQUEST" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="GT_COFILE" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_TRANSPORT_REQUEST=&gt;TT_COFILE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="GT_OBJECT_EDITION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TT_OBJECT_EDITION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="GV_DESTINATION" VERSION="1" LANGU="F" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="F" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD class_constructor.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Initialisation Attribut
  &quot; -----------------------------------------------------------

  &quot; Destination COFILE
  SELECT SINGLE zedrfccons FROM ztbdestrfc
          WHERE zedsoursys EQ &apos;DE1&apos; &quot;#EC NOTEXT
           INTO @zcl_transport_request=&gt;gv_destination.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="OBJECT_EDITION_CHECK" VERSION="1" LANGU="F" DESCRIPT="Objet - Contrôle modification" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="OBJECT_EDITION_CHECK" SCONAME="IV_OBJECT" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="OBJECT_EDITION_CHECK" SCONAME="RV_CANCELLED" VERSION="1" LANGU="F" DESCRIPT="Valeur de vérité XSD : vrai/faux [ext.]" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD object_edition_check.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
        lv_answer TYPE numc1.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Sélection des données
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Contrôle Activation du Contrôle
      IF zcl_hardcode=&gt;get_instance( &apos;ZCL_IM_CTS_REQUEST_CHECK&apos; )-&gt;attribute_value_get( &quot;#EC NOTEXT
              iv_parameter_name = &apos;CONFIGURATION&apos;           &quot;#EC NOTEXT
              iv_attribute_name = &apos;ZXSEUU08&apos;                &quot;#EC NOTEXT
          )-key1 NE abap_true.
        &quot; Contrôle désactivée
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

    CATCH zcx_hardcode.
      &quot; Pas de Hardcode
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

  ENDTRY.

  &quot; Récupération donnée Objet
  READ TABLE zcl_transport_request=&gt;gt_object_edition
  WITH TABLE KEY object = iv_object ASSIGNING FIELD-SYMBOL(&lt;lfs_s_object_edition&gt;).
  IF sy-subrc NE 0.
    &quot; Pas de données pour cet Objet
    &quot;&quot;  --&gt; Création nouvelle entrée
    INSERT VALUE #(
      object = iv_object
    ) INTO TABLE zcl_transport_request=&gt;gt_object_edition
       ASSIGNING &lt;lfs_s_object_edition&gt;.

  ENDIF.

  IF  &lt;lfs_s_object_edition&gt;-first_edit     EQ abap_true
  AND &lt;lfs_s_object_edition&gt;-user_cancelled NE abap_true.
    &quot; Objet déjà contrôlée
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot;&quot;  --&gt; Initialise Flag Première Edition
  &lt;lfs_s_object_edition&gt;-first_edit = abap_true.

  &quot;&quot;  --&gt; Contrôle présence autre Version non transportée jusqu&apos;en Prod / Recette
  SELECT CASE WHEN main~strkorr NE @space THEN main~strkorr ELSE main~trkorr END AS trkorr_main
    FROM e071 INNER JOIN e070 AS main ON e071~trkorr EQ main~trkorr
   WHERE e071~obj_name EQ @&lt;lfs_s_object_edition&gt;-object AND e071~trkorr NOT LIKE &apos;DE1_P%&apos; &quot;#EC NOTEXT
     AND main~trstatus NE &apos;D&apos;                               &quot;#EC NOTEXT
  INTO TABLE @DATA(lt_trkorr).
  IF sy-subrc NE 0.
    &quot; Aucun OT
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; Au moins un OT non modifiable trouvé
  &quot;&quot;  --&gt; Tri par Ordre décroissant
  SORT lt_trkorr BY trkorr_main DESCENDING.
  &lt;lfs_s_object_edition&gt;-trkorr = lt_trkorr[ 1 ]-trkorr_main.

  SELECT SINGLE as4text FROM e07t
          WHERE trkorr EQ @&lt;lfs_s_object_edition&gt;-trkorr AND langu EQ &apos;F&apos;
           INTO @&lt;lfs_s_object_edition&gt;-as4text.

  &quot;&quot;  --&gt; Contrôle Import Production
  IF zcl_transport_request=&gt;transport_request_check_import(
   EXPORTING
     iv_trkorr        = &lt;lfs_s_object_edition&gt;-trkorr
     iv_tarsystem     = &apos;PE1&apos;                               &quot;#EC NOTEXT
 ) EQ abap_true.
    &quot; OT transporté en Production
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; OT non transportée en Production
  &quot;&quot;  --&gt; Popup Confirme
  CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
    EXPORTING
      titlebar              = &apos;Modification non transportée en Production&apos; &quot;#EC NOTEXT
      text_question         = CONV char120( |{ &lt;lfs_s_object_edition&gt;-trkorr } - { &lt;lfs_s_object_edition&gt;-as4text }|
                              &amp;&amp; |\\ La modification n&apos;est pas en Prod ! Tu assumes ?| ) &quot;#EC NOTEXT
      text_button_1         = &apos;Oh que oui !&apos; &quot;#EC NOTEXT
      icon_button_1         = &apos;@Y2@&apos;
      text_button_2         = &apos;Oulà non !&apos; &quot;#EC NOTEXT
      icon_button_2         = &apos;@1V@&apos;
      default_button        = &apos;2&apos; &quot;#EC NOTEXT
      display_cancel_button = abap_false
    IMPORTING
      answer                = lv_answer
    EXCEPTIONS
      text_not_found        = 1
      OTHERS                = 2.
  IF sy-subrc NE 0.
    &quot; Erreur affichage Popup
    &quot;&quot;  --&gt; Confirme
    lv_answer = &apos;1&apos;.                                        &quot;#EC NOTEXT

  ENDIF.

  &quot; Suivant la réponse de l&apos;utilisateur
  CASE lv_answer.

    WHEN &apos;1&apos;.                                               &quot;#EC NOTEXT
      &quot; J&apos;assume !
      &quot;&quot;  --&gt; Tudo Bem
      rv_cancelled = abap_false.

    WHEN &apos;2&apos;.
      &quot; Oulà non !
      rv_cancelled = abap_true.

    WHEN OTHERS.
      &quot; Euuhh ...
      &quot;&quot;  --&gt; Annule le traitement
      rv_cancelled = abap_true.

  ENDCASE.

  &quot; Retiens la réponse de l&apos;utilisateur
  &lt;lfs_s_object_edition&gt;-user_cancelled = rv_cancelled.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_CHECK_IMPORT" VERSION="1" LANGU="F" DESCRIPT="Ordre de Transport - Contrôle Import" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_CHECK_IMPORT" SCONAME="IV_TRKORR" VERSION="1" LANGU="F" DESCRIPT="Ordre/Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORR"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_CHECK_IMPORT" SCONAME="IV_TARSYSTEM" VERSION="1" LANGU="F" DESCRIPT="Système Cible" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRTARSYS"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_CHECK_IMPORT" SCONAME="ES_COFILE_HEADER" VERSION="1" LANGU="F" DESCRIPT="Contenu logique des fichiers de commande : en-tête" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TSTRFCOFIH"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_CHECK_IMPORT" SCONAME="RV_IMPORTED" VERSION="1" LANGU="F" DESCRIPT="OT Importé ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD transport_request_check_import.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
      lt_cofile TYPE zcl_transport_request=&gt;ts_cofile-t_cofile.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  CLEAR : es_cofile_header.

  &quot; -----------------------------------------------------------
  &quot; Récupération Cofile
  &quot; -----------------------------------------------------------

  &quot; Récupération données CoFile
  lt_cofile = zcl_transport_request=&gt;transport_request_cofile_get(
    EXPORTING
      iv_trkorr        = iv_trkorr
    IMPORTING
      es_cofile_header = es_cofile_header
  ).

  &quot; -----------------------------------------------------------
  &quot; Retourne indicateur Import effectué
  &quot; -----------------------------------------------------------

  rv_imported = xsdbool( line_exists( lt_cofile[
     tarsystem = iv_tarsystem
     function  = cl_cts_change_tracking_api=&gt;co_import_status_imported
   ] ) ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_COFILE_GET" VERSION="1" LANGU="F" DESCRIPT="Ordre de Transport - Récupération COFILE" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_COFILE_GET" SCONAME="IV_TRKORR" VERSION="1" LANGU="F" DESCRIPT="Ordre/Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORR"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_COFILE_GET" SCONAME="ES_COFILE_HEADER" VERSION="1" LANGU="F" DESCRIPT="Contenu logique des fichiers de commande : en-tête" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TSTRFCOFIH"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_COFILE_GET" SCONAME="RT_COFILE_LINES" VERSION="1" LANGU="F" DESCRIPT="Table de pointeurs de protocoles" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TR_COFILINES"/>
   <source>METHOD transport_request_cofile_get.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_cofile TYPE zcl_transport_request=&gt;ts_cofile.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  CLEAR : es_cofile_header.

  &quot; -----------------------------------------------------------
  &quot; Récupération Cofile Buffer
  &quot; -----------------------------------------------------------

  READ TABLE zcl_transport_request=&gt;gt_cofile
  WITH TABLE KEY trkorr = iv_trkorr
  ASSIGNING FIELD-SYMBOL(&lt;lfs_s_cofile&gt;).
  IF sy-subrc EQ 0.
    &quot; Retourne les données
    rt_cofile_lines  = &lt;lfs_s_cofile&gt;-t_cofile[].
    es_cofile_header = &lt;lfs_s_cofile&gt;-s_cofile_header.

  ELSE.
    TRY.
        &quot; -----------------------------------------------------------
        &quot; Récupération Cofile DB
        &quot; -----------------------------------------------------------

        &quot; Récupération Cofile
        CALL FUNCTION &apos;STRF_READ_COFILE&apos;
          EXPORTING
            iv_dirtype     = cl_cts_language=&gt;lc_dir_trans
            iv_trkorr      = iv_trkorr
          IMPORTING
            ev_cofi_header = es_cofile_header
          TABLES
            tt_cofi_lines  = rt_cofile_lines
          EXCEPTIONS
            wrong_call     = 1
            no_info_found  = 2
            error_message  = 3
            OTHERS         = 4.
        IF sy-subrc NE 0.
          &quot; Erreur récupération CoFile
          &quot;&quot;  --&gt; Réinitialise données
          REFRESH : rt_cofile_lines.

        ENDIF.

      CATCH cx_root.
        &quot; Erreur ...

    ENDTRY.

    &quot;&quot;  --&gt; Ajout de l&apos;entrée
    INSERT VALUE #(
      trkorr          = iv_trkorr
      t_cofile        = rt_cofile_lines
      s_cofile_header = es_cofile_header
    ) INTO TABLE zcl_transport_request=&gt;gt_cofile.

  ENDIF.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_IS_RELEASED" VERSION="1" LANGU="F" DESCRIPT="Ordre de Transport - Libéré ?" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_IS_RELEASED" SCONAME="IV_TRKORR" VERSION="1" LANGU="F" DESCRIPT="Ordre/Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORR"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_IS_RELEASED" SCONAME="RV_RELEASED" VERSION="1" LANGU="F" DESCRIPT="Libérée ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <source>METHOD transport_request_is_released.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TRANSPORT_REQUEST_IS_RELEASED                     *
*&amp; Classe          : ZCL_TRANSPORT_REQUEST                             *
*&amp; Description     : Ordre de Transport - Libéré ?                     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 04/04/2019                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle que l&apos;Objet soit libéré
  &quot; -----------------------------------------------------------

  &quot; Recherche Objet libéré
  SELECT SINGLE trkorr
    FROM e070
   WHERE trkorr   EQ @iv_trkorr
     AND trstatus EQ @if_cts_transport_request=&gt;co_status_open
    INTO @DATA(lv_trkorr).

  &quot; Retourne booléen OT libéré
  rv_released = xsdbool( sy-subrc NE 0 ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_RELEASE" VERSION="1" LANGU="F" DESCRIPT="Ordre de Transport - Libération" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_RELEASE" SCONAME="IV_TRKORR" VERSION="1" LANGU="F" DESCRIPT="Ordre/Tâche" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORR"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_RELEASE" SCONAME="IV_SIMULATION" VERSION="1" LANGU="F" DESCRIPT="Simulation ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_RELEASE" SCONAME="ES_RETURN" VERSION="1" LANGU="F" DESCRIPT="Paramètre de retour" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="BAPIRET2"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST" CMPNAME="TRANSPORT_REQUEST_RELEASE" SCONAME="RV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <source>METHOD transport_request_release.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TRANSPORT_ORDER_RELEASE                           *
*&amp; Classe          : ZCL_TRANSPORT_REQUEST                             *
*&amp; Description     : Ordre de Transport- Libération                    *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 01/02/2017                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
        lt_trkorr TYPE trkorrs.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_request TYPE trwbo_request.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Récupération typologie de l&apos;Objet (Tâche ou OT ?)
  &quot; -----------------------------------------------------------

  &quot; Récupér
  SELECT SINGLE trkorr, strkorr
    FROM e070
   WHERE trkorr   EQ @iv_trkorr
     AND trstatus EQ @if_cts_transport_request=&gt;co_status_open
    INTO @DATA(ls_e070).
  IF sy-subrc NE 0.
    &quot; OT déjà libéré
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  IF ls_e070-strkorr IS INITIAL.
    &quot; -----------------------------------------------------------
    &quot; Récupération des Tâches - non libérées - contenue dans l&apos;OT
    &quot; -----------------------------------------------------------

    &quot; Récupération des Tâches non libérées
    SELECT trkorr FROM e070
     WHERE strkorr  EQ @ls_e070-trkorr
       AND trstatus EQ @if_cts_transport_request=&gt;co_status_open
      INTO TABLE @lt_trkorr.

    &quot; Ajout de l&apos;OT à la fin de la table de Travail
    APPEND ls_e070-trkorr TO lt_trkorr.

  ELSE.
    &quot; Tâche
    &quot;&quot;  --&gt; Ajout de la Tâche dans table de travail
    APPEND ls_e070-trkorr TO lt_trkorr.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Libération des Tâches / OTs
  &quot; -----------------------------------------------------------

  LOOP AT lt_trkorr ASSIGNING FIELD-SYMBOL(&lt;lfs_s_trkorr&gt;).

    &quot; Libération de la Tâche / OT
    CALL FUNCTION &apos;TR_RELEASE_REQUEST&apos;
      EXPORTING
        iv_trkorr                  = &lt;lfs_s_trkorr&gt;
        iv_dialog                  = abap_false
        iv_as_background_job       = abap_false
        iv_success_message         = abap_false
        iv_display_export_log      = abap_false
        iv_simulation              = iv_simulation
      IMPORTING
        es_request                 = ls_request
      EXCEPTIONS
        cts_initialization_failure = 1
        enqueue_failed             = 2
        no_authorization           = 3
        invalid_request            = 4
        request_already_released   = 5
        repeat_too_early           = 6
        error_in_export_methods    = 7
        object_check_error         = 8
        docu_missing               = 9
        db_access_error            = 10
        action_aborted_by_user     = 11
        export_failed              = 12
        error_message              = 13
        OTHERS                     = 14.
    IF sy-subrc NE 0 AND ( iv_simulation EQ abap_false AND sy-subrc NE 4 ).
      &quot; Une erreur est survenue
      rv_subrc = sy-subrc.

      IF es_return IS SUPPLIED.
        &quot;&quot;  --&gt; Retourne message d&apos;erreur
        es_return-id         = sy-msgid.
        es_return-type       = sy-msgty.
        es_return-number     = sy-msgno.
        es_return-message_v1 = sy-msgv1.
        es_return-message_v2 = sy-msgv2.
        es_return-message_v3 = sy-msgv3.
        es_return-message_v4 = sy-msgv4.
        MESSAGE ID es_return-id TYPE es_return-type NUMBER es_return-number
              WITH es_return-message_v1 es_return-message_v2
                   es_return-message_v3 es_return-message_v4
              INTO es_return-message.

        &quot;&quot;  --&gt; Rollback
        CALL FUNCTION &apos;BAPI_TRANSACTION_ROLLBACK&apos;.

      ELSE.
        IF iv_simulation EQ abap_true.
          CALL FUNCTION &apos;BAPI_TRANSACTION_COMMIT&apos;
            EXPORTING
              wait = abap_true.

        ENDIF.

      ENDIF.

      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    CLEAR : ls_request.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" VERSION="1" LANGU="F" DESCRIPT="Celio - Transport - OT" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TS_REQUEST_CREATE" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="12 " SRCCOLUMN2="31 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_request_create,
        sysid    TYPE sy-sysid,
        zedreqnb TYPE ztbrequest-zedreqnb,
      END OF   ts_request_create
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TT_REQUEST_CREATE" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="14 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="59 " TYPESRC_LENG="0 " TYPESRC="tt_request_create TYPE STANDARD TABLE OF ts_request_create
            WITH NON-UNIQUE KEY primary_key COMPONENTS sysid
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TS_TRANSPORT_ROAD" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="20 " SRCCOLUMN2="31 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF ts_transport_road,
        source TYPE SYST_SYSID,
        target TYPE SYST_SYSID,
      END OF   ts_transport_road
"/>
  <types CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TT_TRANSPORT_ROAD" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="22 " SRCCOLUMN1="4 " SRCROW2="23 " SRCCOLUMN2="58 " TYPESRC_LENG="0 " TYPESRC="tt_transport_road TYPE STANDARD TABLE OF ts_transport_road
          WITH NON-UNIQUE KEY primary_key COMPONENTS source
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeClasDef CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" TYPEGROUP="ZCL_TRANSPORT_REQUEST_CELIO" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="MC_ATTRIBUTE_DEPENDENCIES" VERSION="1" LANGU="F" DESCRIPT="Attribut d&apos;un ordre" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="2" ATTVALUE="&apos;ZDEPENDENCIES&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="E070A-ATTRIBUTE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="MC_REQUEST_TYPE" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="26 " SRCCOLUMN1="2 " SRCROW2="29 " SRCCOLUMN2="25 " TYPESRC_LENG="165 " TYPESRC="BEGIN OF mc_request_type,
    classic TYPE ztbrequest-zedtrpcode VALUE space,
    authorization TYPE ztbrequest-zedtrpcode VALUE &apos;A&apos;,
  END OF   mc_request_type
"/>
  <attribute CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="MC_SYSTEM" VERSION="1" LANGU="F" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="32 " SRCCOLUMN1="4 " SRCROW2="37 " SRCCOLUMN2="15 " TYPESRC_LENG="230 " TYPESRC="BEGIN OF mc_system,
QUALITY type SY-SYSID value &apos;IE1&apos;, ##NO_TEXT
PREPROD type SY-SYSID value &apos;RE1&apos;, ##NO_TEXT
PRODUCTION type SY-SYSID value &apos;PE1&apos;, ##NO_TEXT
DEVELOPMENT type SY-SYSID value &apos;DE1&apos;, ##NO_TEXT
END OF mc_system
"/>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" VERSION="1" LANGU="F" DESCRIPT="Demande de Transport - Création" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" SCONAME="IT_TRKORR" VERSION="1" LANGU="F" DESCRIPT="Table des numéros d&apos;ordres" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORRS"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" SCONAME="IS_SYSTEM" VERSION="1" LANGU="F" DESCRIPT="Identification du système" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="COAS_SYSTEM"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" SCONAME="IV_EXPRESS" VERSION="1" LANGU="F" DESCRIPT="Express ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" SCONAME="IV_ONLY_SYSID" VERSION="1" LANGU="F" DESCRIPT="Uniquement Système cible ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" SCONAME="EV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" SCONAME="ES_RETURN" VERSION="1" LANGU="F" DESCRIPT="Paramètre de retour" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="BAPIRET2"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="REQUEST_CREATE" SCONAME="RT_REQUEST" VERSION="1" LANGU="F" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZCL_TRANSPORT_REQUEST_CELIO=&gt;TT_REQUEST_CREATE"/>
   <source>METHOD request_create.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : REQUEST_CREATE                                    *
*&amp; Classe          : ZCL_TRANSPORT_REQUEST_CELIO                       *
*&amp; Description     : Demande de Transport - Création                   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 04/04/2019                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_mandt    TYPE sy-mandt,
    lv_released TYPE xsdboolean.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  CLEAR : ev_subrc.

  &quot; -----------------------------------------------------------
  &quot; Libération de l&apos;OT / Tâches
  &quot; -----------------------------------------------------------

  &quot; Libérations des OTs / Tâches
  LOOP AT it_trkorr ASSIGNING FIELD-SYMBOL(&lt;lfs_s_trkorr&gt;).

    IF zcl_transport_request=&gt;transport_request_is_released( &lt;lfs_s_trkorr&gt; )
      EQ abap_false.
      &quot; OT non libéré
      &quot;&quot;  --&gt; Libération de l&apos;OT (et des Tâches)
      IF NOT zcl_transport_request=&gt;transport_request_release(
        EXPORTING
          iv_trkorr = &lt;lfs_s_trkorr&gt;
        IMPORTING
          es_return = es_return
      ) IS INITIAL.
        &quot; Erreur lors de la libération de l&apos;OT
        &quot;&quot;  --&gt; Arrêt du traitement
        ev_subrc = 2.
        RETURN.

      ENDIF.

      &quot; Au moins un OT libérée
      lv_released = abap_true.

    ENDIF.

  ENDLOOP.

  IF lv_released EQ abap_true.
    &quot; Mise en attente le temps que le traitement de libération se finisse
    WAIT UP TO 2 SECONDS.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération Route de Transport
  &quot; -----------------------------------------------------------

  &quot; Récupération des Environnements
  DATA(lt_transport_road) = zcl_transport_request_celio=&gt;transport_road_get(
    iv_sysid      = is_system-sysid
    iv_only_sysid = iv_only_sysid
  ).
  IF lt_transport_road[] IS INITIAL.
    &quot; Aucun Environnement
    &quot;&quot;  --&gt; Arrêt du traitement
    ev_subrc   = 4.
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Création Demande(s) de Transport
  &quot; -----------------------------------------------------------

  IF is_system-mandt IS INITIAL.
    &quot; Utilisation mandant courrant
    lv_mandt = sy-mandt.

  ELSE.
    &quot; Utilisation mandant transmis
    lv_mandt = is_system-mandt.

  ENDIF.

  &quot; Création d&apos;une Demande pour chaque Environnement
  LOOP AT lt_transport_road ASSIGNING FIELD-SYMBOL(&lt;lfs_s_transport_road&gt;).

    &quot; Création de la Requête
    APPEND VALUE #(
      sysid    = &lt;lfs_s_transport_road&gt;-target
      zedreqnb = zcl_transport_request_celio=&gt;_request_create(
                      is_system  = VALUE #(
                        mandt = lv_mandt
                        sysid = &lt;lfs_s_transport_road&gt;-source
                      )
                      it_trkorr  = it_trkorr
                      iv_express = iv_express
                 )
    ) TO rt_request. &quot;Ajout dans la table de sortie

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TRANSPORT_ROAD_GET" VERSION="1" LANGU="F" DESCRIPT="Route de Transport - Récupération" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TRANSPORT_ROAD_GET" SCONAME="IV_SYSID" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : nom du système SAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TRANSPORT_ROAD_GET" SCONAME="IV_ONLY_SYSID" VERSION="1" LANGU="F" DESCRIPT="Uniquement Système cible ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="TRANSPORT_ROAD_GET" SCONAME="RT_TRANSPORT_ROAD" VERSION="1" LANGU="F" DESCRIPT="Type de Table SYST_SYSID" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZCL_TRANSPORT_REQUEST_CELIO=&gt;TT_TRANSPORT_ROAD"/>
   <source>METHOD transport_road_get.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : TRANSPORT_ROAD_GET                                *
*&amp; Classe          : ZCL_TRANSPORT_REQUEST_CELIO                       *
*&amp; Description     : Liste Chemin de Transport                         *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 05/04/2019                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
        ls_transport_road TYPE zcl_transport_request_celio=&gt;ts_transport_road.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; Initialisation première recherche
  ls_transport_road-source = iv_sysid.

  WHILE 1 = 1.
    &quot; -----------------------------------------------------------
    &quot; Recherche des Systèmes Sources
    &quot; -----------------------------------------------------------

    &quot; Récupération Système Source
    SELECT SINGLE zedsoursys, zedtargsys
      FROM ztbdestrfc
     WHERE zedtargsys EQ @ls_transport_road-source
       AND loekz      EQ @abap_false
      INTO @ls_transport_road.
    IF sy-subrc NE 0.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Arrêt de la boucle
      EXIT.

    ENDIF.

    &quot; Ajout du Système Source
    INSERT ls_transport_road INTO rt_transport_road INDEX 1.

    IF iv_only_sysid EQ abap_true.
      &quot; Uniquuement Système cible
      &quot;&quot;  --&gt; Arrêt de la boucle
      EXIT.

    ENDIF.

  ENDWHILE.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE" VERSION="1" LANGU="F" DESCRIPT="Usage Interne : Demande de Transport - Création" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE" SCONAME="IT_TRKORR" VERSION="1" LANGU="F" DESCRIPT="Table des numéros d&apos;ordres" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORRS"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE" SCONAME="IS_SYSTEM" VERSION="1" LANGU="F" DESCRIPT="Identification du système" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="COAS_SYSTEM"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE" SCONAME="IV_EXPRESS" VERSION="1" LANGU="F" DESCRIPT="Express ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE" SCONAME="EV_SUBRC" VERSION="1" LANGU="F" DESCRIPT="Zone système ABAP : code retour des instructions ABAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SY-SUBRC"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE" SCONAME="ES_RETURN" VERSION="1" LANGU="F" DESCRIPT="Paramètre de retour" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="BAPIRET2"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE" SCONAME="RV_REQUEST" VERSION="1" LANGU="F" DESCRIPT="N° Demande" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <source>METHOD _request_create.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _REQUEST_CREATE                                   *
*&amp; Classe          : ZCL_TRANSPORT_REQUEST_CELIO                       *
*&amp; Description     : Demande de Transport - Création                   *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 04/04/2019                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Création de la Demande de Transport
  &quot; -----------------------------------------------------------

  &quot; Création de la Demande de Transport - Batch Input
  rv_request = zcl_transport_request_celio=&gt;_request_create_using_batch(
      is_system  = is_system
      it_trkorr  = it_trkorr
      iv_express = iv_express
  ).

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE_USING_BATCH" VERSION="1" LANGU="F" DESCRIPT="Usage Interne : Demande de Transport - Création Batch Input" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE_USING_BATCH" SCONAME="IS_SYSTEM" VERSION="1" LANGU="F" DESCRIPT="Identification du système" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="COAS_SYSTEM"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE_USING_BATCH" SCONAME="IT_TRKORR" VERSION="1" LANGU="F" DESCRIPT="Table des numéros d&apos;ordres" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TRKORRS"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE_USING_BATCH" SCONAME="IV_EXPRESS" VERSION="1" LANGU="F" DESCRIPT="Express ?" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="XSDBOOLEAN"/>
   <parameter CLSNAME="ZCL_TRANSPORT_REQUEST_CELIO" CMPNAME="_REQUEST_CREATE_USING_BATCH" SCONAME="RV_REQNB" VERSION="1" LANGU="F" DESCRIPT="N° Demande" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZEDREQNB"/>
   <source>METHOD _request_create_using_batch.
*&amp;---------------------------------------------------------------------*
*&amp; Méthode         : _REQUEST_CREATE_USING_BATCH                       *
*&amp; Classe          : ZCL_TRANSPORT_REQUEST_CELIO                       *
*&amp; Description     : Demande de Transport - Création (Batch Input      *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 04/04/2019                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_batch   TYPE bdcdata_tab,
    lt_trkorr  TYPE trkorrs,
    lt_message TYPE wdkmsg_tty.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
  DATA :
          ls_options TYPE ctu_params.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_line    TYPE numc2,
    lv_message TYPE string.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Préparation dossier Batch-Input
  &quot; -----------------------------------------------------------

  lt_batch = VALUE #(
    (
      &quot; Ecran de ZBC_REQUEST_CREATE / Grisée
      program  = &apos;Z_M_BC_TRANSPORT_REQUEST&apos;                 &quot;#EC NOTEXT
      dynpro   = &apos;2000&apos;                                     &quot;#EC NOTEXT
      dynbegin = abap_true
    )
    (
    &quot; Validation
      fnam = &apos;BDC_OKCODE&apos;                                   &quot;#EC NOTEXT
      fval = &apos;=VALI&apos;                                        &quot;#EC NOTEXT
    )
    (
      &quot; Ecran de ZBC_REQUEST_CREATE / Saisie des Info d&apos;Entête
      program  = &apos;Z_M_BC_TRANSPORT_REQUEST&apos;                 &quot;#EC NOTEXT
      dynpro   = &apos;2000&apos;                                     &quot;#EC NOTEXT
      dynbegin = abap_true
    )
    (
    &quot; Système Cible
      fnam = &apos;ZTBREQUEST-ZEDSOURSYS&apos;                        &quot;#EC NOTEXT
      fval = is_system-sysid
    )
    (
    &quot; Mandant Cible
      fnam = &apos;ZTBREQUEST-ZEDSOURMDT&apos;                        &quot;#EC NOTEXT
      fval = is_system-mandt
    )
    (
    &quot; Date
      fnam = &apos;ZTBREQUEST-ZEDTRPDATE&apos;                        &quot;#EC NOTEXT
      fval = |{ sy-datum DATE = USER }|
    )
    (
    &quot; Heure
      fnam = &apos;ZTBREQUEST-ZEDTRPTIME&apos;                        &quot;#EC NOTEXT
      fval = |{ sy-uzeit TIME = USER }|
    )
    (
    &quot; Radio-boutton Mandant-Dépendant
      fnam = &apos;DCLT&apos;                                         &quot;#EC NOTEXT
      fval = abap_true
    )
    (
    &quot; Radio-boutton Inter-Mandant
      fnam = &apos;ICLT&apos;                                         &quot;#EC NOTEXT
      fval = abap_false
    )
    (
    &quot; Validation
      fnam = &apos;BDC_OKCODE&apos;                                   &quot;#EC NOTEXT
      fval = &apos;=VALI&apos;                                        &quot;#EC NOTEXT
    )
  ).

  IF is_system-sysid NE zcl_transport_request_celio=&gt;mc_system-development.
    &quot; -----------------------------------------------------------
    &quot; PopUp Sélection d&apos;une Autre Demande
    &quot; -----------------------------------------------------------

    APPEND LINES OF VALUE bdcdata_tab(
      (
        &quot; PopUp Reprise Demande ?
        program  = &apos;SAPLSWOS&apos;                               &quot;#EC NOTEXT
        dynpro   = &apos;0600&apos;                                   &quot;#EC NOTEXT
        dynbegin = abap_true
      )
      (
        fnam = &apos;BDC_OKCODE&apos;
        fval = &apos;=N&apos;
      )
    ) TO lt_batch.

  ENDIF.

  IF is_system-sysid EQ zcl_transport_request_celio=&gt;mc_system-preprod.
    &quot; Système Source Recette
    IF iv_express EQ abap_true.
      &quot; -----------------------------------------------------------
      &quot; Coche Demande Express
      &quot; -----------------------------------------------------------

      APPEND LINES OF VALUE bdcdata_tab(
        (
          &quot; Ecran de ZBC_REQUEST_CREATE / Saisie des Info d&apos;Entête
          program  = &apos;Z_M_BC_TRANSPORT_REQUEST&apos;             &quot;#EC NOTEXT
          dynpro   = &apos;2000&apos;                                 &quot;#EC NOTEXT
          dynbegin = abap_true
        )
        (
          fnam = &apos;ZTBREQUEST-ZEDELIGIBLE&apos;                   &quot;#EC NOTEXT
          fval = iv_express
        )
      ) TO lt_batch.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Ajout des OTs
  &quot; -----------------------------------------------------------

  &quot; Découpe les OTs par Paquet de 10
  DATA(lo_tranchor) = NEW zcl_tranchor(
    it_data         = it_trkorr
    iv_package_size = 10
  ).

  &quot; Ajout des OTs 10 par 10
  WHILE lo_tranchor-&gt;has_next( ) EQ abap_true.

    &quot; Récupération Paquet Suivant
    lo_tranchor-&gt;get_next( IMPORTING et_package = lt_trkorr ).

    &quot; Réinitialisation Position
    lv_line = 01.

    &quot; Ecran ZBC_REQUEST_CREATE / Saisie OT
    APPEND VALUE #(
      program  = &apos;Z_M_BC_TRANSPORT_REQUEST&apos;                 &quot;#EC NOTEXT
      dynpro   = &apos;2000&apos;                                     &quot;#EC NOTEXT
      dynbegin = abap_true
    ) TO lt_batch.

    &quot; Ajout des OTs
    LOOP AT lt_trkorr ASSIGNING FIELD-SYMBOL(&lt;lfs_s_trkorr&gt;).

      &quot; Ajout de l&apos;OT
      APPEND VALUE #(
          fnam = |GT_ORDER-TRKORR({ lv_line })|             &quot;#EC NOTEXT
          fval = &lt;lfs_s_trkorr&gt;
      ) TO lt_batch.

      &quot; Incrémentation N° Ligne
      ADD 1 TO lv_line.

    ENDLOOP.

    IF lo_tranchor-&gt;has_next( ) EQ abap_true.
      &quot; Saut de Page
      APPEND LINES OF VALUE bdcdata_tab(
        (
          &quot; Ecran de ZBC_REQUEST_CREATE / Saut de Page
          program  = &apos;Z_M_BC_TRANSPORT_REQUEST&apos;             &quot;#EC NOTEXT
          dynpro   = &apos;2000&apos;                                 &quot;#EC NOTEXT
          dynbegin = abap_true
        )
        (
          fnam = &apos;BDC_OKCODE&apos;
          fval = &apos;=P+&apos;
        )
      ) TO lt_batch.

    ENDIF.

  ENDWHILE.

  &quot; -----------------------------------------------------------
  &quot; Finalisation
  &quot; -----------------------------------------------------------

  &quot; Finalisation
  APPEND LINES OF VALUE bdcdata_tab(
      (
        &quot; Ecran de ZBC_REQUEST_CREATE / Sauvegarde
        program  = &apos;Z_M_BC_TRANSPORT_REQUEST&apos;               &quot;#EC NOTEXT
        dynpro   = &apos;2000&apos;                                   &quot;#EC NOTEXT
        dynbegin = abap_true
      )
    (
      fnam = &apos;BDC_OKCODE&apos;                                   &quot;#EC NOTEXT
      fval = &apos;=SAVE&apos;                                        &quot;#EC NOTEXT
    )
  ) TO lt_batch.

  &quot; -----------------------------------------------------------
  &quot; Exécution dossier Batch-Input
  &quot; -----------------------------------------------------------

  &quot; Mode Asychrone / Pas d&apos;affichage
  ls_options-updmode  = &apos;A&apos;.                                &quot;#EC NOTEXT
  ls_options-dismode  = &apos;P&apos;.                                &quot;#EC NOTEXT
  ls_options-racommit = abap_true.

  &quot; Appel de la Transaction
  CALL TRANSACTION &apos;ZBC_REQUEST_CREATE&apos;                     &quot;#EC NOTEXT
           WITHOUT AUTHORITY-CHECK
             USING lt_batch
     MESSAGES INTO lt_message OPTIONS FROM ls_options.

  TRY.
      &quot; Récupération du Numéro de Demande
      lv_message = lt_message[ lines( lt_message ) ]-msgv1.
      FIND REGEX &apos;\d&apos; IN lv_message MATCH OFFSET DATA(lv_offset). &quot;#EC NOTEXT
      IF sy-subrc EQ 0.
        rv_reqnb = lv_message+lv_offset(8).

      ENDIF.

    CATCH cx_sy_itab_line_not_found.

  ENDTRY.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <PROG NAME="ZXSEUU08" VARCL="X" SUBC="I" APPL="S" RMAND="200" RLOAD="F" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="R" ENTRY="Include ZXSEUU08" LENGTH="16 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZXSEUU08
*&amp;---------------------------------------------------------------------*

&quot; Suivant l&apos;action utilisateur
CASE operation.

  WHEN &apos;EDIT&apos;. ##NOTEXT
    &quot; Edition du Code
    IF zcl_transport_request=&gt;object_edition_check( program ) EQ abap_true.
      &quot; L&apos;utilisateur ne souhaite pas poursuivre l&apos;édition
      RAISE cancelled.

    ENDIF.

  WHEN OTHERS.
    &quot; Autre

ENDCASE.</source>
 </PROG>
 <PROG NAME="Z_BC_TRANSPORT_REQUEST_CREATE" VARCL="X" SUBC="1" APPL="*" RSTAT="K" RMAND="200" RLOAD="F" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="E01" ENTRY="Transport par Pattern interdite" LENGTH="62 "/>
    <textElement ID="I" KEY="E02" ENTRY="Erreur création de la Demande" LENGTH="58 "/>
    <textElement ID="I" KEY="E03" ENTRY="Système cible obligatoire" LENGTH="50 "/>
    <textElement ID="I" KEY="E04" ENTRY="OT obligatoire" LENGTH="24 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Créer la Demande malgré contrôle KO ?" LENGTH="50 "/>
    <textElement ID="I" KEY="S01" ENTRY="Demande(s) créé(s)" LENGTH="28 "/>
    <textElement ID="I" KEY="TB1" ENTRY="Paramètres" LENGTH="20 "/>
    <textElement ID="I" KEY="TB2" ENTRY="Options supplémentaires" LENGTH="46 "/>
    <textElement ID="I" KEY="TT1" ENTRY="Création de la Demande" LENGTH="44 "/>
    <textElement ID="R" ENTRY="Demande de Transport - Création" LENGTH="31 "/>
    <textElement ID="S" KEY="P_CHECK" ENTRY="        Contrôler cohérence" LENGTH="27 "/>
    <textElement ID="S" KEY="P_EXPR" ENTRY="        Express" LENGTH="15 "/>
    <textElement ID="S" KEY="P_LJOB" ENTRY="        Déclencher Job Transport" LENGTH="32 "/>
    <textElement ID="S" KEY="P_ONLY" ENTRY="        Uniquement système cible" LENGTH="32 "/>
    <textElement ID="S" KEY="P_SYSID" ENTRY="D       ." LENGTH="21 "/>
    <textElement ID="S" KEY="S_TRKORR" ENTRY="D       ." LENGTH="19 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_BC_TRANSPORT_REQUEST_CREATE
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*
REPORT z_bc_transport_request_create.

TABLES : e070.

***==================================================================***
**                         SELECTION-SCREEN                           **
***==================================================================***

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-tb1.
&quot; -----------------------------------------------------------
&quot; Paramètres
&quot; -----------------------------------------------------------

&quot; Liste OT
SELECT-OPTIONS : s_trkorr FOR e070-trkorr NO INTERVALS.

&quot; Système Cible
PARAMETERS : p_sysid TYPE ztbdestrfc-zedtargsys.

SELECTION-SCREEN SKIP 1.

SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE text-tb2.

&quot; Contrôler cohérence
PARAMETERS : p_check AS CHECKBOX DEFAULT &apos;X&apos;.               &quot;#EC NOTEXT

&quot; Uniquement ce Sytème
PARAMETERS : p_only AS CHECKBOX.

&quot; Express
PARAMETERS : p_expr AS CHECKBOX.

&quot; Déclencher Job Transport
PARAMETERS : p_ljob AS CHECKBOX.

SELECTION-SCREEN END OF BLOCK b2.

SELECTION-SCREEN END OF BLOCK b1.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_sysid.
  &quot; Système Cible - Aide à la recherche
  PERFORM sysid_value_help CHANGING p_sysid.

INITIALIZATION.
*  MESSAGE e323(uc0).

***==================================================================***
**                         START-OF-SELECTION                         **
***==================================================================***
START-OF-SELECTION.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
        lt_trkorr TYPE trkorrs.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_subrc TYPE sy-subrc.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF p_sysid IS INITIAL.
    &quot; Système cible obligatoire
    MESSAGE s000(zcunity) WITH text-e03 DISPLAY LIKE &apos;E&apos;.   &quot;#EC NOTEXT
    RETURN.

  ELSEIF s_trkorr[] IS INITIAL.
    &quot; OT obligatoire
    MESSAGE s000(zcunity) WITH text-e04 DISPLAY LIKE &apos;E&apos;.   &quot;#EC NOTEXT
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Transport des OTs
  &quot; -----------------------------------------------------------

  &quot; Contrôle cohérence saisie
  READ TABLE s_trkorr WITH KEY option = if_trba_selection_c=&gt;gc_option_cp
                  TRANSPORTING NO FIELDS.
  IF sy-subrc EQ 0.
    &quot; Recherche sur Pattern non autorisée
    MESSAGE s000(zcunity) WITH text-e01 DISPLAY LIKE &apos;E&apos;.   &quot;#EC NOTEXT
    RETURN.

  ENDIF.

  &quot; Récupération des OTs
  LOOP AT s_trkorr ASSIGNING FIELD-SYMBOL(&lt;lfs_sr_trkorr&gt;).

    &quot; L&apos;OT existe ?
    SELECT SINGLE trkorr FROM e070 WHERE trkorr EQ @&lt;lfs_sr_trkorr&gt;-low INTO @DATA(lv_trkorr).
    IF sy-subrc NE 0.
      &quot; Aucune correspondance
      &quot;&quot;  --&gt; Passe à l&apos;itération suivante
      CONTINUE.

    ENDIF.

    &quot; Ajout de l&apos;OT
    APPEND lv_trkorr TO lt_trkorr.

  ENDLOOP.

  IF p_check EQ abap_true.
    &quot; Contrôle séquence
    PERFORM request_check CHANGING lv_subrc.
    IF lv_subrc NE 0.
      &quot; Erreur contrôle
      &quot;&quot;  --&gt; PopUp validation création
      DATA : lv_answer TYPE char1.
      CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
        EXPORTING
          titlebar       = text-tt1
          text_question  = text-q01
          text_button_1  = &apos;Oui&apos;(001)
          text_button_2  = &apos;Non&apos;(002)
          default_button = &apos;2&apos;
        IMPORTING
          answer         = lv_answer
        EXCEPTIONS
          text_not_found = 1
          OTHERS         = 2.
      IF sy-subrc NE 0 OR lv_answer NE &apos;1&apos;.
        &quot; Erreur création PopUp // Utilisateur ne souhaite pas poursuivre
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

    ENDIF.

  ENDIF.

  &quot; Création de la Demande
  DATA(lt_request) = zcl_transport_request_celio=&gt;request_create(
    EXPORTING
      it_trkorr     = lt_trkorr
      is_system     = VALUE #(
       mandt = sy-mandt
       sysid = p_sysid
      )
      iv_express    = p_expr
      iv_only_sysid = p_only
*    IMPORTING
*      ev_subrc   = DATA(lv_subrc)
  ).

  LOOP AT lt_request ASSIGNING FIELD-SYMBOL(&lt;lfs_s_request&gt;).

    WRITE : |{ &lt;lfs_s_request&gt;-sysid } : Demande { &lt;lfs_s_request&gt;-zedreqnb } créé|, /. &quot;#EC NOTEXT

  ENDLOOP.


  IF p_ljob EQ abap_true.

    DATA :
      lv_jobname  TYPE tbtcjob-jobname,
      lv_jobcount TYPE tbtcjob-jobcount.

    &quot; -----------------------------------------------------------
    &quot; Lancement du Job de Transport
    &quot; -----------------------------------------------------------

    &quot; Initialisation Nom du Job
    lv_jobname = condense( |TRANSPORT_MAN_{ sy-uname }| ).  &quot;#EC NOTEXT

    &quot; Ouverture JOB
    CALL FUNCTION &apos;JOB_OPEN&apos;
      EXPORTING
        jobname          = lv_jobname
      IMPORTING
        jobcount         = lv_jobcount
      EXCEPTIONS
        cant_create_job  = 1
        invalid_job_data = 2
        jobname_missing  = 3
        OTHERS           = 4.
    IF sy-subrc EQ 0.
      &quot; Appel du Programme avec variante
      SUBMIT z_a_bc_transport_job
         VIA JOB lv_jobname
          NUMBER lv_jobcount
             AND RETURN.

      &quot; Fermeture du Job
      CALL FUNCTION &apos;JOB_CLOSE&apos;
        EXPORTING
          jobcount             = lv_jobcount
          jobname              = lv_jobname
          strtimmed            = abap_true
        EXCEPTIONS
          cant_start_immediate = 1
          invalid_startdate    = 2
          jobname_missing      = 3
          job_close_failed     = 4
          job_nosteps          = 5
          job_notex            = 6
          lock_failed          = 7
          invalid_target       = 8
          OTHERS               = 9.

    ENDIF.

  ENDIF.

END-OF-SELECTION.

FORM sysid_value_help CHANGING ev_sysid TYPE ztbdestrfc-zedtargsys.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_fields   TYPE wlf_tt_help_value,
    lt_valuetab TYPE file_buffer_table.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Aide à la Recherche Système Cible
  &quot; -----------------------------------------------------------

  lt_fields = VALUE #(
    (
      tabname   = &apos;ZTBDESTRFC&apos;                              &quot;#EC NOTEXT
      fieldname = &apos;ZEDTARGSYS&apos;                              &quot;#EC NOTEXT
      selectflag = abap_true
    )
  ).

  &quot; Récupération Liste des Systèmes Cibles
  SELECT DISTINCT ( zedtargsys ) FROM ztbdestrfc
   WHERE loekz EQ @abap_false ORDER BY zedtargsys
    INTO TABLE @lt_valuetab.

  &quot; Affiche PopUp Sélection
  CALL FUNCTION &apos;HELP_VALUES_GET_WITH_TABLE&apos;
    EXPORTING
      display                       = abap_false
      fieldname                     = &apos;ZEDTARSYS&apos;  &quot;#EC NOTEXT
      tabname                       = &apos;ZTBDESTRFC&apos; &quot;#EC NOTEXT
      show_all_values_at_first_time = abap_true
    IMPORTING
      select_value                  = ev_sysid
    TABLES
      fields                        = lt_fields
      valuetab                      = lt_valuetab
    EXCEPTIONS
      field_not_in_ddic             = 1
      more_then_one_selectfield     = 2
      no_selectfield                = 3
      OTHERS                        = 4.
  IF sy-subrc NE 0.
    &quot; Erreur sélection
    CLEAR : ev_sysid.
  ENDIF.

ENDFORM. &quot; SYSID_VALUE_HELP

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REQUEST_CHECK
*&amp;---------------------------------------------------------------------*
*       Contrôle la cohérence de la Demande
*----------------------------------------------------------------------*
*  &lt;-- EV_SUBRC     Code retour
*----------------------------------------------------------------------*
FORM request_check CHANGING ev_subrc TYPE sy-subrc.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_listasci   TYPE list_string_table,
    lt_listobject TYPE table_abaplist.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lor_data       TYPE REF TO data,
    lo_salv_table  TYPE REF TO cl_salv_table,
    lor_line_descr TYPE REF TO cl_abap_datadescr.

***------------------------------------------------------------------***
**                          FIELD-SYMBOLS                             **
***------------------------------------------------------------------***
  FIELD-SYMBOLS :
        &lt;lfs_t_result&gt; TYPE STANDARD TABLE.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  CLEAR : ev_subrc.

  &quot; -----------------------------------------------------------
  &quot; Paramétrage pour récupération ALV résultat
  &quot; -----------------------------------------------------------

  &quot; Récuépration données &amp; metadata
  cl_salv_bs_runtime_info=&gt;set(
    data     = abap_true
    display  = abap_false
    metadata = abap_true
  ).

  &quot; -----------------------------------------------------------
  &quot; Lance le programme de contrôle
  &quot; -----------------------------------------------------------

  &quot; Programme de Contrôle
  SUBMIT z_a_bc_transport_check
    WITH s_trkorr IN s_trkorr[]
    WITH p_sysid  EQ p_sysid
    EXPORTING LIST TO MEMORY
     AND RETURN.

  TRY.
      &quot; -----------------------------------------------------------
      &quot; Récupération résultat du contrôle
      &quot; -----------------------------------------------------------

      &quot; Récupération données
      cl_salv_bs_runtime_info=&gt;get_data_ref( IMPORTING r_data = lor_data ).
      IF lor_data IS BOUND.
        &quot; Données présente
        ASSIGN lor_data-&gt;* TO &lt;lfs_t_result&gt;.

      ENDIF.
      IF NOT &lt;lfs_t_result&gt; IS ASSIGNED
      OR &lt;lfs_t_result&gt; IS INITIAL.
        &quot; Pas de données
        &quot;&quot;  --&gt; Arrêt du traitement
        ev_subrc = 0.
        RETURN.

      ENDIF.

      &quot; Retourne indicateur présence erreur / avertissement
      LOOP AT &lt;lfs_t_result&gt; ASSIGNING FIELD-SYMBOL(&lt;lfs_s_result&gt;).
        ASSIGN COMPONENT &apos;TYPE&apos; OF STRUCTURE &lt;lfs_s_result&gt; TO FIELD-SYMBOL(&lt;lfs_value&gt;).
        IF &lt;lfs_value&gt; CA &apos;EAXIW&apos;.                          &quot;#EC NOTEXT
          ev_subrc = 4.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF ev_subrc IS INITIAL.
        &quot; Aucune erreur / avertissement
        &quot;&quot;  --&gt; Arrêt du traitement
        RETURN.

      ENDIF.

      &quot; Récupération metadata
      DATA(ls_metadata) = cl_salv_bs_runtime_info=&gt;get_metadata( ).

      &quot; Réinitialisation capture ALV
      cl_salv_bs_runtime_info=&gt;clear_all( ).

      TRY.
          &quot; -----------------------------------------------------------
          &quot; Affichage résultat dans une fenêtre modale
          &quot; -----------------------------------------------------------

          &quot; Génération instance ALV
          cl_salv_table=&gt;factory(
            IMPORTING
              r_salv_table   = lo_salv_table
            CHANGING
              t_table        = &lt;lfs_t_result&gt;
          ).

          &quot; Activation fonctions standards
          lo_salv_table-&gt;get_functions( )-&gt;set_all( abap_true ).

          DATA(lv_end_line) = lines( &lt;lfs_t_result&gt; ) + 1.
          IF lv_end_line GT 20. lv_end_line = 20. ENDIF.

          &quot; Initialisation taille fenêtre modale
          lo_salv_table-&gt;set_screen_popup(
            start_line   = 1
            end_line     = lv_end_line
            start_column = 20
            end_column   = 160
          ).

          &quot; Modification Affichage
          zcl_salv_utilities=&gt;fieldcatalog_lvc_to_salv(
            EXPORTING
              it_fieldcatalog = ls_metadata-t_fcat
            CHANGING
              co_salv_table   = lo_salv_table
          ).

          &quot; Modification intitulé
          lo_salv_table-&gt;get_display_settings( )-&gt;set_list_header(
            |Contrôle Demande|                              &quot;#EC NOTEXT
          ).

          &quot; Affichage de l&apos;ALV
          lo_salv_table-&gt;display( ).

        CATCH cx_salv_msg.

      ENDTRY.

    CATCH cx_salv_bs_sc_runtime_info.
      &quot; Erreur récupération données
      &quot;&quot;  --&gt; Le message du programme s&apos;affiche quand même

  ENDTRY.

ENDFORM.</source>
 </PROG>
 <PROG NAME="Z_BC_TRANSPORT_HANA" VARCL="X" SUBC="1" APPL="*" RMAND="200" RLOAD="F" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="143" ENTRY="Package/object is in sync" LENGTH="50 "/>
    <textElement ID="I" KEY="144" ENTRY="Package/object is not in sync" LENGTH="58 "/>
    <textElement ID="I" KEY="145" ENTRY="Cannot synchronize package/object" LENGTH="66 "/>
    <textElement ID="I" KEY="159" ENTRY="Action canceled by user" LENGTH="46 "/>
    <textElement ID="I" KEY="194" ENTRY="Translate packages and objects" LENGTH="60 "/>
    <textElement ID="I" KEY="195" ENTRY="Do not translate packages and objects" LENGTH="74 "/>
    <textElement ID="I" KEY="196" ENTRY="Translation-relevance can only be set after the first synchronization; perform the synchronization first" LENGTH="132 "/>
    <textElement ID="I" KEY="197" ENTRY="Package and associated objects are relevant for translation" LENGTH="118 "/>
    <textElement ID="I" KEY="198" ENTRY="Package and associated objects are not relevant for translation" LENGTH="126 "/>
    <textElement ID="I" KEY="199" ENTRY="Package &amp;1 set to translation-relevant" LENGTH="76 "/>
    <textElement ID="I" KEY="200" ENTRY="Package &amp;1 set to not translation-relevant" LENGTH="84 "/>
    <textElement ID="I" KEY="202" ENTRY="The texts of the objects in the chosen packages are not available until the first synchronization of the objects in ABAP." LENGTH="132 "/>
    <textElement ID="I" KEY="211" ENTRY="Package/object not deployed" LENGTH="54 "/>
    <textElement ID="I" KEY="212" ENTRY="Package/object cannot be deployed" LENGTH="66 "/>
    <textElement ID="I" KEY="230" ENTRY="Package/object is deployed" LENGTH="52 "/>
    <textElement ID="I" KEY="232" ENTRY="Packages /" LENGTH="20 "/>
    <textElement ID="I" KEY="234" ENTRY="Objects" LENGTH="17 "/>
    <textElement ID="I" KEY="TB1" ENTRY="Sélection Package" LENGTH="42 "/>
    <textElement ID="R" ENTRY="HANA - Outil de Transport" LENGTH="25 "/>
    <textElement ID="S" KEY="PV_PACK" ENTRY="        SAP HANA Repository Package" LENGTH="35 "/>
    <textElement ID="S" KEY="PV_SUB" ENTRY="        Inclure Sous-Package" LENGTH="28 "/>
   </language>
  </textPool>
  <dynpros>
   <dynpro PROG="Z_BC_TRANSPORT_HANA" DNUM="2000" FNUM="2000" BZMX="4 " BZBR="79 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="17 " NOCO="118 " VALP="0 " CUAN="G" SPRA="F" DTEXT="Status-Filter für ALV List Ausgabe">
    <dynprofield FNAM="GREEN" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" ITYP="C" AGLT="00" ADEZ="00"/>
    <dynprofield FNAM="GREEN" DIDX="0002" FLG1="00" FLG2="00" FLG3="00" FILL="C" FMB1="30" FMB2="00" LENG="0A" LINE="01" COLN="04" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" ITYP="0" AGLT="00" ADEZ="00" STXT="@5B\Qgrün@"/>
    <dynprofield FNAM="TEXT_GREEN" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="28" LINE="01" COLN="08" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________________________________________"/>
    <dynprofield FNAM="NO_P_GREEN" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="01" COLN="31" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_PAKETE_1" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="09" LINE="01" COLN="38" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="_________"/>
    <dynprofield FNAM="NO_O_GREEN" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="01" COLN="42" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_OBJEKTE_1" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="08" LINE="01" COLN="49" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________"/>
    <dynprofield FNAM="YELLOW" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="02" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" ITYP="C" AGLT="00" ADEZ="00"/>
    <dynprofield FNAM="YELLOW" DIDX="0002" FLG1="00" FLG2="00" FLG3="00" FILL="C" FMB1="30" FMB2="00" LENG="0A" LINE="02" COLN="04" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" ITYP="0" AGLT="00" ADEZ="00" STXT="@5D\Qgelb@"/>
    <dynprofield FNAM="TEXT_YELLOW" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="28" LINE="02" COLN="08" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________________________________________"/>
    <dynprofield FNAM="NO_P_YELLOW" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="02" COLN="31" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_PAKETE_2" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="09" LINE="02" COLN="38" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="_________"/>
    <dynprofield FNAM="NO_O_YELLOW" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="02" COLN="42" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_OBJEKTE_2" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="08" LINE="02" COLN="49" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________"/>
    <dynprofield FNAM="RED" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="03" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" ITYP="C" AGLT="00" ADEZ="00"/>
    <dynprofield FNAM="RED" DIDX="0002" FLG1="00" FLG2="00" FLG3="00" FILL="C" FMB1="30" FMB2="00" LENG="09" LINE="03" COLN="04" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" ITYP="0" AGLT="00" ADEZ="00" STXT="@5C\Qrot@"/>
    <dynprofield FNAM="TEXT_RED" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="28" LINE="03" COLN="08" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________________________________________"/>
    <dynprofield FNAM="NO_P_RED" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="03" COLN="31" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_PAKETE_3" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="09" LINE="03" COLN="38" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="_________"/>
    <dynprofield FNAM="NO_O_RED" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="03" COLN="42" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_OBJEKTE_3" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="08" LINE="03" COLN="49" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________"/>
    <dynprofield FNAM="INACTIVE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="04" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="104" ITYP="C" AGLT="00" ADEZ="00"/>
    <dynprofield FNAM="INACTIVE" DIDX="0002" FLG1="00" FLG2="00" FLG3="00" FILL="C" FMB1="30" FMB2="00" LENG="0A" LINE="04" COLN="04" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="104" ITYP="0" AGLT="00" ADEZ="00" STXT="@BZ\Qgrau@"/>
    <dynprofield FNAM="TEXT_INACTIVE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="28" LINE="04" COLN="08" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________________________________________"/>
    <dynprofield FNAM="NO_P_INACTIVE" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="04" COLN="31" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_PAKETE_4" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="09" LINE="04" COLN="38" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="_________"/>
    <dynprofield FNAM="NO_O_INACTIVE" DIDX="0000" FLG1="80" FLG2="20" FLG3="80" FMB1="31" FMB2="00" LENG="06" LINE="04" COLN="42" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="TEXT_OBJEKTE_4" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="31" FMB2="00" LENG="08" LINE="04" COLN="49" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="________"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE status_2000.

PROCESS AFTER INPUT.
  MODULE user_command_2000.</dynproflowsource>
   </dynpro>
  </dynpros>
  <pfstatus>
   <pfstatus_sta CODE="HOTA_DEPL" MODAL="D" ACTCODE="000001" PFKCODE="000001" BUTCODE="0001" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Deployment"/>
   <pfstatus_sta CODE="HOTA_SYNC" MODAL="D" ACTCODE="000002" PFKCODE="000002" BUTCODE="0001" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Synchronisierung"/>
   <pfstatus_sta CODE="START_DEPL" MODAL="D" ACTCODE="000003" PFKCODE="000003" BUTCODE="0001" INT_NOTE="Paketauswahl für Deployment UI"/>
   <pfstatus_sta CODE="START_SYNC" MODAL="D" ACTCODE="000004" PFKCODE="000004" BUTCODE="0001" INT_NOTE="Paketauswahl für Synchronisierung UI"/>
   <pfstatus_fun CODE="%SC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH" ICON_ID="@13@" FUN_TEXT="Suchen" PATH="C"/>
   <pfstatus_fun CODE="%SC+" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH_NEXT" ICON_ID="@4E@" FUN_TEXT="Weiter suchen"/>
   <pfstatus_fun CODE="&amp;AVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_SAVE" ICON_ID="@DN@" FUN_TEXT="Layout sichern..." PATH="Y"/>
   <pfstatus_fun CODE="&amp;CRB" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOTAL_LEFT" ICON_ID="@0B@" FUN_TEXT="Erste Spalte"/>
   <pfstatus_fun CODE="&amp;CRE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOTAL_RIGHT" ICON_ID="@0C@" FUN_TEXT="Letzte Spalte"/>
   <pfstatus_fun CODE="&amp;CRL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLUMN_LEFT" ICON_ID="@0D@" FUN_TEXT="Spalte links"/>
   <pfstatus_fun CODE="&amp;CRR" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLUMN_RIGHT" ICON_ID="@0E@" FUN_TEXT="Spalte rechts"/>
   <pfstatus_fun CODE="&amp;ETA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_DETAIL" ICON_ID="@16@" FUN_TEXT="Details anzeigen" INFO_TEXT="Details zu Paket/Objekt anzeigen" PATH="D"/>
   <pfstatus_fun CODE="&amp;F03" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Zurück" PATH="Z"/>
   <pfstatus_fun CODE="&amp;F12" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Abbrechen" PATH="A"/>
   <pfstatus_fun CODE="&amp;F15" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Beenden" PATH="B"/>
   <pfstatus_fun CODE="&amp;INFO" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Info"/>
   <pfstatus_fun CODE="&amp;OAD" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_CHOOSE" ICON_ID="@DM@" FUN_TEXT="Layout auswählen..." PATH="A"/>
   <pfstatus_fun CODE="&amp;ODN" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_DOWN" ICON_ID="@3F@" FUN_TEXT="Sortieren absteigend" PATH="O"/>
   <pfstatus_fun CODE="&amp;OL0" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANTS" ICON_ID="@LZ@" FUN_TEXT="Layout ändern..." PATH="L"/>
   <pfstatus_fun CODE="&amp;OUP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_UP" ICON_ID="@3E@" FUN_TEXT="Sortieren aufsteig." PATH="I"/>
   <pfstatus_fun CODE="&amp;RNT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_PRINT" ICON_ID="@0X@" FUN_TEXT="Drucken"/>
   <pfstatus_fun CODE="&amp;SC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH" ICON_ID="@13@" FUN_TEXT="Suchen"/>
   <pfstatus_fun CODE="&amp;SC+" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH_NEXT" ICON_ID="@4E@" FUN_TEXT="Weiter suchen"/>
   <pfstatus_fun CODE="AUSF" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Ausführen" PATH="A"/>
   <pfstatus_fun CODE="DEPL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Deployen von ABAP nach SAP HANA" INFO_TEXT="Deployen von ABAP nach SAP HANA" PATH="E"/>
   <pfstatus_fun CODE="DEPL_T" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Deployment" PATH="D"/>
   <pfstatus_fun CODE="DESEL_ALL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DESELECT_ALL" ICON_ID="@4D@" FUN_TEXT="Alle synchronisierb. Pak/Obj entmarkier." INFO_TEXT="Alle synchronisierbaren Pakete/Objekte entmarkieren" PATH="E"/>
   <pfstatus_fun CODE="DESEL_PACK" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DESELECT_BLOCK" ICON_ID="@8J@" FUN_TEXT="Pak./Obj. im akt. Block entmarkieren" INFO_TEXT="Paket/Objekte im aktuellen Block entmarkieren" PATH="I"/>
   <pfstatus_fun CODE="DES_ALL_D" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DESELECT_ALL" ICON_ID="@4D@" FUN_TEXT="Alle deployb. Pak/Obj entmarkier." PATH="E"/>
   <pfstatus_fun CODE="FILTER" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLOR" ICON_ID="@G3@" FUN_TEXT="Filter setzen" ICON_TEXT="Filter setzen" INFO_TEXT="Filter setzen" PATH="F"/>
   <pfstatus_fun CODE="INFO" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Dokumentation anzeigen"/>
   <pfstatus_fun CODE="INFO_D" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Dokumentation anzeigen"/>
   <pfstatus_fun CODE="INFO_S" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Dokumentation anzeigen"/>
   <pfstatus_fun CODE="LEGEND" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ICON_LIST" ICON_ID="@3D@" FUN_TEXT="Legende"/>
   <pfstatus_fun CODE="REFRESH" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_REFRESH" ICON_ID="@42@" FUN_TEXT="Auffrischen" PATH="U"/>
   <pfstatus_fun CODE="SE09" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Transport Organizer" PATH="T"/>
   <pfstatus_fun CODE="SELECT_ALL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_ALL" ICON_ID="@4B@" FUN_TEXT="Alle synchronisierb. Pak./Obj. markieren" INFO_TEXT="Alle synchronisierbaren Pakete/Objekte markieren" PATH="L"/>
   <pfstatus_fun CODE="SEL_ALL_D" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_ALL" ICON_ID="@4B@" FUN_TEXT="Alle deployb. Pak./Obj. markieren" PATH="L"/>
   <pfstatus_fun CODE="SEL_DEPL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_WITH_CONDITION" ICON_ID="@KG@" FUN_TEXT="Zu deployende markieren" PATH="Z"/>
   <pfstatus_fun CODE="SEL_PACK" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_BLOCK" ICON_ID="@4C@" FUN_TEXT="Pak./Obj. im aktuellen Block markieren" INFO_TEXT="Paket/Objekte im aktuellen Block markieren" PATH="B"/>
   <pfstatus_fun CODE="SEL_SYNC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_WITH_CONDITION" ICON_ID="@KG@" FUN_TEXT="Zu synchronisierende markieren" INFO_TEXT="Zu synchronisierende Pakete/Objekte markieren" PATH="Z"/>
   <pfstatus_fun CODE="SETDEPMODE" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Deploymodus festlegen" PATH="D"/>
   <pfstatus_fun CODE="SYNC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Synchronisieren von SAP HANA nach ABAP" INFO_TEXT="Synchronisieren von SAP HANA Repository nach ABAP" PATH="S"/>
   <pfstatus_fun CODE="SYNC_T" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Synchronisierung" PATH="S"/>
   <pfstatus_fun CODE="TRANSLMODE" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Übersetzungsrelevanz festlegen" PATH="Ü"/>
   <pfstatus_fun CODE="VERS" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Versionsverwaltung" PATH="V"/>
   <pfstatus_men CODE="000001" NO="01" REF_TYPE="F" REF_CODE="&amp;ETA" REF_NO="001"/>
   <pfstatus_men CODE="000001" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000001" NO="03" REF_TYPE="F" REF_CODE="DEPL" REF_NO="001"/>
   <pfstatus_men CODE="000001" NO="04" REF_TYPE="S"/>
   <pfstatus_men CODE="000001" NO="05" REF_TYPE="F" REF_CODE="&amp;F15" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="01" REF_TYPE="F" REF_CODE="REFRESH" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000002" NO="03" REF_TYPE="F" REF_CODE="SEL_ALL_D" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="04" REF_TYPE="F" REF_CODE="DES_ALL_D" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="05" REF_TYPE="F" REF_CODE="SEL_PACK" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="06" REF_TYPE="F" REF_CODE="DESEL_PACK" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="07" REF_TYPE="F" REF_CODE="SEL_DEPL" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="08" REF_TYPE="S"/>
   <pfstatus_men CODE="000002" NO="09" REF_TYPE="F" REF_CODE="FILTER" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="10" REF_TYPE="S"/>
   <pfstatus_men CODE="000002" NO="11" REF_TYPE="F" REF_CODE="%SC" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="12" REF_TYPE="F" REF_CODE="&amp;F12" REF_NO="001"/>
   <pfstatus_men CODE="000003" NO="01" REF_TYPE="F" REF_CODE="SYNC_T" REF_NO="001"/>
   <pfstatus_men CODE="000003" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000003" NO="03" REF_TYPE="F" REF_CODE="&amp;F03" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="01" REF_TYPE="F" REF_CODE="&amp;OL0" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="02" REF_TYPE="F" REF_CODE="&amp;OAD" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="03" REF_TYPE="F" REF_CODE="&amp;AVE" REF_NO="001"/>
   <pfstatus_men CODE="000005" NO="01" REF_TYPE="F" REF_CODE="VERS" REF_NO="001"/>
   <pfstatus_men CODE="000006" NO="01" REF_TYPE="F" REF_CODE="&amp;ETA" REF_NO="001"/>
   <pfstatus_men CODE="000006" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000006" NO="03" REF_TYPE="F" REF_CODE="SYNC" REF_NO="001"/>
   <pfstatus_men CODE="000006" NO="04" REF_TYPE="S"/>
   <pfstatus_men CODE="000006" NO="05" REF_TYPE="F" REF_CODE="&amp;F15" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="01" REF_TYPE="F" REF_CODE="REFRESH" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000007" NO="03" REF_TYPE="F" REF_CODE="SELECT_ALL" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="04" REF_TYPE="F" REF_CODE="DESEL_ALL" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="05" REF_TYPE="F" REF_CODE="SEL_PACK" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="06" REF_TYPE="F" REF_CODE="DESEL_PACK" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="07" REF_TYPE="F" REF_CODE="SEL_SYNC" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="08" REF_TYPE="S"/>
   <pfstatus_men CODE="000007" NO="09" REF_TYPE="F" REF_CODE="FILTER" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="10" REF_TYPE="S"/>
   <pfstatus_men CODE="000007" NO="11" REF_TYPE="F" REF_CODE="%SC" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="12" REF_TYPE="F" REF_CODE="&amp;F12" REF_NO="001"/>
   <pfstatus_men CODE="000008" NO="01" REF_TYPE="F" REF_CODE="SE09" REF_NO="001"/>
   <pfstatus_men CODE="000008" NO="02" REF_TYPE="F" REF_CODE="DEPL_T" REF_NO="001"/>
   <pfstatus_men CODE="000008" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000008" NO="04" REF_TYPE="F" REF_CODE="&amp;F03" REF_NO="001"/>
   <pfstatus_men CODE="000009" NO="01" REF_TYPE="F" REF_CODE="&amp;OL0" REF_NO="001"/>
   <pfstatus_men CODE="000009" NO="02" REF_TYPE="F" REF_CODE="&amp;OAD" REF_NO="001"/>
   <pfstatus_men CODE="000009" NO="03" REF_TYPE="F" REF_CODE="&amp;AVE" REF_NO="001"/>
   <pfstatus_men CODE="000010" NO="01" REF_TYPE="F" REF_CODE="SETDEPMODE" REF_NO="001"/>
   <pfstatus_men CODE="000010" NO="02" REF_TYPE="F" REF_CODE="TRANSLMODE" REF_NO="001"/>
   <pfstatus_men CODE="000010" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000010" NO="04" REF_TYPE="F" REF_CODE="VERS" REF_NO="001"/>
   <pfstatus_men CODE="000011" NO="01" REF_TYPE="F" REF_CODE="AUSF" REF_NO="001"/>
   <pfstatus_men CODE="000011" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000011" NO="03" REF_TYPE="F" REF_CODE="&amp;F15" REF_NO="001"/>
   <pfstatus_men CODE="000012" NO="01" REF_TYPE="F" REF_CODE="&amp;F12" REF_NO="001"/>
   <pfstatus_men CODE="000013" NO="01" REF_TYPE="F" REF_CODE="SYNC_T" REF_NO="001"/>
   <pfstatus_men CODE="000013" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000013" NO="03" REF_TYPE="F" REF_CODE="&amp;F03" REF_NO="001"/>
   <pfstatus_men CODE="000014" NO="01" REF_TYPE="F" REF_CODE="AUSF" REF_NO="001"/>
   <pfstatus_men CODE="000014" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000014" NO="03" REF_TYPE="F" REF_CODE="&amp;F15" REF_NO="001"/>
   <pfstatus_men CODE="000015" NO="01" REF_TYPE="F" REF_CODE="&amp;F12" REF_NO="001"/>
   <pfstatus_men CODE="000016" NO="01" REF_TYPE="F" REF_CODE="DEPL_T" REF_NO="001"/>
   <pfstatus_men CODE="000016" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000016" NO="03" REF_TYPE="F" REF_CODE="&amp;F03" REF_NO="001"/>
   <pfstatus_mtx CODE="000001" TEXT_TYPE="S" TEXT="Paket/Objekt" PATH="P"/>
   <pfstatus_mtx CODE="000002" TEXT_TYPE="S" TEXT="Bearbeiten" PATH="B"/>
   <pfstatus_mtx CODE="000003" TEXT_TYPE="S" TEXT="Springen" PATH="S"/>
   <pfstatus_mtx CODE="000004" TEXT_TYPE="S" TEXT="Einstellungen" PATH="E"/>
   <pfstatus_mtx CODE="000005" TEXT_TYPE="S" TEXT="Hilfsmittel" PATH="M"/>
   <pfstatus_mtx CODE="000006" TEXT_TYPE="S" TEXT="Paket/Objekt" PATH="P" INT_NOTE="Normergänzung"/>
   <pfstatus_mtx CODE="000007" TEXT_TYPE="S" TEXT="Bearbeiten" PATH="B" INT_NOTE="Normergänzung"/>
   <pfstatus_mtx CODE="000008" TEXT_TYPE="S" TEXT="Springen" PATH="S" INT_NOTE="Normergänzung"/>
   <pfstatus_mtx CODE="000009" TEXT_TYPE="S" TEXT="Einstellungen" PATH="E"/>
   <pfstatus_mtx CODE="000010" TEXT_TYPE="S" TEXT="Hilfsmittel" PATH="M"/>
   <pfstatus_mtx CODE="000011" TEXT_TYPE="S" TEXT="Programm" PATH="P"/>
   <pfstatus_mtx CODE="000012" TEXT_TYPE="S" TEXT="Bearbeiten" PATH="B"/>
   <pfstatus_mtx CODE="000013" TEXT_TYPE="S" TEXT="Springen" PATH="S"/>
   <pfstatus_mtx CODE="000014" TEXT_TYPE="S" TEXT="Programm" PATH="P"/>
   <pfstatus_mtx CODE="000015" TEXT_TYPE="S" TEXT="Bearbeiten" PATH="B"/>
   <pfstatus_mtx CODE="000016" TEXT_TYPE="S" TEXT="Springen" PATH="S"/>
   <pfstatus_act CODE="000001" NO="01" MENUCODE="000001"/>
   <pfstatus_act CODE="000001" NO="02" MENUCODE="000002"/>
   <pfstatus_act CODE="000001" NO="03" MENUCODE="000003"/>
   <pfstatus_act CODE="000001" NO="04" MENUCODE="000004"/>
   <pfstatus_act CODE="000001" NO="05" MENUCODE="000005"/>
   <pfstatus_act CODE="000002" NO="01" MENUCODE="000006"/>
   <pfstatus_act CODE="000002" NO="02" MENUCODE="000007"/>
   <pfstatus_act CODE="000002" NO="03" MENUCODE="000008"/>
   <pfstatus_act CODE="000002" NO="04" MENUCODE="000009"/>
   <pfstatus_act CODE="000002" NO="05" MENUCODE="000010"/>
   <pfstatus_act CODE="000003" NO="01" MENUCODE="000011"/>
   <pfstatus_act CODE="000003" NO="02" MENUCODE="000012"/>
   <pfstatus_act CODE="000003" NO="03" MENUCODE="000013"/>
   <pfstatus_act CODE="000004" NO="01" MENUCODE="000014"/>
   <pfstatus_act CODE="000004" NO="02" MENUCODE="000015"/>
   <pfstatus_act CODE="000004" NO="03" MENUCODE="000016"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="01" PFNO="08"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="02" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="03" PFNO="02"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="04" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="05" PFNO="05"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="06" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="07" PFNO="06"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="08" PFNO="18"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="09" PFNO="09"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="10" PFNO="21"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="11" PFNO="07"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="12" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="13" PFNO="32"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="14" PFNO="33"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="15" PFNO="34"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="16" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="17" PFNO="26"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="18" PFNO="27"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="19" PFNO="19"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="20" PFNO="20"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="21" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="22" PFNO="37"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="23" PFNO="13"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="24" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="25" PFNO="35"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="01" PFNO="08"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="02" PFNO="S"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="03" PFNO="02"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="04" PFNO="S"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="05" PFNO="05"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="06" PFNO="S"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="07" PFNO="06"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="08" PFNO="18"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="09" PFNO="09"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="10" PFNO="21"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="11" PFNO="07"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="12" PFNO="S"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="13" PFNO="32"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="14" PFNO="33"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="15" PFNO="34"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="16" PFNO="S"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="17" PFNO="26"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="18" PFNO="27"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="19" PFNO="19"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="20" PFNO="20"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="21" PFNO="S"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="22" PFNO="37"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="23" PFNO="13"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="24" PFNO="S"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="25" PFNO="35"/>
   <pfstatus_but PFK_CODE="000003" CODE="0001" NO="01" PFNO="08"/>
   <pfstatus_but PFK_CODE="000003" CODE="0001" NO="02" PFNO="25"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="01" PFNO="08"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="02" PFNO="25"/>
   <pfstatus_pfk CODE="000001" PFNO="02" FUNCODE="&amp;ETA" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="&amp;F03" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="05" FUNCODE="REFRESH" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="06" FUNCODE="SEL_ALL_D" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="07" FUNCODE="SEL_DEPL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="08" FUNCODE="DEPL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="09" FUNCODE="SEL_PACK" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="&amp;F12" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="13" FUNCODE="INFO" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="&amp;F15" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="18" FUNCODE="DES_ALL_D" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="19" FUNCODE="&amp;CRB" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="20" FUNCODE="&amp;CRE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="21" FUNCODE="DESEL_PACK" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="26" FUNCODE="&amp;CRL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="27" FUNCODE="&amp;CRR" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="32" FUNCODE="&amp;OL0" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="33" FUNCODE="&amp;OAD" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="34" FUNCODE="&amp;AVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="35" FUNCODE="FILTER" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="36" FUNCODE="SYNC_T" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="37" FUNCODE="LEGEND" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="71" FUNCODE="%SC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="84" FUNCODE="%SC+" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="86" FUNCODE="&amp;RNT" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="02" FUNCODE="&amp;ETA" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="03" FUNCODE="&amp;F03" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="05" FUNCODE="REFRESH" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="06" FUNCODE="SELECT_ALL" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="07" FUNCODE="SEL_SYNC" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="08" FUNCODE="SYNC" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="09" FUNCODE="SEL_PACK" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="12" FUNCODE="&amp;F12" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="13" FUNCODE="INFO" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="15" FUNCODE="&amp;F15" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="18" FUNCODE="DESEL_ALL" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="19" FUNCODE="&amp;CRB" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="20" FUNCODE="&amp;CRE" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="21" FUNCODE="DESEL_PACK" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="25" FUNCODE="&amp;INFO" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="26" FUNCODE="&amp;CRL" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="27" FUNCODE="&amp;CRR" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="28" FUNCODE="&amp;OUP" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="32" FUNCODE="&amp;OL0" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="33" FUNCODE="&amp;OAD" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="34" FUNCODE="&amp;AVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="35" FUNCODE="FILTER" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="36" FUNCODE="DEPL_T" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="37" FUNCODE="LEGEND" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="40" FUNCODE="&amp;ODN" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="71" FUNCODE="%SC" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="84" FUNCODE="%SC+" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="86" FUNCODE="&amp;RNT" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="03" FUNCODE="&amp;F03" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="08" FUNCODE="AUSF" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="12" FUNCODE="&amp;F12" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="15" FUNCODE="&amp;F15" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="25" FUNCODE="INFO_D" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="36" FUNCODE="SYNC_T" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="03" FUNCODE="&amp;F03" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="08" FUNCODE="AUSF" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="12" FUNCODE="&amp;F12" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="15" FUNCODE="&amp;F15" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="25" FUNCODE="INFO_S" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="36" FUNCODE="DEPL_T" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="71" FUNCODE="&amp;SC" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="84" FUNCODE="&amp;SC+" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="86" FUNCODE="&amp;RNT" FUNNO="001"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="%SC"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="%SC+"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;AVE"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;CRB"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;CRE"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;CRL"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;CRR"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;ETA"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;F03"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;F12"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;F15"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;OAD"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;OL0"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="&amp;RNT"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="DEPL"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="DESEL_PACK"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="DES_ALL_D"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="FILTER"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="INFO"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="LEGEND"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="REFRESH"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="SE09"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="SEL"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="SELECT_ALL"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="SEL_ALL_D"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="SEL_DEPL"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="SEL_PACK"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="SYNC_T"/>
   <pfstatus_set STATUS="HOTA_DEPL" FUNCTION="VERS"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="%SC"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="%SC+"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;AVE"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;CRB"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;CRE"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;CRL"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;CRR"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;ETA"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;F03"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;F12"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;F15"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;F3"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;INFO"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;OAD"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;ODN"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;OL0"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;OUP"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="&amp;RNT"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="DEPL_T"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="DESEL_ALL"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="DESEL_PACK"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="FILTER"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="INFO"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="LEGEND"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="REFRESH"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="SE09"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="SEL"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="SELECT_ALL"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="SEL_PACK"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="SEL_SYNC"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="SETDEPMODE"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="SYNC"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="TRANSLMODE"/>
   <pfstatus_set STATUS="HOTA_SYNC" FUNCTION="VERS"/>
   <pfstatus_set STATUS="START_DEPL" FUNCTION="&amp;F03"/>
   <pfstatus_set STATUS="START_DEPL" FUNCTION="&amp;F12"/>
   <pfstatus_set STATUS="START_DEPL" FUNCTION="&amp;F15"/>
   <pfstatus_set STATUS="START_DEPL" FUNCTION="AUSF"/>
   <pfstatus_set STATUS="START_DEPL" FUNCTION="INFO_D"/>
   <pfstatus_set STATUS="START_DEPL" FUNCTION="SYNC-T"/>
   <pfstatus_set STATUS="START_DEPL" FUNCTION="SYNC_T"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="&amp;F03"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="&amp;F12"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="&amp;F15"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="&amp;RNT"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="&amp;SC"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="&amp;SC+"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="AUSF"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="DEPL_T"/>
   <pfstatus_set STATUS="START_SYNC" FUNCTION="INFO_S"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Deployment"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="D" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Deployment"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" MODAL="D" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Deployment"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000002" MODAL="D" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Synchronisierung"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000002" MODAL="D" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Synchronisierung"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000002" SUB_CODE="0001" MODAL="D" INT_NOTE="ALV List Ausgabe des HOTA Organizers - Synchronisierung"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000003" MODAL="D" INT_NOTE="Paketauswahl für Deployment UI"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000003" MODAL="D" INT_NOTE="Paketauswahl für Deployment UI"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000003" SUB_CODE="0001" MODAL="D" INT_NOTE="Paketauswahl für Deployment UI"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000004" MODAL="D" INT_NOTE="Paketauswahl für Synchronisierung UI"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000004" MODAL="D" INT_NOTE="Paketauswahl für Synchronisierung UI"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000004" SUB_CODE="0001" MODAL="D" INT_NOTE="Paketauswahl für Synchronisierung UI"/>
   <pfstatus_tit CODE="DEPLOYMENT" TEXT="SAP HANA Transport for ABAP - Deployment"/>
   <pfstatus_tit CODE="FILTER_TITEL" TEXT="Filter setzen"/>
   <pfstatus_tit CODE="SYNCHRONISATION" TEXT="SAP HANA Transport for ABAP - Synchronisierung"/>
  </pfstatus>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Programme       : Z_BC_TRANSPORT_HANA                               *
*&amp; Description     : Transport Objet HANA                              *
*                    Copie du Standard SCTS_HOTA_ORGANIZER             *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 04/04/2018                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

REPORT z_bc_transport_hana.

DATA: gv_sync TYPE c,
      gv_depl TYPE c.

INTERFACE lif_data_provider.

  METHODS:
    &quot;! Finds active objects in HANA for a specified package and status and returns them as list.
    &quot;!
    &quot;! @parameter i_hana_package_id | package_id in HANA for which all objects should be read
    &quot;! @parameter i_object_status | &quot;-1&quot; find all objects, &quot;0&quot; find objects with status OK, &quot;1&quot; find objects with status BROKEN, &quot;2&quot; find objects with status NEEDS_REGEN
    &quot;! @parameter r_objects | table with all objects found for input parameter
    find_active_objects_in_hana
      IMPORTING
        i_hana_package_id TYPE string
        i_object_status   TYPE string
      RETURNING
        VALUE(r_objects)  TYPE cl_nhi_object_id_and_caption=&gt;ty_objlist_caption
      RAISING
        cx_hana_object_transport.

ENDINTERFACE.

CLASS lcl_data_provider DEFINITION.
  PUBLIC SECTION.
    INTERFACES:
      lif_data_provider.
ENDCLASS.

CLASS lcl_data_provider IMPLEMENTATION.

  METHOD lif_data_provider~find_active_objects_in_hana.

    r_objects = cl_cts_hot_hana_connector=&gt;create_instance( )-&gt;find_active_objects_in_hana(
                                  i_hana_package_id = i_hana_package_id
                                  i_object_status   = i_object_status ).

  ENDMETHOD.

ENDCLASS.

CLASS ltc_deployment DEFINITION DEFERRED.
CLASS lcl_hota_organizer DEFINITION FRIENDS ltc_deployment.
  PUBLIC SECTION.
    TYPES: BEGIN OF ty_filter_data,
             show_green           TYPE abap_bool,
             show_yellow          TYPE abap_bool,
             show_red             TYPE abap_bool,
             show_inactive        TYPE abap_bool,
             nr_packages_green    TYPE i,
             nr_packages_yellow   TYPE i,
             nr_packages_red      TYPE i,
             nr_packages_inactive TYPE i,
             nr_objects_green     TYPE i,
             nr_objects_yellow    TYPE i,
             nr_objects_red       TYPE i,
             nr_objects_inactive  TYPE i,
           END OF ty_filter_data.

    DATA:
      &quot;! Stores the search/select string of the user
      mv_search_string       TYPE string READ-ONLY,
      &quot;! Stores whether subpackages should also be taken into account
      mv_include_subpackages TYPE abap_bool READ-ONLY.

    METHODS:
      constructor
        RAISING
          cx_hana_object_transport,

      &quot;! Displays the data in hierarchy table
      display_data,

      &quot;! Read user values for passed parameters if not initial and returns in corresponding changing parameter
      read_user_value
        IMPORTING
          i_param_name    TYPE string
        RETURNING
          VALUE(r_result) TYPE string,

      &quot;! Displays f4 help for packages using passed package id as search string and returns user selected value.
      &quot;! F4 help shows all packages from HANA repository AND all packages available in HOT that are not in HANA
      f4help_packages
        IMPORTING
          i_hana_package_name   TYPE cts_hot_package-hana_package_id
          i_include_subpackages TYPE abap_bool
        RETURNING
          VALUE(r_result)       TYPE cts_hot_package-hana_package_id
        RAISING
          cx_nhi_hana_repository
          cx_hana_object_transport,

      &quot;! Reads data from HANA repository and HOTA repository and stores them in mt_master and mt_slave. Also sets the sync status.
      select_data
        IMPORTING
          i_hana_package_name   TYPE cts_hot_package-hana_package_id
          i_include_subpackages TYPE abap_bool
        RAISING
          cx_nhi_hana_repository
          cx_hana_object_transport,

      &quot;! Filter packages/objects using the passed selection. Each importing parameter might contain &apos;X&apos;
      &quot;! for checkbox is checked (display) or not &apos;X&apos; for not checked (do not display)
      &quot;! @parameter i_green | if &apos;X&apos;, show green packages/objects, else do not show green packages/objects
      &quot;! @parameter i_yellow | if &apos;X&apos;, show yellow packages/objects, else do not show yellow packages/objects
      &quot;! @parameter i_red | if &apos;X&apos;, show red packages/objects, else do not show red packages/objects
      &quot;! @parameter i_inactive | if &apos;X&apos;, show inactive packages/objects, else do not show inactive packages/objects
      apply_filter
        IMPORTING
          i_green    TYPE c
          i_yellow   TYPE c
          i_red      TYPE c
          i_inactive TYPE c,

      &quot;! Returns filter data about which filter is active as well as how many objects / packages are there per status
      get_filter_data
        RETURNING VALUE(r_filter_data) TYPE ty_filter_data,

      is_data_filtered
        RETURNING
          VALUE(r_result) TYPE abap_bool,

      sync_data
        RETURNING VALUE(rv_trkorr) TYPE e070-trkorr,

      transport_order
        IMPORTING !iv_trkorr TYPE e070-trkorr,

      &quot;! Selects package and its objects for the package/object the cursor is currently placed in
      select_all_for_package,

      &quot;! Deselect package and its objects for the package/object the cursor is currently placed in
      deselect_all_for_package,

      preselect_all_out_of_sync,

      select_all,

      deselect_all,

      refresh_data,

      &quot;! Reads current selected cell (package or object) and displays versioning UI for this.
      show_versioning_for_currnt_cll,

      hide_name_columns,

      show_name_columns,

      deploy,

      set_deploy_mode,

      set_transl_mode.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ty_hana_package_id,
        hana_package_id TYPE cts_hot_package-hana_package_id,
      END OF ty_hana_package_id.
    TYPES: tt_cts_hot_hana_package_id TYPE STANDARD TABLE OF cts_hot_hana_package_id,
           ty_trkorrs_sorted          TYPE SORTED TABLE OF trkorr WITH UNIQUE KEY table_line.
    TYPES: BEGIN OF g_type_s_master.    &quot; package
    &quot; icon_led_green (in sync/ not deployed), icon_led_yellow (out of sync/deployable),
    &quot; icon_led_red (not syncable/not deployable) icon_led_inactive (not syncable/ not deployable)
    TYPES: sync_deploy_state            TYPE icon_d,
           &quot;! Transport Object name (HANA package in upper case or with hash)
           transport_obj_name           TYPE cts_hot_package_id,
           &quot;! package_id to display in ALV List. Either package id from HANA or if package only exists in HOTA, the package_id from HOTA. Important: This package_id must not be shown in details view!
           &quot;! This package_id is required to be able to have &amp;lt;unbekannt&amp;gt; for hana_package_id or hot_hana_package_id in details view.
           package_id                   TYPE cts_hot_hana_package_id,
           &quot;! Name of the hana package in HANA
           hana_package_id              TYPE cts_hot_hana_package_id,
           &quot;! name of hana package in HOTA repository that is already known for the transport_obj_name  or initial if it is equal to hana_package_id
           hot_hana_package_id          TYPE cts_hot_hana_package_id,
           &quot;! Devclass in tadir
           devclass                     TYPE tadir-devclass,
           &quot;! HANA package description in HANA
           hana_description             TYPE cts_hot_hana_pack_description,
           &quot;! HANA package description in HOTA
           hot_description              TYPE cts_hot_hana_pack_description,
           &quot;! HANA package src_system in HANA
           hana_src_system              TYPE cts_hot_pack_src_system,
           &quot;! HANA package src_system in HOTA
           hot_src_system               TYPE cts_hot_pack_src_system,
           &quot;! HANA package src_tenant in HANA
           hana_src_tenant              TYPE cts_hot_pack_src_tenant,
           &quot;! HANA package src_tenant in HOTA
           hot_src_tenant               TYPE cts_hot_pack_src_tenant,
           &quot;! HANA package responsible in HANA
           hana_responsible             TYPE cts_hot_pack_responsible,
           &quot;! HANA package responsible in HOTA
           hot_responsible              TYPE cts_hot_pack_responsible,
           &quot;! HANA package original language in HANA
           hana_original_language       TYPE cts_hot_hana_orig_lang,
           &quot;! HANA package original language in HOTA
           hot_original_language        TYPE cts_hot_hana_orig_lang,
           &quot;! HANA package is structural in HANA
           hana_is_structural           TYPE char40,  &quot;CTS_HOT_PACK_IS_STRUCTURAL not possible as it is number. char40 because max length of header text
           &quot;! HANA package is structural in HOTA
           hot_is_structural            TYPE char40,  &quot;CTS_HOT_PACK_IS_STRUCTURAL not possible as it is number. char40 because max length of header text
           &quot;! HANA package delivery unit in HANA
           hana_delivery_unit           TYPE cts_hot_pack_delivery_unit,
           &quot;! HANA package delivery unit in HOTA
           hot_delivery_unit            TYPE cts_hot_pack_delivery_unit,
           &quot;! HANA package delivery unit vendor in HANA
           hana_delivery_unit_vendor    TYPE cts_hot_pack_deliv_unit_vendor,
           &quot;! HANA package delivery unit vendor in HOTA
           hot_delivery_unit_vendor     TYPE cts_hot_pack_deliv_unit_vendor,
           &quot;! HANA package text collection in HANA
           hana_text_collection         TYPE cts_hot_pack_text_collection,
           &quot;! HANA package text collection in HOTA
           hot_text_collection          TYPE cts_hot_pack_text_collection,
           &quot;! HANA package text status in HANA
           hana_text_status             TYPE cts_hot_pack_text_status,
           &quot;! HANA package text status in HOTA
           hot_text_status              TYPE cts_hot_pack_text_status,
           &quot;! HANA package terminology domain in HANA
           hana_text_terminology_domain TYPE cts_hot_pack_text_term_domain,
           &quot;! HANA package terminology domain in HOTA
           hot_text_terminology_domain  TYPE cts_hot_pack_text_term_domain,
           &quot;! HANA package hints for translation in HANA
           hana_hints_for_translation   TYPE cts_hot_pack_hints_for_transl,
           &quot;! HANA package hints for translation in HOTA
           hot_hints_for_translation    TYPE cts_hot_pack_hints_for_transl,
           hana_read_system             TYPE cts_hot_hana_read_system,
           hot_abap_sync_system         TYPE cts_hot_abap_sync_system,
           hot_abap_synced_by           TYPE cts_hot_abap_synced_by,
           hot_abap_synced_at           TYPE char40, &quot;char40 because timestamp is in ms but we would like to see human readable data
           hot_abap_deployed_by         TYPE cts_hot_abap_deployed_by,
           hot_abap_deployed_at         TYPE char40, &quot;char40 because timestamp is in ms but we would like to see human readable data
           &quot;! R3trans UTC??? import timestamp in milli seconds
           abap_import_timestamp        TYPE char40,
           &quot;! Deploy mode, whether deployment should be done always or only if prework was done,...
           hot_deploy_mode              TYPE cts_hot_activation_mode,  &quot;technical for calculation only
           &quot;! Text for deploy mode for UI
           hot_deploy_mode_as_text      TYPE char100,
           &quot;! translation relevance, whether translation should be done or not
           abap_no_translation          TYPE cts_hot_abap_no_translation,
           &quot;! Text for translation relevance for UI
           abap_translation_as_text     TYPE char100,
           hot_status                   TYPE cts_hot_object_status, &quot;technical for calculation only
           hot_status_as_text           TYPE char70,
           cts_hot_package_ref          TYPE REF TO cl_cts_hot_package,
           exists_in_hana               TYPE abap_bool,
           exists_in_hota               TYPE abap_bool,
           masterlang                   TYPE sy-langu,
           t_color                      TYPE lvc_t_scol,
           END OF g_type_s_master.

    TYPES: BEGIN OF g_type_s_slave.   &quot;object
    TYPES: &quot;! hana package as transport object name, only needed to link objects in objects table (slave) to packages table (master)
      abap_hana_package_id       TYPE cts_hot_package_id,
      sync_deploy_state          TYPE icon_d,
      &quot;! Transport Object name (HANA package(40) + hana object name + &apos;.&apos; + hana object suffix(70) in upper case or with hash(es))
      transport_obj_name         TYPE cts_hot_object_name,
      &quot;! Name of the hana package in HANA
      hana_package_id            TYPE cts_hot_hana_package_id,
      &quot;! name of hana package in HOTA repository that is already known for the transport_obj_name or initial if it is equal to hana_package_id
      hot_hana_package_id        TYPE cts_hot_hana_package_id,
      &quot;! object_name to display in ALV List. Either object name from HANA or if object only exists in HOTA, the object name from HOTA. Important: This object_name must not be shown in details view!
      &quot;! This object_name is required to be able to have &amp;lt;unbekannt&amp;gt; for hana_object_name or hot_hana_object_name in details view.
      object_name                TYPE cts_hot_hana_object_name,
      &quot;! Name of the object in HANA
      hana_object_name           TYPE cts_hot_hana_object_name,
      &quot;! Name of the object in HOTA repository that is already known for the transport_obj_name or initial if it is equal to hana_object_name
      hot_hana_object_name       TYPE cts_hot_hana_object_name,
      &quot;! object_suffix to display in ALV List. Either object suffix from HANA or if object only exists in HOTA, the object suffix from HOTA. Important: This object_suffix must not be shown in details view!
      &quot;! This object_suffix is required to be able to have &amp;lt;unbekannt&amp;gt; for hana_object_suffix or hot_hana_object_suffix in details view.
      object_suffix              TYPE cts_hot_hana_object_suffix,
      &quot;! Suffix of the object in HANA
      hana_object_suffix         TYPE cts_hot_hana_object_suffix,
      &quot;! Suffix of the object in HOTA repository that is already known for the transport_obj_name or initial if it is equal to hana_object_suffix
      hot_hana_object_suffix     TYPE cts_hot_hana_object_suffix,
      &quot;! Status of the object in HANA (OK, BROKEN; NEEDS_REGEN)
      hana_object_status         TYPE icon_d,
      hana_source_object_version TYPE cts_hot_hana_src_obj_version,
      hana_version               TYPE char40, &quot;cts_hot_hana_object_version not possible due to assign &amp;lt;unbekannt&amp;gt; to this entry in some cases
      hot_version                TYPE char40, &quot;cts_hot_hana_object_version not possible due to assign &amp;lt;unbekannt&amp;gt; to this entry in some cases
      hana_activated_by          TYPE cts_hot_hana_activated_by,
      hot_activated_by           TYPE cts_hot_hana_activated_by,
      hana_activated_at          TYPE char40, &quot;string not working for manually setting column length, char40 because max length of header text
      hot_activated_at           TYPE char40, &quot;string not working for manually setting column length, char40 because max length of header text
      hana_hana_read_system      TYPE cts_hot_hana_read_system,
      hot_hana_read_system       TYPE cts_hot_hana_read_system,
      hot_abap_sync_system       TYPE cts_hot_abap_sync_system,
      hot_abap_synced_by         TYPE cts_hot_abap_synced_by,
      hot_abap_synced_at         TYPE char40, &quot;string not working for manually setting column length, char40 because max length of header text
      hot_abap_deployed_by       TYPE cts_hot_abap_deployed_by,
      hot_abap_deployed_at       TYPE string,
      abap_import_timestamp      TYPE char40,
      hot_status                 TYPE cts_hot_object_status, &quot;technical for calculation only
      hot_status_as_text         TYPE char70,
      cts_hot_object_ref         TYPE REF TO cl_cts_hot_object_v1,
      exists_in_hana             TYPE abap_bool,
      abap_object_reference      TYPE lxeobjname, &quot;name of translation object
      exists_in_hota             TYPE abap_bool,
      t_color                    TYPE lvc_t_scol,
      END OF g_type_s_slave.

    DATA: mt_master                      TYPE STANDARD TABLE OF g_type_s_master WITH UNIQUE HASHED KEY pack_ref COMPONENTS cts_hot_package_ref,
          mt_slave                       TYPE STANDARD TABLE OF g_type_s_slave WITH UNIQUE HASHED KEY obj_ref COMPONENTS cts_hot_object_ref,
          mr_hierseq                     TYPE REF TO cl_salv_hierseq_table,
          mv_max_length_package_id       TYPE lvc_outlen, &quot;needed to reduce output length from 256 to maximum used length of current dataset
          mv_max_length_devclass         TYPE lvc_outlen,
          mv_max_length_pack_desc        TYPE lvc_outlen,
          mv_max_length_pack_src_system  TYPE lvc_outlen,
          mv_max_length_pack_src_tenant  TYPE lvc_outlen,
          mv_max_length_pack_responsible TYPE lvc_outlen,
          mv_max_length_pack_du_name     TYPE lvc_outlen,
          mv_max_length_pack_du_vendor   TYPE lvc_outlen,
          mv_max_length_pack_text_coll   TYPE lvc_outlen,
          mv_max_length_pack_text_status TYPE lvc_outlen,
          mv_max_length_pack_text_domain TYPE lvc_outlen,
          mv_max_length_pack_hint        TYPE lvc_outlen,
          mv_max_length_object_name      TYPE lvc_outlen,
          mv_max_length_object_suffix    TYPE lvc_outlen,
          mv_any_object_not_ok_in_hana   TYPE abap_bool,
          mr_data_provider               TYPE REF TO lif_data_provider,
          mr_hot_hana_connector          TYPE REF TO if_cts_hot_hana_conn_internal,
          mr_external_calls              TYPE REF TO if_cts_hot_ext_call_internal,
          mv_system_timezone             TYPE timezone,
          &quot;! Filter data, current used filter and number of packages/objects by status
          ms_filter_data                 TYPE ty_filter_data,
          &quot;! All packages found for user input string. Currently it will be only filled and use in apply_filter
          mt_master_all                  LIKE mt_master,
          &quot;! All objects found for user input string. Currently it will be only filled and use in apply_filter.
          mt_slave_all                   LIKE mt_slave.

    METHODS:
      &quot;! select objects from hana of all packages in mt_master into global output table mt_slaves
      read_object_data_from_hana
        RAISING
          cx_nhi_hana_repository
          cx_hana_object_transport ,

      &quot;! select objects from hot of all packages in mt_master into global table mt_slaves
      &quot;! Before all objects were read from HANA so that global table usually contain already values.
      read_object_data_from_hot
        RAISING
          cx_hana_object_transport,

      &quot;! Calculates the sync_status icon.
      calculate_sync_status,

      &quot;! Calculates the depl_status icon.
      calculate_depl_status,

      &quot;! Mark the difference in the ALV list for packages.
      mark_difference_package EXPORTING ev_master TYPE any,

      &quot;! Mark the difference in the ALV list for objects.
      mark_difference_object EXPORTING ev_slave TYPE any,

      &quot;! Calculates the numbers of packages/objects per status
      calc_number_pkg_obj,

      &quot;! Searches all packages in HANA and HOT repository and returns them for each repository. So both e_xx_packages might contain exact same data.
      &quot;!
      &quot;! @parameter i_hana_package_name |
      &quot;! @parameter i_include_subpackages |
      &quot;! @parameter e_hana_packages | packages found in HANA for the i_hana_package_name (exact case)
      &quot;! @parameter e_hot_packages | packages found in HOT for the i_hana_package_name (exact case)
      &quot;! @raising cx_hana_object_transport |
      search_packges_in_hana_and_hot
        IMPORTING
          i_hana_package_name   TYPE cts_hot_package-hana_package_id
          i_include_subpackages TYPE abap_bool
        EXPORTING
          e_hana_packages       TYPE tt_cts_hot_hana_package_id
          e_hot_packages        TYPE tt_cts_hot_hana_package_id
        RAISING
          cx_hana_object_transport,

      &quot;! Returns the selected data from UI
      &quot;!
      &quot;! @parameter i_check_deletion_consistency | flag whether to check or not to check for deletion consistency
      &quot;!                                           (if package should be deleted, show error if not all objects are also selected)
      &quot;! @parameter e_hotp_packages | selected packages for which NOT all objects are selected
      &quot;! @parameter e_hota_packages | selected packages for which also all objects are selected
      &quot;! @parameter e_hoto_objects | objects that are selected individually (not together with all other objects of a package as HOTA)
      &quot;! @parameter e_hota_objects | objects that are selected as part of a selection of all objects of a package
      &quot;! @raising cx_hana_object_transport |
      get_selected_data
        IMPORTING
          i_check_deletion_consistency TYPE abap_bool DEFAULT abap_false
        EXPORTING
          e_hotp_packages              TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          e_hota_packages              TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          e_hoto_objects               TYPE cl_cts_hot_object_v1=&gt;ty_cl_cts_hot_object_list
          e_hota_objects               TYPE cl_cts_hot_object_v1=&gt;ty_cl_cts_hot_object_list
        RAISING
          cx_hana_object_transport,
      add_to_transport_request
        IMPORTING
          i_hotp_packages TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          i_hota_packages TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          i_hoto_objects  TYPE cl_cts_hot_object_v1=&gt;ty_cl_cts_hot_object_list
        RETURNING
          VALUE(r_result) TYPE ty_trkorrs_sorted,

      &quot;! Adds the passed object in i_obj_name to TR or new TR if TR is not specified
      &quot;!
      &quot;! @parameter i_pgmid | R3TR or LIMU
      &quot;! @parameter i_obj_type | HOTA or HOTP or HOTO
      &quot;! @parameter i_obj_name | Object name for TR
      &quot;! @parameter i_transport_request |
      &quot;! @parameter i_is_deletion |
      &quot;! @parameter r_result |
      add_to_tr
        IMPORTING
          i_pgmid             TYPE pgmid
          i_obj_type          TYPE trobjtype
          i_obj_name          TYPE cts_hot_object_name
          i_transport_request TYPE trkorr
          i_is_deletion       TYPE abap_bool
        RETURNING
          VALUE(r_result)     TYPE trkorr,

      &quot;! Reads package attributes from hana of all packages in mt_master into global output table mt_master
      read_package_data_from_hana
        RAISING
          cx_nhi_hana_repository
          cx_hana_object_transport,

      &quot;! Reads package attributes from hot of all packages in mt_master into global output table mt_master
      read_package_data_from_hot,

      create_local_time_string
        IMPORTING
          i_timestamp_utc     TYPE timestampl
        RETURNING
          VALUE(r_local_time) TYPE string,

      conv_hana_actvted_at_to_timest
        IMPORTING
          i_activated_at  TYPE string
        RETURNING
          VALUE(r_timest) TYPE timestampl,
      read_tadir_for_packages,

      &quot;! ALV does not show data that has a &apos;space&apos;, therefore write meaningfull data if either HANA or HOTA has data
      &quot;! Also calculate gv_max_length for some columns
      replace_spaces_for_display,

      &quot;! Sets output length of passed column to at least i_min_length or i_max_length if i_max_length &amp;gt; i_min_length
      set_column_length
        IMPORTING
          i_column     TYPE REF TO cl_salv_column_hierseq
          i_min_length TYPE lvc_outlen
          i_max_length TYPE lvc_outlen,

      find_package_with_diffrnt_case
        IMPORTING
          i_hot_hana_package_id    TYPE string
        RETURNING
          VALUE(r_hana_package_id) TYPE string
        RAISING
          cx_nhi_hana_repository,

      &quot;! Marks the passed columns as color columns in ch_color_table
      &quot;! @parameter i_name1 | Name of column1 (HANA column or general column)
      &quot;! @parameter i_name2 | Name of column2 (HOTA column)
      &quot;! @parameter ch_color_table |
      append_change_color
        IMPORTING
          i_name1        TYPE string
          i_name2        TYPE string OPTIONAL
        CHANGING
          ch_color_table TYPE lvc_t_scol,

      &quot;! Adds or updates the passed HANA objects to/in mt_slave
      append_hana_objcts_to_mt_slave
        IMPORTING
          i_master        TYPE REF TO g_type_s_master
          i_hana_objects  TYPE cl_nhi_object_id_and_caption=&gt;ty_objlist_caption
          i_object_status TYPE icon_d
        RAISING
          cx_hana_object_transport,

      &quot;! Do column settings for columns and their layout that is based on content
      handle_dynamic_columns,

      &quot;! Helper method to set max value on gv_xxx_length variables.
      &quot;! Calculates length of i_text and if longer than c_length, c_length is updated to this value
      &quot;! @parameter i_text | text to calculate length from
      &quot;! @parameter c_length | current length to be changed if strlen( i_text ) &amp;gt; c_length
      set_max_length
        IMPORTING
          i_text   TYPE lcl_hota_organizer=&gt;g_type_s_slave-hana_object_name
        CHANGING
          c_length TYPE lvc_outlen,

      &quot;! First appending the packages of i_package_names_hana to mt_master.
      &quot;! Then for packages in i_package_names_hot either modify existing entries in mt_master
      &quot;! (same key on transport_obj_name) or append as well.
      append_packages_to_mt_master
        IMPORTING
          i_package_names_hana TYPE tt_cts_hot_hana_package_id
          i_package_names_hot  TYPE tt_cts_hot_hana_package_id
        RAISING
          cx_hana_object_transport,

      &quot;! Loops over mt_master to check whether the packages that do exist only in either HANA or HOTA
      &quot;! do exist in different case in the other repository
      check_packgs_for_diffrnt_cases
        RAISING
          cx_nhi_hana_repository,

      set_tooltips,

      &quot;! Sets the long text for the column with the specified template (&amp;1 in HANA or &amp;1 in HOTA)
      set_column_long_text
        IMPORTING
          i_text_template TYPE string
          i_column        TYPE REF TO cl_salv_column_hierseq,

      build_header
        CHANGING
          cr_content TYPE REF TO cl_salv_form_element,

      &quot;! Set master language for all objects/packages in the mt_master table (language is an attribute on package/tadir level)&lt;br/&gt;
      &quot;! If setting language fails because of unknown language code on HANA side or there is no language maintained on HANA and user
      &quot;! decides to cancel, an error system message is shown which leads to complete cancel of current action. (e.g. sync)
      set_masterlang_in_mt_master
        IMPORTING
          i_hota_packages TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          i_hotp_packages TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          i_hoto_objects  TYPE cl_cts_hot_object_v1=&gt;ty_cl_cts_hot_object_list,

      &quot;! Checks all passed objects with tr_object_check. If any problem occurs or user does cancel, complete sync will be canceled. All actions done
      &quot;! until then remain (but this might be only add task to existing request).
      &quot;! @parameter i_hota_packages |
      &quot;! @parameter i_hotp_packages |
      &quot;! @parameter i_hoto_objects |
      &quot;! @parameter e_used_trkorrs | all different trkorrs returned by tr_object_check
      check_objects
        IMPORTING
          i_hota_packages TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          i_hotp_packages TYPE cl_cts_hot_package=&gt;ty_cl_cts_hot_package_list
          i_hoto_objects  TYPE cl_cts_hot_object_v1=&gt;ty_cl_cts_hot_object_list
        RETURNING
          VALUE(r_result) TYPE ty_trkorrs_sorted,

      &quot;! Checks passed object with rs_corr_check. If any problem occurs or user does cancel, complete sync will be canceled. All actions done
      &quot;! until then remain (but this might be only add task to existing request).
      &quot;! @parameter i_pgmid |
      &quot;! @parameter i_obj_type |
      &quot;! @parameter i_obj_name |
      &quot;! @parameter r_result | trkorr used if object was already locked on any request, otherwise initial.
      check_object
        IMPORTING
          i_pgmid         TYPE pgmid
          i_obj_type      TYPE trobjtype
          i_obj_name      TYPE cts_hot_object_name
        RETURNING
          VALUE(r_result) TYPE trkorr,

      &quot;! Checks passed object with tr_object_check for LANG object. If any problem occurs or user does cancel, complete sync will be canceled. All actions done
      &quot;! until then remain (but this might be only add task to existing request).
      &quot;! @parameter i_pgmid |
      &quot;! @parameter i_obj_type |
      &quot;! @parameter i_obj_name |
      &quot;! @parameter r_result | trkorr used if object was already locked on any request, otherwise initial.
      check_langu_object
        IMPORTING
          i_obj_type      TYPE trobjtype
          i_obj_name      TYPE cts_hot_object_name
          i_masterlang    TYPE spras
        RETURNING
          VALUE(r_result) TYPE trkorr,

      &quot;! Adds the passed object in i_obj_name as LANG object to TR or new TR if TR is not specified
      &quot;!
      &quot;! @parameter i_obj_type | HOTA or HOTP or HOTO
      &quot;! @parameter i_obj_name | Object name for TR
      &quot;! @parameter i_masterlang | language for the object
      &quot;! @parameter i_transport_request |
      &quot;! @parameter r_result |
      add_langu_to_tr
        IMPORTING
          i_obj_type          TYPE trobjtype
          i_obj_name          TYPE cts_hot_object_name
          i_masterlang        TYPE spras
          i_transport_request TYPE trkorr
        RETURNING
          VALUE(r_result)     TYPE trkorr,

      &quot;! Checks whether TP and R3trans are up to date with regards to required HOTA functionality.
      check_transport_tools.

ENDCLASS.

*---------------------------------------------------------------------*
*       CLASS lcl_handle_events DEFINITION
*---------------------------------------------------------------------*
* local class for handling events of cl_salv_table
*---------------------------------------------------------------------*
CLASS lcl_handle_events DEFINITION.
  PUBLIC SECTION.
    METHODS:
      constructor
        IMPORTING
          i_hot_organizer TYPE REF TO lcl_hota_organizer,

      on_before_salv_function FOR EVENT before_salv_function OF cl_salv_events
        IMPORTING
            e_salv_function,

      on_after_salv_function FOR EVENT after_salv_function OF cl_salv_events
        IMPORTING
            e_salv_function,

      on_user_command FOR EVENT added_function OF cl_salv_events
        IMPORTING
            e_salv_function.

  PRIVATE SECTION.
    DATA: gr_hot_organizer  TYPE REF TO lcl_hota_organizer.
ENDCLASS.                    &quot;lcl_handle_events DEFINITION

*---------------------------------------------------------------------*
*       CLASS lcl_handle_events IMPLEMENTATION
*---------------------------------------------------------------------*
* implement the events for handling the events of cl_salv_table
*---------------------------------------------------------------------*
CLASS lcl_handle_events IMPLEMENTATION.
  METHOD on_user_command.
    CASE e_salv_function.
      WHEN &apos;SELECT_ALL&apos; OR &apos;SEL_ALL_D&apos;.
        gr_hot_organizer-&gt;select_all( ).
      WHEN &apos;DESEL_ALL&apos; OR &apos;DES_ALL_D&apos;.
        gr_hot_organizer-&gt;deselect_all( ).
      WHEN &apos;SEL_SYNC&apos; OR &apos;SEL_DEPL&apos;.
        gr_hot_organizer-&gt;preselect_all_out_of_sync( ).
      WHEN &apos;SYNC&apos;.
        gr_hot_organizer-&gt;transport_order( gr_hot_organizer-&gt;sync_data( ) ).
      WHEN &apos;DEPL&apos;.
        gr_hot_organizer-&gt;deploy( ).
      WHEN &apos;SEL_PACK&apos;.
        gr_hot_organizer-&gt;select_all_for_package( ).
      WHEN &apos;DESEL_PACK&apos;.
        gr_hot_organizer-&gt;deselect_all_for_package( ).
      WHEN &apos;REFRESH&apos;.
        gr_hot_organizer-&gt;refresh_data( ).
      WHEN &apos;VERS&apos;.
        gr_hot_organizer-&gt;show_versioning_for_currnt_cll( ).
      WHEN &apos;SE09&apos;.
        TRY.
            CALL TRANSACTION &apos;SE09&apos; WITH AUTHORITY-CHECK.
          CATCH cx_sy_authorization_error.
            DATA text TYPE string.
            text = &apos;No authorization for Transport Organizer (SE09)&apos;(165).
            MESSAGE text TYPE &apos;E&apos;.
        ENDTRY.
      WHEN &apos;INFO&apos;.
        IF gv_sync = &apos;X&apos;.
          CALL FUNCTION &apos;DSYS_SHOW_FOR_F1HELP&apos;
            EXPORTING
              dokclass = &apos;TX&apos; &quot; allgemeiner Text - SE61
              dokname  = &apos;CTS_HOTA_SYNC_UI_ALV_DOCU&apos;
*             short_text = &apos;X&apos;
            EXCEPTIONS
              OTHERS   = 1.
        ELSEIF gv_depl = &apos;X&apos;.
          CALL FUNCTION &apos;DSYS_SHOW_FOR_F1HELP&apos;
            EXPORTING
              dokclass = &apos;TX&apos; &quot; allgemeiner Text - SE61
              dokname  = &apos;CTS_HOTA_DEPL_UI_ALV_DOCU&apos;
*             short_text = &apos;X&apos;
            EXCEPTIONS
              OTHERS   = 1.
        ENDIF.
        IF sy-subrc &lt;&gt; 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      WHEN &apos;SETDEPMODE&apos;.
        gr_hot_organizer-&gt;set_deploy_mode( ).
      WHEN &apos;TRANSLMODE&apos;.
        gr_hot_organizer-&gt;set_transl_mode( ).
      WHEN &apos;LEGEND&apos;.
        IF gv_sync = &apos;X&apos;.
          CALL FUNCTION &apos;DSYS_SHOW_FOR_F1HELP&apos;
            EXPORTING
              dokclass = &apos;TX&apos; &quot; allgemeiner Text - SE61
              dokname  = &apos;CTS_HTA_SYNC_UI_LEGEND&apos;
*             short_text = &apos;X&apos;
            EXCEPTIONS
              OTHERS   = 1.
          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ELSEIF gv_depl = &apos;X&apos;.
          CALL FUNCTION &apos;DSYS_SHOW_FOR_F1HELP&apos;
            EXPORTING
              dokclass = &apos;TX&apos; &quot; allgemeiner Text - SE61
              dokname  = &apos;CTS_HTA_DEPL_UI_LEGEND&apos;
*             short_text = &apos;X&apos;
            EXCEPTIONS
              OTHERS   = 1.
          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.
      WHEN &apos;DEPLOY&apos;.
        MESSAGE &apos;To deploy SAP HANA packages and objects, use transaction SCTS_HTA_DEPLOY&apos;(235) TYPE &apos;I&apos;.
      WHEN &apos;FILTER&apos;.
        CALL SCREEN 2000 STARTING AT 40 9.
      WHEN &apos;SYNC_T&apos;.
        CALL TRANSACTION &apos;SCTS_HTA&apos; WITH AUTHORITY-CHECK.
      WHEN &apos;DEPL_T&apos;.
        CALL TRANSACTION &apos;SCTS_HTA_DEPLOY&apos; WITH AUTHORITY-CHECK.
    ENDCASE.
  ENDMETHOD.                    &quot;on_user_command

  METHOD constructor.
    gr_hot_organizer = i_hot_organizer.
  ENDMETHOD.


  METHOD on_before_salv_function.
    IF e_salv_function = &apos;&amp;ETA&apos;.
      gr_hot_organizer-&gt;hide_name_columns( ).
    ENDIF.
  ENDMETHOD.

  METHOD on_after_salv_function.
    CASE e_salv_function.
      WHEN &apos;&amp;ETA&apos;.
        gr_hot_organizer-&gt;show_name_columns( ).
      WHEN &apos;&amp;OL0&apos; OR &apos;&amp;OAD&apos;  OR &apos;&amp;AVE&apos;.
        gr_hot_organizer-&gt;preselect_all_out_of_sync( ).
    ENDCASE.
  ENDMETHOD.

ENDCLASS.                    &quot;lcl_handle_events IMPLEMENTATION

CLASS lcl_hota_organizer IMPLEMENTATION.

  METHOD f4help_packages.
    DATA:
      lt_package_names_hot_and_hana  TYPE tt_cts_hot_hana_package_id, &quot;will contain all names from HANA and HOT with given name
      ls_package_name_in_hot_and_han LIKE LINE OF lt_package_names_hot_and_hana,
      lt_package_names_out           TYPE STANDARD TABLE OF ddshretval WITH EMPTY KEY,
      ls_package_name                LIKE LINE OF lt_package_names_out,
      lt_package_names_in            TYPE STANDARD TABLE OF ty_hana_package_id,
      ls_f4help_wa                   TYPE ty_hana_package_id.

    search_packges_in_hana_and_hot(
      EXPORTING
        i_hana_package_name = i_hana_package_name
        i_include_subpackages = i_include_subpackages
      IMPORTING
        e_hana_packages = lt_package_names_hot_and_hana
        e_hot_packages  = DATA(lt_package_names_hot)
    ).

    INSERT LINES OF lt_package_names_hot INTO TABLE lt_package_names_hot_and_hana.
    SORT lt_package_names_hot_and_hana.
    DELETE ADJACENT DUPLICATES FROM lt_package_names_hot_and_hana.

    &quot; add all HANA and HOT packages to F4 help input table
    LOOP AT lt_package_names_hot_and_hana INTO ls_package_name_in_hot_and_han.
      ls_f4help_wa-hana_package_id = ls_package_name_in_hot_and_han.
      APPEND ls_f4help_wa TO lt_package_names_in.
    ENDLOOP.

    &quot;show f4 help and get user selected value
    CALL FUNCTION &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
      EXPORTING
        retfield        = &apos;HANA_PACKAGE_ID&apos;
        value_org       = &apos;S&apos; &quot; Structure
      TABLES
        value_tab       = lt_package_names_in &quot; F4 help values
        return_tab      = lt_package_names_out &quot; F4 selected values
      EXCEPTIONS
        parameter_error = 1
        no_values_found = 2
        OTHERS          = 3.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ELSE.
      READ TABLE lt_package_names_out INDEX 1 INTO ls_package_name.
      r_result = ls_package_name-fieldval.
    ENDIF.

  ENDMETHOD.

  METHOD read_user_value.
    DATA: dynpfield  TYPE dynpread,
          dynpfields TYPE STANDARD TABLE OF dynpread.

    IF i_param_name IS NOT INITIAL.
      dynpfield-fieldname = i_param_name.
      APPEND dynpfield TO dynpfields.
    ENDIF.

    CALL FUNCTION &apos;DYNP_VALUES_READ&apos;
      EXPORTING
        dyname               = sy-repid
        dynumb               = sy-dynnr
        translate_to_upper   = &apos; &apos;
      TABLES
        dynpfields           = dynpfields
      EXCEPTIONS
        invalid_abapworkarea = 1
        invalid_dynprofield  = 2
        invalid_dynproname   = 3
        invalid_dynpronummer = 4
        invalid_request      = 5
        no_fielddescription  = 6
        invalid_parameter    = 7
        undefind_error       = 8
        double_conversion    = 9
        stepl_not_found      = 10
        OTHERS               = 11.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ELSE.
      READ TABLE dynpfields WITH KEY fieldname = i_param_name INTO dynpfield.
      IF sy-subrc = 0.
        r_result = dynpfield-fieldvalue.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD select_data.
    FREE: mt_master, mt_slave, mt_master_all, mt_slave_all, ms_filter_data.
    ms_filter_data-show_green = abap_true.
    ms_filter_data-show_yellow = abap_true.
    ms_filter_data-show_red = abap_true.
    ms_filter_data-show_inactive = abap_true.

    &quot;Store search string and subpackage selection to print to top of list
    mv_search_string = i_hana_package_name.
    mv_include_subpackages = i_include_subpackages.

* 1. Prepare mt_master by reading all packages from HANA and HOTA that match user input string, also check for different cases if it exists only in 1 repository

    &quot;can be called for multi packages with * like mypackage*
    search_packges_in_hana_and_hot( EXPORTING i_hana_package_name = i_hana_package_name
                                              i_include_subpackages = i_include_subpackages
                                    IMPORTING e_hana_packages     = DATA(lt_package_names_hana)
                                              e_hot_packages      = DATA(lt_package_names_hot) ).

    append_packages_to_mt_master( i_package_names_hana = lt_package_names_hana i_package_names_hot = lt_package_names_hot ).

    check_packgs_for_diffrnt_cases( ).

* 2. Read package, tadir and object details from HANA, HOTA and tadir
    read_package_data_from_hana( ).

    read_package_data_from_hot( ).

    read_tadir_for_packages( ).

    read_object_data_from_hana( ).

    read_object_data_from_hot( ).

* 3. Set all unknown(initial) data to &lt;unknown&gt; because initial values are not shown in details view in ALV
    replace_spaces_for_display( ).

* 4. Calculate the sync/depl status for packages and objects
    IF gv_sync = &apos;X&apos;.
      calculate_sync_status( ).
    ELSEIF gv_depl = &apos;X&apos;.
      calculate_depl_status( ).
    ENDIF.

    calc_number_pkg_obj(  ).
  ENDMETHOD.

  METHOD calc_number_pkg_obj.
    DATA: lt_master TYPE STANDARD TABLE OF g_type_s_master,
          lt_slave  TYPE STANDARD TABLE OF g_type_s_slave.

    LOOP AT mt_master REFERENCE INTO DATA(lr_master) GROUP BY ( sync_deploy_state = lr_master-&gt;sync_deploy_state lv_count = GROUP SIZE )
                                                        WITHOUT MEMBERS REFERENCE INTO DATA(lr_master_group).
      CASE lr_master_group-&gt;sync_deploy_state.
        WHEN icon_led_green.
          ms_filter_data-nr_packages_green = lr_master_group-&gt;lv_count.
        WHEN icon_led_yellow.
          ms_filter_data-nr_packages_yellow = lr_master_group-&gt;lv_count.
        WHEN icon_led_red.
          ms_filter_data-nr_packages_red = lr_master_group-&gt;lv_count.
        WHEN icon_led_inactive.
          ms_filter_data-nr_packages_inactive = lr_master_group-&gt;lv_count.
        WHEN OTHERS.
          &quot;todo: OK to use assert in this case and how to use assert?
          ASSERT 0 = 0. &quot;new state not implemented...
      ENDCASE.
    ENDLOOP.

    LOOP AT mt_slave REFERENCE INTO DATA(lr_slave) GROUP BY ( sync_deploy_state = lr_slave-&gt;sync_deploy_state lv_count = GROUP SIZE )
                                                        WITHOUT MEMBERS REFERENCE INTO DATA(lr_slave_group).
      CASE lr_slave_group-&gt;sync_deploy_state.
        WHEN icon_led_green.
          ms_filter_data-nr_objects_green = lr_slave_group-&gt;lv_count.
        WHEN icon_led_yellow.
          ms_filter_data-nr_objects_yellow = lr_slave_group-&gt;lv_count.
        WHEN icon_led_red.
          ms_filter_data-nr_objects_red = lr_slave_group-&gt;lv_count.
        WHEN icon_led_inactive.
          ms_filter_data-nr_objects_inactive = lr_slave_group-&gt;lv_count.
        WHEN OTHERS.
          &quot;todo: OK to use assert in this case and how to use assert?
          ASSERT 0 = 0. &quot;new state not implemented...
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD apply_filter.
    DATA: lr_content TYPE REF TO cl_salv_form_element.

    &quot;Only filter if filter has changed?
    IF i_green = ms_filter_data-show_green
          AND i_yellow = ms_filter_data-show_yellow
          AND i_red = ms_filter_data-show_red
          AND i_inactive = ms_filter_data-show_inactive.
      RETURN.
    ENDIF.

    TRY.
        ms_filter_data-show_green = i_green.
        ms_filter_data-show_yellow = i_yellow.
        ms_filter_data-show_red = i_red.
        ms_filter_data-show_inactive = i_inactive.

        &quot; if not yet filtered, remember all packages / objects. If filter is used 2nd time,
        &quot; get all packages / objects back  into mt_master and mt_slave and filter again.
        IF mt_master_all IS INITIAL.
          mt_master_all = mt_master.
        ELSE.
          mt_master = mt_master_all.
        ENDIF.

        IF mt_slave_all IS INITIAL.
          mt_slave_all = mt_slave.
        ELSE.
          mt_slave = mt_slave_all.
        ENDIF.

* 1. delete all objects that should not be shown
        IF ms_filter_data-show_green = abap_false.
          DELETE mt_slave WHERE sync_deploy_state = icon_led_green.
        ENDIF.
        IF  ms_filter_data-show_yellow = abap_false.
          DELETE mt_slave WHERE sync_deploy_state = icon_led_yellow.
        ENDIF.
        IF  ms_filter_data-show_red = abap_false.
          DELETE mt_slave WHERE sync_deploy_state = icon_led_red.
        ENDIF.
        IF  ms_filter_data-show_inactive = abap_false.
          DELETE mt_slave WHERE sync_deploy_state = icon_led_inactive.
        ENDIF.

* 2. delete all packages that should not be shown, BUT only if there is no object to be shown for this package
*    Else the object will not be shown as it requires the package to be shown!
        LOOP AT mt_master REFERENCE INTO DATA(lr_master).
          IF ( ( ms_filter_data-show_green = abap_false AND lr_master-&gt;sync_deploy_state = icon_led_green )
                OR ( ms_filter_data-show_yellow = abap_false AND lr_master-&gt;sync_deploy_state = icon_led_yellow )
                OR ( ms_filter_data-show_red = abap_false AND lr_master-&gt;sync_deploy_state = icon_led_red )
                OR ( ms_filter_data-show_inactive = abap_false AND lr_master-&gt;sync_deploy_state = icon_led_inactive )
             ) AND NOT line_exists( mt_slave[ abap_hana_package_id = lr_master-&gt;transport_obj_name ] ).
            DELETE mt_master. &quot;delete current table line
          ENDIF.
        ENDLOOP.

        preselect_all_out_of_sync( ).

*       in case number of packages/objects has been changed, top of list has to be changed as well
        build_header( CHANGING cr_content = lr_content ).
        mr_hierseq-&gt;set_top_of_list( lr_content ).

*... refresh the table in order to see the new data
*        mr_hierseq-&gt;refresh( ). &quot;with refresh there are scrolling issues...
      CATCH cx_hana_object_transport INTO DATA(hot_exc).
        DATA(t100_key) = hot_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH hot_exc-&gt;msgv1 hot_exc-&gt;msgv2 hot_exc-&gt;hana_error_code hot_exc-&gt;hana_error_msg.
      CATCH cx_nhi_hana_repository INTO DATA(nhi_exc).
        t100_key = nhi_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4.
    ENDTRY.
  ENDMETHOD.

  METHOD display_data.
    DATA:
      lt_binding      TYPE salv_t_hierseq_binding,
      ls_binding      TYPE salv_s_hierseq_binding,
      lr_functions    TYPE REF TO cl_salv_functions_list,
      lr_columns      TYPE REF TO cl_salv_columns_hierseq,
      lr_column       TYPE REF TO cl_salv_column_hierseq,
      lr_layout       TYPE REF TO cl_salv_layout,
      lr_events       TYPE REF TO cl_salv_events_hierseq,
      ls_layout_key   TYPE salv_s_layout_key,
      lv_text_in_hana TYPE string,
      lv_text_in_hota TYPE string,
      lv_title        TYPE lvc_title,
      lr_content      TYPE REF TO cl_salv_form_element.

*    lv_text_in_sap_hana = &apos;&amp;1 in SAP HANA&apos;(106).
    lv_text_in_hana = &apos;&amp;1 in HANA&apos;(101).
    lv_text_in_hota = &apos;&amp;1 in ABAP&apos;(102).

*... create the binding information between master and slave
    ls_binding-master = &apos;TRANSPORT_OBJ_NAME&apos;.
    ls_binding-slave  = &apos;ABAP_HANA_PACKAGE_ID&apos;.
    APPEND ls_binding TO lt_binding.

*... create an ALV hierseq table
    TRY.
        cl_salv_hierseq_table=&gt;factory(
          EXPORTING
            t_binding_level1_level2 = lt_binding
          IMPORTING
            r_hierseq               = mr_hierseq
          CHANGING
            t_table_level1           = mt_master
            t_table_level2           = mt_slave ).

        IF gv_sync = &apos;X&apos;.
          mr_hierseq-&gt;set_screen_status(
            pfstatus   =  &apos;HOTA_SYNC&apos;
            report     =  sy-repid ).
          lv_title = &apos;SAP HANA Transport for ABAP - Synchronisation&apos;(004).
        ELSEIF gv_depl = &apos;X&apos;.
          mr_hierseq-&gt;set_screen_status(
            pfstatus   =  &apos;HOTA_DEPL&apos;
            report     =  sy-repid ).
          lv_title = &apos;SAP HANA Transport for ABAP - Deployment&apos;(229).
        ENDIF.
        mr_hierseq-&gt;get_display_settings( )-&gt;set_list_header( lv_title ).

        build_header( CHANGING cr_content = lr_content ).
        mr_hierseq-&gt;set_top_of_list( lr_content ).

      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
      CATCH cx_salv_data_error INTO DATA(exc1).
        ls_msg = exc1-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*... §3.1 activate ALV generic Functions
    lr_functions = mr_hierseq-&gt;get_functions( ).
*      lr_functions-&gt;set_all( abap_true ).
*      lr_functions-&gt;set_default( ).
    lr_functions-&gt;set_detail( if_salv_c_bool_sap=&gt;true ).
*      lr_functions-&gt;set_filter( if_salv_c_bool_sap=&gt;true ).
    lr_functions-&gt;set_layout_change( if_salv_c_bool_sap=&gt;true ).
    lr_functions-&gt;set_layout_load( if_salv_c_bool_sap=&gt;true ).
    lr_functions-&gt;set_layout_save( if_salv_c_bool_sap=&gt;true ).
*      lr_functions-&gt;set_sort_asc( if_salv_c_bool_sap=&gt;true ).
*      lr_functions-&gt;set_sort_desc( if_salv_c_bool_sap=&gt;true ).
    lr_functions-&gt;set_find( if_salv_c_bool_sap=&gt;true ).
*    lr_functions-&gt;set_group_layout( if_salv_c_bool_sap=&gt;true ).


*... set tooltips
    set_tooltips( ).

*enable selections
    TRY.
*... set selection mode for both levels to single
        mr_hierseq-&gt;get_selections( 1 )-&gt;set_selection_mode( if_salv_c_selection_mode=&gt;single ).
        mr_hierseq-&gt;get_selections( 2 )-&gt;set_selection_mode( if_salv_c_selection_mode=&gt;single ).
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*handle master columns
    TRY.
        lr_columns = mr_hierseq-&gt;get_columns( 1 ).

        TRY.
            lr_columns-&gt;set_color_column( &apos;T_COLOR&apos; ).
          CATCH cx_salv_data_error.                     &quot;#EC NO_HANDLER
        ENDTRY.

*... optimze the columns
*          lr_columns-&gt;set_optimize( abap_true ).

*... hide technical columns
        lr_column ?= lr_columns-&gt;get_column( &apos;EXISTS_IN_HANA&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;EXISTS_IN_HOTA&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_STATUS&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_DEPLOY_MODE&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;ABAP_NO_TRANSLATION&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;MASTERLANG&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

*...change column settings
        IF gv_sync = &apos;X&apos;.
          lr_column ?= lr_columns-&gt;get_column( &apos;SYNC_DEPLOY_STATE&apos; ).
          lr_column-&gt;set_short_text( &apos;Status&apos;(107) ).
          lr_column-&gt;set_medium_text( &apos;Sync.status Paket&apos;(108) ).
          lr_column-&gt;set_long_text( &apos;Synchronisierungsstatus Paket&apos;(109) ).
          lr_column-&gt;set_output_length( 6 ).
          lr_column-&gt;set_icon( if_salv_c_bool_sap=&gt;true ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column ?= lr_columns-&gt;get_column( &apos;SYNC_DEPLOY_STATE&apos; ).
          lr_column-&gt;set_short_text( &apos;Status&apos;(107) ).
          lr_column-&gt;set_medium_text( &apos;Depl.status Paket&apos;(218) ).
          lr_column-&gt;set_long_text( &apos;Deploymentstatus Paket&apos;(219) ).
          lr_column-&gt;set_output_length( 6 ).
          lr_column-&gt;set_icon( if_salv_c_bool_sap=&gt;true ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;PACKAGE_ID&apos; ).
        set_column_length( i_column = lr_column i_min_length = 9 i_max_length = mv_max_length_package_id ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_PACKAGE_ID&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_package_id ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_HANA_PACKAGE_ID&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_package_id ).

        lr_column ?= lr_columns-&gt;get_column( &apos;TRANSPORT_OBJ_NAME&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;DEVCLASS&apos; ).
        lr_column-&gt;set_short_text( &apos;ABAP-Paket&apos;(103) ).
        lr_column-&gt;set_medium_text( &apos;ABAP-Paket&apos;(104) ).
        lr_column-&gt;set_long_text( &apos;ABAP-Paket&apos;(105) ).
        set_column_length( i_column = lr_column i_min_length = 10 i_max_length = mv_max_length_devclass ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_DESCRIPTION&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_desc ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_DESCRIPTION&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_desc ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_SRC_SYSTEM&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_src_system ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_SRC_SYSTEM&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_src_system ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_SRC_TENANT&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_src_tenant ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_SRC_TENANT&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_src_tenant ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_RESPONSIBLE&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_responsible ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_RESPONSIBLE&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_responsible ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_ORIGINAL_LANGUAGE&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        lr_column-&gt;set_output_length( 20 ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ORIGINAL_LANGUAGE&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        lr_column-&gt;set_output_length( 20 ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_IS_STRUCTURAL&apos; ).
        lr_column-&gt;set_short_text( &apos;Struk.pak.&apos;(110) ).
        lr_column-&gt;set_medium_text( &apos;Strukturpaket&apos;(111) ).
        lr_column-&gt;set_long_text( &apos;Strukturpaket&apos;(112) ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        lr_column-&gt;set_output_length( 20 ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_IS_STRUCTURAL&apos; ).
        lr_column-&gt;set_short_text( &apos;Struk.pak.&apos;(110) ).
        lr_column-&gt;set_medium_text( &apos;Strukturpaket&apos;(111) ).
        lr_column-&gt;set_long_text( &apos;Strukturpaket&apos;(112) ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        lr_column-&gt;set_output_length( 20 ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_DELIVERY_UNIT&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_du_name ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_DELIVERY_UNIT&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_du_name ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_DELIVERY_UNIT_VENDOR&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_du_vendor ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_DELIVERY_UNIT_VENDOR&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_du_vendor ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_TEXT_COLLECTION&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_text_coll ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_TEXT_COLLECTION&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_text_coll ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_TEXT_STATUS&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_text_status ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_TEXT_STATUS&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_text_status ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_TEXT_TERMINOLOGY_DOMAIN&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_text_domain ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_TEXT_TERMINOLOGY_DOMAIN&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_text_domain ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_HINTS_FOR_TRANSLATION&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_hint ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_HINTS_FOR_TRANSLATION&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_pack_hint ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_SYNC_SYSTEM&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        lr_column-&gt;set_output_length( 15 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_SYNCED_AT&apos; ).
        lr_column-&gt;set_short_text( &apos;Sync.zeit&apos;(113) ).
        lr_column-&gt;set_medium_text( &apos;Synchronis.zeit&apos;(114) ).
        lr_column-&gt;set_long_text( &apos;Synchronisierungszeit&apos;(115) ).
        lr_column-&gt;set_output_length( 19 ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_SYNCED_BY&apos; ).
        lr_column-&gt;set_output_length( 25 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_DEPLOYED_AT&apos; ).
        lr_column-&gt;set_short_text( &apos;Deployzeit&apos;(116) ).
        lr_column-&gt;set_medium_text( &apos;Deployzeit&apos;(117) ).
        lr_column-&gt;set_long_text( &apos;Deployzeit&apos;(118) ).
        lr_column-&gt;set_output_length( 19 ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_DEPLOYED_BY&apos; ).
        lr_column-&gt;set_output_length( 25 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_READ_SYSTEM&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_STATUS_AS_TEXT&apos; ).
        lr_column-&gt;set_short_text( &apos;Status&apos;(107) ).
        lr_column-&gt;set_medium_text( &apos;Status in ABAP&apos;(119) ).
        lr_column-&gt;set_long_text( &apos;Status in ABAP&apos;(120) ).
        lr_column-&gt;set_output_length( 15 ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_DEPLOY_MODE_AS_TEXT&apos; ).
        lr_column-&gt;set_short_text( &apos;Deploymod.&apos;(166) ).
        lr_column-&gt;set_medium_text( &apos;Deploymodus&apos;(167) ).
        lr_column-&gt;set_long_text( &apos;Deploymodus&apos;(168) ).
        lr_column-&gt;set_output_length( 15 ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;ABAP_TRANSLATION_AS_TEXT&apos; ).
*        lr_column-&gt;set_short_text( &apos;Deploymod.&apos;(166) ).
*        lr_column-&gt;set_medium_text( &apos;Deploymodus&apos;(167) ).
        lr_column-&gt;set_long_text( &apos;Übersetzungsrelevanz&apos;(201) ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;ABAP_IMPORT_TIMESTAMP&apos; ).
        lr_column-&gt;set_short_text( &apos;Importzeit&apos;(236) ).
        lr_column-&gt;set_medium_text( &apos;Importzeit&apos;(237) ).
        lr_column-&gt;set_long_text( &apos;Importzeit&apos;(238) ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ). &quot; not visible directly in ALV List

      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*handle slave columns
    TRY.
        lr_columns = mr_hierseq-&gt;get_columns( 2 ).

        TRY.
            lr_columns-&gt;set_color_column( &apos;T_COLOR&apos; ).
          CATCH cx_salv_data_error.                     &quot;#EC NO_HANDLER
        ENDTRY.

*... optimze the columns
*          lr_columns-&gt;set_optimize( abap_true ).

*      lr_column = lr_columns-&gt;get_column( &apos;OBJECT_NAME&apos; ).
*      lr_column-&gt;set_output_length( 50 ).

*... hide technical columns
        lr_column ?= lr_columns-&gt;get_column( &apos;ABAP_HANA_PACKAGE_ID&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;EXISTS_IN_HANA&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;EXISTS_IN_HOTA&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_STATUS&apos; ).
        lr_column-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).

*...change column settings
        IF gv_sync = &apos;X&apos;.
          lr_column ?= lr_columns-&gt;get_column( &apos;SYNC_DEPLOY_STATE&apos; ).
          lr_column-&gt;set_short_text( &apos;Status&apos;(107) ).
          lr_column-&gt;set_medium_text( &apos;Sync.status Objekt&apos;(121) ).
          lr_column-&gt;set_long_text( &apos;Synchronisierungsstatus Objekt&apos;(122) ).
          lr_column-&gt;set_output_length( 6 ).
          lr_column-&gt;set_icon( ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column ?= lr_columns-&gt;get_column( &apos;SYNC_DEPLOY_STATE&apos; ).
          lr_column-&gt;set_short_text( &apos;Status&apos;(107) ).
          lr_column-&gt;set_medium_text( &apos;Depl.status Objekt&apos;(220) ).
          lr_column-&gt;set_long_text( &apos;Deploymentstatus Objekt&apos;(221) ).
          lr_column-&gt;set_output_length( 6 ).
          lr_column-&gt;set_icon( ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_PACKAGE_ID&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_package_id ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_HANA_PACKAGE_ID&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 20 i_max_length = mv_max_length_package_id ).

        lr_column ?= lr_columns-&gt;get_column( &apos;OBJECT_NAME&apos; ).
        set_column_length( i_column = lr_column i_min_length = 10 i_max_length = mv_max_length_object_name ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_OBJECT_NAME&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 10 i_max_length = mv_max_length_object_name ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_HANA_OBJECT_NAME&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 10 i_max_length = mv_max_length_object_name ).

        lr_column ?= lr_columns-&gt;get_column( &apos;OBJECT_SUFFIX&apos; ).
        set_column_length( i_column = lr_column i_min_length = 12 i_max_length = mv_max_length_object_suffix ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_OBJECT_SUFFIX&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 12 i_max_length = mv_max_length_object_suffix ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_HANA_OBJECT_SUFFIX&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).
        set_column_length( i_column = lr_column i_min_length = 12 i_max_length = mv_max_length_object_suffix ).

        lr_column ?= lr_columns-&gt;get_column( &apos;TRANSPORT_OBJ_NAME&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_OBJECT_STATUS&apos; ).
        lr_column-&gt;set_short_text( &apos;Obj.status&apos;(123) ).
        lr_column-&gt;set_medium_text( &apos;Objektstatus in HANA&apos;(124) ).
        lr_column-&gt;set_long_text( &apos;Objektstatus in HANA&apos;(125) ).
        lr_column-&gt;set_icon( if_salv_c_bool_sap=&gt;true ).
        lr_column-&gt;set_output_length( 20 ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_SOURCE_OBJECT_VERSION&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
*       not really necessary
*        lr_column-&gt;set_short_text( &apos;ObjVersQu&apos;(184) ).
*        lr_column-&gt;set_medium_text( &apos;Objektvers/Quellsyst&apos;(185) ).
        lr_column-&gt;set_long_text( &apos;Objektversion aus Quellsystem&apos;(186) ).
        lr_column-&gt;set_output_length( 21 ). &quot; 4 should be enough?!?

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_VERSION&apos; ).
        lr_column-&gt;set_short_text( &apos;Obj.vers.&apos;(130) ).
        lr_column-&gt;set_medium_text( &apos;Objektversion&apos;(131) ).
        lr_column-&gt;set_long_text( &apos;Objektversion&apos;(132) ).
        lr_column-&gt;set_output_length( 21 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_VERSION&apos; ).
        lr_column-&gt;set_short_text( &apos;Obj.vers.&apos;(130) ).
        lr_column-&gt;set_medium_text( &apos;Objektversion&apos;(131) ).
        lr_column-&gt;set_long_text( &apos;Objektversion&apos;(132) ).
        lr_column-&gt;set_output_length( 21 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_HANA_READ_SYSTEM&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        lr_column-&gt;set_output_length( 20 ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_HANA_READ_SYSTEM&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        lr_column-&gt;set_output_length( 20 ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_ACTIVATED_AT&apos; ).
        lr_column-&gt;set_short_text( &apos;Aktiv.zeit&apos;(126) ).
        lr_column-&gt;set_medium_text( &apos;Aktivierungszeit&apos;(127) ).
        lr_column-&gt;set_long_text( &apos;Aktivierungszeit&apos;(128) ).
        lr_column-&gt;set_output_length( 25 ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ACTIVATED_AT&apos; ).
        lr_column-&gt;set_short_text( &apos;Aktiv.zeit&apos;(126) ).
        lr_column-&gt;set_medium_text( &apos;Aktivierungszeit&apos;(127) ).
        lr_column-&gt;set_long_text( &apos;Aktivierungszeit&apos;(128) ).
        lr_column-&gt;set_output_length( 25 ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HANA_ACTIVATED_BY&apos; ).
        lr_column-&gt;set_output_length( 23 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        set_column_long_text( i_text_template = lv_text_in_hana i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ACTIVATED_BY&apos; ).
        lr_column-&gt;set_output_length( 23 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        set_column_long_text( i_text_template = lv_text_in_hota i_column = lr_column ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_SYNC_SYSTEM&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        lr_column-&gt;set_output_length( 15 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_SYNCED_AT&apos; ).
        lr_column-&gt;set_short_text( &apos;Sync.zeit&apos;(113) ).
        lr_column-&gt;set_medium_text( &apos;Synchronis.zeit&apos;(114) ).
        lr_column-&gt;set_long_text( &apos;Synchronisierungszeit&apos;(115) ).
        lr_column-&gt;set_output_length( 19 ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_SYNCED_BY&apos; ).
        lr_column-&gt;set_output_length( 25 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_DEPLOYED_AT&apos; ).
        lr_column-&gt;set_short_text( &apos;Deployzeit&apos;(116) ).
        lr_column-&gt;set_medium_text( &apos;Deployzeit&apos;(117) ).
        lr_column-&gt;set_long_text( &apos;Deployzeit&apos;(118) ).
        lr_column-&gt;set_output_length( 19 ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_ABAP_DEPLOYED_BY&apos; ).
        lr_column-&gt;set_output_length( 25 ).
        lr_column-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
        IF gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;true ).
        ENDIF.

        lr_column ?= lr_columns-&gt;get_column( &apos;HOT_STATUS_AS_TEXT&apos; ).
        lr_column-&gt;set_short_text( &apos;Status&apos;(107) ).
        lr_column-&gt;set_medium_text( &apos;Status in ABAP&apos;(119) ).
        lr_column-&gt;set_long_text( &apos;Status in ABAP&apos;(120) ).
        lr_column-&gt;set_output_length( 15 ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).

        lr_column ?= lr_columns-&gt;get_column( &apos;ABAP_IMPORT_TIMESTAMP&apos; ).
        lr_column-&gt;set_short_text( &apos;Importzeit&apos;(236) ).
        lr_column-&gt;set_medium_text( &apos;Importzeit&apos;(237) ).
        lr_column-&gt;set_long_text( &apos;Importzeit&apos;(238) ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ). &quot; not visible directly in ALV List

        lr_column ?= lr_columns-&gt;get_column( &apos;ABAP_OBJECT_REFERENCE&apos; ).
        lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
      CATCH cx_salv_not_found INTO DATA(exc3).
        ls_msg = exc3-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

    handle_dynamic_columns( ).

*... *** GENERAL Settings ***

*... set layout settings
    lr_layout = mr_hierseq-&gt;get_layout( ).

    ls_layout_key-report = sy-repid.
    lr_layout-&gt;set_key( ls_layout_key ).

    lr_layout-&gt;set_default( abap_true ).
    lr_layout-&gt;set_save_restriction( if_salv_c_layout=&gt;restrict_none ).

*... register to the events
    lr_events = mr_hierseq-&gt;get_event( ).

    DATA(lr_event_handler) = NEW lcl_handle_events( i_hot_organizer = me ).
    SET HANDLER lr_event_handler-&gt;on_user_command FOR lr_events.
    SET HANDLER lr_event_handler-&gt;on_user_command FOR lr_events.

*... §6.2 register to the event BEFORE_SALV_FUNCTION
    SET HANDLER lr_event_handler-&gt;on_before_salv_function FOR lr_events.
*... §6.3 register to the event AFTER_SALV_FUNCTION
    SET HANDLER lr_event_handler-&gt;on_after_salv_function FOR lr_events.

*.... default sorting otherwise preselection does not work...
    SORT mt_master BY package_id ASCENDING.
    SORT mt_slave BY abap_hana_package_id object_name ASCENDING.

    preselect_all_out_of_sync( ).

*... display the table
    mr_hierseq-&gt;display( ).

  ENDMETHOD.



  METHOD read_object_data_from_hana.

    DATA: dr_master       TYPE REF TO g_type_s_master,
          lt_hana_objects TYPE cl_nhi_object_id_and_caption=&gt;ty_objlist_caption.

    LOOP AT mt_master REFERENCE INTO dr_master WHERE hana_package_id IS NOT INITIAL.
      lt_hana_objects = mr_hot_hana_connector-&gt;find_active_objects_in_hana( i_hana_package_id = dr_master-&gt;hana_package_id i_object_status = &apos;0&apos; ).
      append_hana_objcts_to_mt_slave( i_master = dr_master i_hana_objects = lt_hana_objects i_object_status = icon_okay ).

      lt_hana_objects = mr_hot_hana_connector-&gt;find_active_objects_in_hana( i_hana_package_id = dr_master-&gt;hana_package_id i_object_status = &apos;1&apos; ).

      IF lt_hana_objects IS NOT INITIAL.
        mv_any_object_not_ok_in_hana = abap_true.
        append_hana_objcts_to_mt_slave( i_master = dr_master i_hana_objects = lt_hana_objects i_object_status = icon_alert ).
      ENDIF.

      IF lt_hana_objects IS NOT INITIAL.
        mv_any_object_not_ok_in_hana = abap_true.
        lt_hana_objects = mr_hot_hana_connector-&gt;find_active_objects_in_hana( i_hana_package_id = dr_master-&gt;hana_package_id i_object_status = &apos;2&apos; ).

        append_hana_objcts_to_mt_slave( i_master = dr_master i_hana_objects = lt_hana_objects i_object_status = icon_generate ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD read_object_data_from_hot.

    DATA: lt_hot_objects        TYPE STANDARD TABLE OF cts_hot_object,
          ls_slave              TYPE g_type_s_slave,
          lr_cts_hot_object     TYPE REF TO cl_cts_hot_object_v1,
          lv_transport_obj_name TYPE g_type_s_slave-transport_obj_name.

    LOOP AT mt_master ASSIGNING FIELD-SYMBOL(&lt;master&gt;).
      CLEAR lt_hot_objects.
      SELECT hana_package_id, hana_object_name, hana_object_suffix, hana_read_system, hana_source_object_version,
             hana_object_version, abap_sync_system, hot_status, hana_activated_at, hana_activated_by, abap_synced_at,
             abap_synced_by, abap_deployed_at, abap_deployed_by, abap_import_timestamp, abap_object_reference
            FROM cts_hot_object
            INTO CORRESPONDING FIELDS OF TABLE @lt_hot_objects WHERE abap_hana_package_id = @&lt;master&gt;-transport_obj_name
                                                                 AND abap_status = &apos;A&apos;.

      IF sy-subrc = 0.
        LOOP AT lt_hot_objects ASSIGNING FIELD-SYMBOL(&lt;hot_object&gt;).
          lr_cts_hot_object = cl_cts_hot_object_v1=&gt;create_instance2(
                                io_cts_hot_package = &lt;master&gt;-cts_hot_package_ref
                                iv_hana_object_name = &lt;hot_object&gt;-hana_object_name
                                iv_hana_object_suffix = &lt;hot_object&gt;-hana_object_suffix ).
          lv_transport_obj_name = lr_cts_hot_object-&gt;transport_object_name.

          READ TABLE mt_slave WITH KEY transport_obj_name = lv_transport_obj_name ASSIGNING FIELD-SYMBOL(&lt;slave&gt;).

          IF sy-subrc &lt;&gt; 0.
            &quot;if object only exists in HOT, create an entry in mt_slave
            CLEAR ls_slave.
            ls_slave-abap_hana_package_id = &lt;master&gt;-transport_obj_name.
            ls_slave-cts_hot_object_ref = lr_cts_hot_object.
            ls_slave-transport_obj_name = lv_transport_obj_name.
            ls_slave-object_name = &lt;hot_object&gt;-hana_object_name.
            ls_slave-object_suffix = &lt;hot_object&gt;-hana_object_suffix.
            APPEND  ls_slave TO mt_slave.

            &quot;read entry again to have a pointer to the data in the table for the rest of assignments after the if.
            READ TABLE mt_slave INDEX lines( mt_slave ) ASSIGNING &lt;slave&gt;.

            set_max_length( EXPORTING i_text = &lt;slave&gt;-hana_object_name CHANGING c_length = mv_max_length_object_name ).
            set_max_length( EXPORTING i_text = &lt;slave&gt;-hana_object_suffix CHANGING c_length = mv_max_length_object_suffix ).
          ENDIF.

          &quot;assign general data independent whether mt_slave had already an entry or not
          &lt;slave&gt;-hot_hana_package_id = &lt;hot_object&gt;-hana_package_id.
          &lt;slave&gt;-hot_hana_object_name = &lt;hot_object&gt;-hana_object_name.
          &lt;slave&gt;-hot_hana_object_suffix = &lt;hot_object&gt;-hana_object_suffix.
          &lt;slave&gt;-hot_abap_deployed_at = create_local_time_string( &lt;hot_object&gt;-abap_deployed_at ).
          &lt;slave&gt;-hot_abap_deployed_by = &lt;hot_object&gt;-abap_deployed_by.
          &lt;slave&gt;-hot_abap_synced_at = create_local_time_string( &lt;hot_object&gt;-abap_synced_at ).
          &lt;slave&gt;-hot_abap_synced_by = &lt;hot_object&gt;-abap_synced_by.
          &lt;slave&gt;-hot_abap_sync_system = &lt;hot_object&gt;-abap_sync_system.
          &lt;slave&gt;-hot_activated_at = create_local_time_string( &lt;hot_object&gt;-hana_activated_at ).
          &lt;slave&gt;-hot_activated_by = &lt;hot_object&gt;-hana_activated_by.
          &lt;slave&gt;-hot_hana_read_system = &lt;hot_object&gt;-hana_read_system.
          &lt;slave&gt;-hot_status = &lt;hot_object&gt;-hot_status.
          &lt;slave&gt;-hot_version = &lt;hot_object&gt;-hana_object_version.
          &lt;slave&gt;-abap_import_timestamp = create_local_time_string( CONV timestampl( &lt;hot_object&gt;-abap_import_timestamp(14) ) ).
          IF &lt;master&gt;-abap_no_translation IS INITIAL.
            &lt;slave&gt;-abap_object_reference = &lt;hot_object&gt;-abap_object_reference.
          ELSE.
            CLEAR &lt;slave&gt;-abap_object_reference.
          ENDIF.
          CONDENSE &lt;slave&gt;-hot_version.
          &lt;slave&gt;-hana_source_object_version = &lt;hot_object&gt;-hana_source_object_version.
          &lt;slave&gt;-exists_in_hota = abap_true.

          &quot;Fix display of wrong timestamp in HOT created with older version of HTA organizer
          IF &lt;slave&gt;-exists_in_hana = abap_true AND &lt;slave&gt;-exists_in_hota = abap_true
             AND &lt;slave&gt;-hot_activated_at &lt;&gt; &lt;slave&gt;-hana_activated_at
             AND &lt;slave&gt;-hana_version = &lt;slave&gt;-hot_version
             AND &lt;slave&gt;-hana_package_id = &lt;slave&gt;-hot_hana_package_id
             AND &lt;slave&gt;-hana_object_name = &lt;slave&gt;-hot_hana_object_name
             AND &lt;slave&gt;-hana_object_suffix = &lt;slave&gt;-hot_hana_object_suffix.
            &quot;if same version and same case of file name and package, we assume timestamps must be the same
            &lt;slave&gt;-hot_activated_at = &lt;slave&gt;-hana_activated_at.
          ENDIF.
        ENDLOOP.
      ELSE.
        &quot;no data in HOT
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD calculate_sync_status.
    FIELD-SYMBOLS: &lt;master&gt; TYPE g_type_s_master,
                   &lt;slave&gt;  TYPE g_type_s_slave.

* ... 1.  handle packages
    LOOP AT mt_master ASSIGNING &lt;master&gt;.
      &quot;set sync status
      IF &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_inactive
        OR &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_deploy_error
        OR &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted
        OR &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_delete_error.
        &lt;master&gt;-sync_deploy_state = icon_led_inactive.
      ELSEIF &quot;&lt;master&gt;-hana_delivery_unit &lt;&gt; &lt;master&gt;-hot_delivery_unit &quot;DU difference is not a difference because HTA does not write DU data to HANA
         &quot;OR &lt;master&gt;-hana_delivery_unit_vendor &lt;&gt; &lt;master&gt;-hot_delivery_unit_vendor
         &lt;master&gt;-hana_description &lt;&gt; &lt;master&gt;-hot_description
         OR &lt;master&gt;-hana_hints_for_translation &lt;&gt; &lt;master&gt;-hot_hints_for_translation
         OR &lt;master&gt;-hana_is_structural &lt;&gt; &lt;master&gt;-hot_is_structural
         OR &lt;master&gt;-hana_original_language &lt;&gt; &lt;master&gt;-hot_original_language
         OR &lt;master&gt;-hana_responsible &lt;&gt; &lt;master&gt;-hot_responsible
         OR &lt;master&gt;-hana_src_system &lt;&gt; &lt;master&gt;-hot_src_system
         OR &lt;master&gt;-hana_src_tenant &lt;&gt; &lt;master&gt;-hot_src_tenant
         OR &lt;master&gt;-hana_text_collection &lt;&gt; &lt;master&gt;-hot_text_collection
         OR &lt;master&gt;-hana_text_status &lt;&gt; &lt;master&gt;-hot_text_status
         OR &lt;master&gt;-hana_text_terminology_domain &lt;&gt; &lt;master&gt;-hot_text_terminology_domain.
        &lt;master&gt;-sync_deploy_state = icon_led_yellow.
      ELSE.
        &lt;master&gt;-sync_deploy_state = icon_led_green.
      ENDIF.

      &quot;set color in case package id in HANA is different than in HOTA (but will be same transport object name!!!)
      IF &lt;master&gt;-exists_in_hana = abap_true AND &lt;master&gt;-exists_in_hota = abap_true AND &lt;master&gt;-hana_package_id &lt;&gt; &lt;master&gt;-hot_hana_package_id.
        &quot;set color to blue in case HANA package id is different in HANA and HOTA
        append_change_color( EXPORTING i_name1 = &apos;HANA_PACKAGE_ID&apos; i_name2 = &apos;HOT_HANA_PACKAGE_ID&apos;
                             CHANGING ch_color_table = &lt;master&gt;-t_color  ).
        &lt;master&gt;-sync_deploy_state = icon_led_red. &quot;Do not allow sync for case different packages
      ENDIF.

      mark_difference_package( IMPORTING ev_master = &lt;master&gt; ).
    ENDLOOP.

* ... 2. handle objects
    LOOP AT mt_slave ASSIGNING &lt;slave&gt;.

      IF &lt;master&gt;-transport_obj_name &lt;&gt; &lt;slave&gt;-abap_hana_package_id.
        READ TABLE mt_master ASSIGNING &lt;master&gt; WITH KEY transport_obj_name = &lt;slave&gt;-abap_hana_package_id.
      ENDIF.

      IF &lt;master&gt;-sync_deploy_state = icon_led_red.
        &quot;set status to red if package has case difference, because this is currently not support.
        &quot;no colors to be set for these slaves as the objects can not be compared
        &lt;slave&gt;-sync_deploy_state = icon_led_red.
      ELSEIF &lt;slave&gt;-exists_in_hota = abap_false AND &lt;slave&gt;-exists_in_hana = abap_true.
        &lt;slave&gt;-sync_deploy_state = icon_led_yellow.
      ELSEIF &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_inactive
            OR &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_deploy_error
            OR &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted
            OR &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_delete_error.
        &lt;slave&gt;-sync_deploy_state = icon_led_inactive.
      ELSEIF &lt;slave&gt;-hana_package_id &lt;&gt; &lt;slave&gt;-hot_hana_package_id
            OR &lt;slave&gt;-hana_object_name &lt;&gt; &lt;slave&gt;-hot_hana_object_name
            OR &lt;slave&gt;-hana_version &lt;&gt; &lt;slave&gt;-hot_version &quot;Stephan
            OR &lt;slave&gt;-hana_activated_at &lt;&gt; &lt;slave&gt;-hot_activated_at
            OR &lt;slave&gt;-hana_activated_by &lt;&gt; &lt;slave&gt;-hot_activated_by.
        IF &lt;slave&gt;-exists_in_hana = abap_true AND &lt;slave&gt;-exists_in_hota = abap_true
            AND ( &lt;slave&gt;-hana_package_id &lt;&gt; &lt;slave&gt;-hot_hana_package_id
                  OR &lt;slave&gt;-hana_object_name &lt;&gt; &lt;slave&gt;-hot_hana_object_name
                  OR &lt;slave&gt;-hana_object_suffix &lt;&gt; &lt;slave&gt;-hot_hana_object_suffix ).
          &lt;slave&gt;-sync_deploy_state = icon_led_red.
        ELSE.
          &lt;slave&gt;-sync_deploy_state = icon_led_yellow.
        ENDIF.
      ELSE.
        &lt;slave&gt;-sync_deploy_state = icon_led_green.
      ENDIF.

      mark_difference_object( IMPORTING ev_slave = &lt;slave&gt; ).
    ENDLOOP.

  ENDMETHOD.

  METHOD search_packges_in_hana_and_hot.

    CLEAR: e_hana_packages, e_hot_packages.

*...  read all packages with i_package name from HANA
    e_hana_packages = mr_hot_hana_connector-&gt;list_hana_packages( i_hana_package_name ).

*...  read all packages with i_package name from HOT
    &quot;convert * to % for select with like
    DATA(lv_package) = i_hana_package_name.
    REPLACE ALL OCCURRENCES OF &apos;*&apos; IN lv_package WITH &apos;%&apos;.

    IF sy-subrc = 0 OR sy-subrc = 2. &quot;switch for select with &apos;LIKE&apos; or &apos;=&apos;
      REPLACE ALL OCCURRENCES OF &apos;_&apos; IN lv_package WITH &apos;\_&apos;.
      SELECT hana_package_id FROM cts_hot_package INTO TABLE @e_hot_packages WHERE hana_package_id LIKE @lv_package ESCAPE &apos;\&apos; AND abap_status = &apos;A&apos;.
      DATA(lv_case_like) = &apos;X&apos;.
    ELSE.
      SELECT hana_package_id FROM cts_hot_package INTO TABLE @e_hot_packages WHERE hana_package_id = @lv_package AND abap_status = &apos;A&apos;.
    ENDIF.

    IF e_hana_packages IS INITIAL AND e_hot_packages IS INITIAL.
      IF lv_case_like = &apos;X&apos;.
        SELECT hana_package_id FROM cts_hot_package INTO TABLE @e_hot_packages WHERE abap_hana_package_id LIKE @lv_package ESCAPE &apos;\&apos; AND abap_status = &apos;A&apos;.
      ELSE.
        SELECT hana_package_id FROM cts_hot_package INTO TABLE @e_hot_packages WHERE abap_hana_package_id = @lv_package AND abap_status = &apos;A&apos;.
      ENDIF.
      IF e_hot_packages IS NOT INITIAL.
        LOOP AT e_hot_packages ASSIGNING FIELD-SYMBOL(&lt;hot_package&gt;).
          DATA(l_hana_packages) = mr_hot_hana_connector-&gt;list_hana_packages( &lt;hot_package&gt; ).
          APPEND LINES OF l_hana_packages TO e_hana_packages.
        ENDLOOP.
      ENDIF.
    ENDIF.

    &quot;if subpackages should be selected, execute this method again for all found packages so far plus &apos;.*&apos; as input string. (with &apos;.*&apos; all subpackages will bes elected)
    IF i_include_subpackages = abap_true.
      &quot;if last character of search string was a &apos;*&apos; then we do not need to search for subpackages anymore...
      DATA(lv_length) = strlen( i_hana_package_name ).
      IF lv_length &gt; 0 AND substring( val = i_hana_package_name off = lv_length - 1 len = 1 ) &lt;&gt; &apos;*&apos;.
        DATA(lt_all_packages) = e_hana_packages.
        APPEND LINES OF e_hot_packages TO lt_all_packages.
        SORT lt_all_packages ASCENDING.
        DELETE ADJACENT DUPLICATES FROM lt_all_packages.

        LOOP AT lt_all_packages INTO DATA(lv_hana_package).
          search_packges_in_hana_and_hot(
            EXPORTING
              i_hana_package_name      = lv_hana_package &amp;&amp; &apos;.*&apos;
              i_include_subpackages   = abap_false &quot;abap_false to stop recursive function call because &apos;.*&apos; will already contain all subpackages of all levels.
            IMPORTING
              e_hana_packages          = DATA(lt_hana_packages)
              e_hot_packages           = DATA(lt_hot_packages)
          ).
          APPEND LINES OF lt_hana_packages TO e_hana_packages.
          SORT e_hana_packages ASCENDING.
          DELETE ADJACENT DUPLICATES FROM e_hana_packages.

          APPEND LINES OF lt_hot_packages TO e_hot_packages.
          SORT e_hot_packages ASCENDING.
          DELETE ADJACENT DUPLICATES FROM e_hot_packages.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD sync_data.
    DATA: lv_text TYPE string.

    TRY.
        get_selected_data( EXPORTING i_check_deletion_consistency = abap_true
                           IMPORTING e_hotp_packages = DATA(lt_hotp_packages) e_hota_packages = DATA(lt_hota_packages) e_hota_objects = DATA(lt_hota_objects) e_hoto_objects = DATA(lt_hoto_objects) ).

        IF lt_hotp_packages IS INITIAL AND lt_hota_packages IS INITIAL AND lt_hoto_objects IS INITIAL AND lt_hota_objects IS INITIAL.
          MESSAGE &apos;Synchronisierung nicht möglich; markieren Sie Einträge mit gelbem oder grünem Status&apos;(240) TYPE &apos;S&apos;.
        ELSE.
          &quot;if lt_hoto_objects should be synced check whether package is already known in HOT repo or part of HOTP and if not, add it to lt_hotp_packages

          &quot;each package needs to be added only once, so group all objects by package
          LOOP AT lt_hoto_objects INTO DATA(lr_hoto_object) GROUP BY lr_hoto_object-&gt;abap_hana_package_id REFERENCE INTO DATA(lr_hoto_group).
            LOOP AT GROUP lr_hoto_group INTO DATA(lr_hoto_member).
              &quot;check if package already in hotp
              DATA(package_part_of_hotp) = abap_false.
              LOOP AT lt_hotp_packages ASSIGNING FIELD-SYMBOL(&lt;hotp&gt;).
                IF &lt;hotp&gt;-&gt;abap_hana_package_id = lr_hoto_member-&gt;abap_hana_package_id.
                  package_part_of_hotp = abap_true.
                  EXIT.
                ENDIF.
              ENDLOOP.

              IF package_part_of_hotp = abap_false.
                READ TABLE mt_master REFERENCE INTO DATA(lr_master) WITH KEY transport_obj_name = lr_hoto_member-&gt;abap_hana_package_id.
                IF sy-subrc = 0 AND lr_master-&gt;cts_hot_package_ref IS BOUND.
                  IF lr_master-&gt;exists_in_hota = abap_false.
                    APPEND lr_master-&gt;cts_hot_package_ref TO lt_hotp_packages.
                  ENDIF.
                ELSE.
                  SELECT SINGLE abap_hana_package_id FROM cts_hot_package INTO @DATA(lv_abap_hana_package_id) WHERE abap_hana_package_id = @lr_hoto_member-&gt;abap_hana_package_id AND abap_status = &apos;A&apos;.
                  IF sy-subrc &lt;&gt; 0.
                    APPEND cl_cts_hot_package=&gt;create_instance( lr_hoto_member-&gt;hana_package_id ) TO lt_hotp_packages.
                  ENDIF.
                ENDIF.
                EXIT. &quot;only one loop run per abap_hana_package_id needed.
              ENDIF.
            ENDLOOP.
          ENDLOOP.

          &quot;add all as R3TR/LIMUs to TR or reuse TR if already part of a TR.
          DATA(lt_used_trkorrs) = add_to_transport_request( i_hotp_packages = lt_hotp_packages i_hota_packages = lt_hota_packages i_hoto_objects = lt_hoto_objects ).

          mr_hot_hana_connector-&gt;sync_packages_from_hana_to_hot( lt_hota_packages ).
          mr_hot_hana_connector-&gt;sync_packages_from_hana_to_hot( lt_hotp_packages ).

          mr_hot_hana_connector-&gt;read_objects_from_hana_to_hot( lt_hota_objects ).
          mr_hot_hana_connector-&gt;read_objects_from_hana_to_hot( lt_hoto_objects ).

          IF lines( lt_used_trkorrs ) = 0. &quot; e.g.for $tmp objekte
            lv_text = &apos;&amp;1 Pakete/&amp;2 Objekte synchronisiert&apos;(184).
            REPLACE &apos;&amp;1&apos; IN lv_text WITH |{ lines( lt_hota_packages ) + lines( lt_hotp_packages ) }|.
            REPLACE &apos;&amp;2&apos; IN lv_text WITH |{ lines( lt_hota_objects ) + lines( lt_hoto_objects ) }|.
          ELSEIF lines( lt_used_trkorrs ) = 1.
            lv_text = &apos;&amp;1 Pakete/&amp;2 Objekte zum Transportauftrag &amp;3 hinzugefügt und synchronisiert&apos;(180).
            REPLACE &apos;&amp;1&apos; IN lv_text WITH |{ lines( lt_hota_packages ) + lines( lt_hotp_packages ) }|.
            REPLACE &apos;&amp;2&apos; IN lv_text WITH |{ lines( lt_hota_objects ) + lines( lt_hoto_objects ) }|.
            REPLACE &apos;&amp;3&apos; IN lv_text WITH lt_used_trkorrs[ 1 ].
          ELSE.
            lv_text = &apos;&amp;1 Pakete/&amp;2 Objekte zu &amp;3 Transportaufträgen hinzugefügt und synchronisiert&apos;(181).
            REPLACE &apos;&amp;1&apos; IN lv_text WITH |{ lines( lt_hota_packages ) + lines( lt_hotp_packages ) }|.
            REPLACE &apos;&amp;2&apos; IN lv_text WITH |{ lines( lt_hota_objects ) + lines( lt_hoto_objects ) }|.
            REPLACE &apos;&amp;3&apos; IN lv_text WITH |{ lines( lt_used_trkorrs ) }|.
          ENDIF.
          MESSAGE lv_text TYPE &apos;S&apos;.

          &quot; Refresh data to show sync result (status from yellow to green for items that were not in sync before)
          refresh_data( ).
        ENDIF.
      CATCH cx_hana_object_transport INTO DATA(hot_exc).
        DATA(t100_key) = hot_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH hot_exc-&gt;msgv1 hot_exc-&gt;msgv2 hot_exc-&gt;hana_error_code hot_exc-&gt;hana_error_msg.
      CATCH cx_cts_hta INTO DATA(hta_exc).
        t100_key = hta_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH hta_exc-&gt;message_variable_1 hta_exc-&gt;message_variable_2 hta_exc-&gt;message_variable_3 hta_exc-&gt;message_variable_4.
    ENDTRY.

  ENDMETHOD.

  METHOD get_selected_data.
    DATA: lr_selections        TYPE REF TO cl_salv_selections,
          lt_rows_packages     TYPE salv_t_row,
          lt_rows_objects      TYPE salv_t_row,
          lt_rows_hota_objects TYPE salv_t_row,
          l_row                TYPE i,
          lv_style             TYPE lvc_s_styl,
          lv_hota              TYPE abap_bool.

    CLEAR: e_hota_packages, e_hotp_packages, e_hota_objects, e_hoto_objects.

*... get selected packages
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 1 ).
        lt_rows_packages = lr_selections-&gt;get_selected_rows( ).
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*... get selected objects
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 2 ).
        lt_rows_objects = lr_selections-&gt;get_selected_rows( ).
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*... check for hota or hotp and fill exporting parameter
    LOOP AT lt_rows_packages INTO l_row.
      READ TABLE mt_master INDEX l_row REFERENCE INTO DATA(lr_master).

      &quot;skip package if it is not allowed to be synced.
      IF lr_master-&gt;sync_deploy_state = icon_led_inactive OR lr_master-&gt;sync_deploy_state = icon_led_red.
        CONTINUE.
      ENDIF.

      &quot;determine whether hotp or hota should be used (hota if all objects of this package are also selected and syncable, hotp otherwise)
      lv_hota = abap_true.
      CLEAR lt_rows_hota_objects.
      LOOP AT mt_slave REFERENCE INTO DATA(lr_slave) WHERE abap_hana_package_id = lr_master-&gt;transport_obj_name.
        IF NOT line_exists( lt_rows_objects[ table_line = sy-tabix ] )
                OR lr_slave-&gt;sync_deploy_state = icon_led_inactive OR lr_slave-&gt;sync_deploy_state = icon_led_red.
          lv_hota = abap_false.
          EXIT.
        ELSE.
          APPEND sy-tabix TO lt_rows_hota_objects.
        ENDIF.
      ENDLOOP.

      &quot;If package should be deleted, check whether also all objects are selected. (all objects are selected if lv_hota = abap_true)
      IF i_check_deletion_consistency = abap_true AND lr_master-&gt;exists_in_hana = abap_false AND lv_hota = abap_false.
        DATA lv_text TYPE string.
        lv_text = &apos;Paket kann nur als Gesamtpaket gelöscht werden; selektieren Sie auch die Objekte von Paket &amp;1&apos;(182).
        REPLACE &apos;&amp;1&apos; IN lv_text WITH lr_master-&gt;hot_hana_package_id.
        MESSAGE lv_text TYPE &apos;E&apos;.
        &quot;Ende Programmausfuehrung
      ENDIF.

      IF lv_hota = abap_true.
        APPEND lr_master-&gt;cts_hot_package_ref TO e_hota_packages.

        &quot;add all obects of this package to e_hota_objects
        LOOP AT lt_rows_hota_objects INTO l_row.
          READ TABLE mt_slave INDEX l_row REFERENCE INTO lr_slave.

          &quot;add objects only if allowed to be synched.
          IF lr_slave-&gt;sync_deploy_state &lt;&gt; icon_led_inactive AND lr_slave-&gt;sync_deploy_state &lt;&gt; icon_led_red.
            APPEND lr_slave-&gt;cts_hot_object_ref TO e_hota_objects.
            DELETE TABLE lt_rows_objects FROM l_row. &quot;object selection not needed anymore
          ENDIF.
        ENDLOOP.
      ELSE.
        APPEND lr_master-&gt;cts_hot_package_ref TO e_hotp_packages.
      ENDIF.
    ENDLOOP.

    LOOP AT lt_rows_objects INTO l_row.
      READ TABLE mt_slave INDEX l_row REFERENCE INTO lr_slave.
      &quot;add objects only if allowed to be synched.
      IF lr_slave-&gt;sync_deploy_state &lt;&gt; icon_led_inactive AND lr_slave-&gt;sync_deploy_state &lt;&gt; icon_led_red.
        APPEND lr_slave-&gt;cts_hot_object_ref TO e_hoto_objects.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD add_to_transport_request.
    DATA: lv_transport_request TYPE trkorr,
          lt_used_trkorrs      TYPE ty_trkorrs_sorted,
          lv_is_deletion       TYPE abap_bool.

    set_masterlang_in_mt_master( i_hota_packages = i_hota_packages
                                 i_hotp_packages = i_hotp_packages
                                 i_hoto_objects  = i_hoto_objects ).

    lt_used_trkorrs = check_objects( i_hota_packages = i_hota_packages
                                     i_hotp_packages = i_hotp_packages
                                     i_hoto_objects  = i_hoto_objects ).

    &quot;Only reuse transport request if there was only 1 request so far. otherwise we don&apos;t know which request was used last and
    &quot;we even do not know whether order of tr_object_check was &apos;correct&apos;, because we process in order hota, hotp, hoto and not as selected by user
    IF lines( lt_used_trkorrs ) = 1.
      lv_transport_request = lt_used_trkorrs[ 1 ].
    ENDIF.

    LOOP AT i_hota_packages INTO DATA(lo_hota_package).
      CLEAR lv_is_deletion.
      READ TABLE mt_master REFERENCE INTO DATA(lr_master) WITH KEY pack_ref COMPONENTS cts_hot_package_ref = lo_hota_package.
      IF lr_master-&gt;exists_in_hana = abap_false AND lr_master-&gt;exists_in_hota = abap_true.
        lv_is_deletion = abap_true.
      ENDIF.

      lv_transport_request = add_to_tr( i_pgmid = &apos;R3TR&apos; i_obj_type = &apos;HOTA&apos;
                                        i_obj_name = CONV #( lo_hota_package-&gt;abap_hana_package_id ) &quot;conv needed to extend c length 40 to c length 110
                                        i_transport_request = lv_transport_request
                                        i_is_deletion = lv_is_deletion ).
      IF lv_transport_request NE space.
        INSERT lv_transport_request INTO TABLE lt_used_trkorrs.
      ENDIF.
    ENDLOOP.

    LOOP AT i_hotp_packages INTO DATA(lo_hotp_package).
      CLEAR lv_is_deletion.
      READ TABLE mt_master REFERENCE INTO lr_master WITH KEY pack_ref COMPONENTS cts_hot_package_ref = lo_hotp_package.
      IF lr_master-&gt;exists_in_hana = abap_false AND lr_master-&gt;exists_in_hota = abap_true.
        lv_is_deletion = abap_true.
      ENDIF.

      lv_transport_request = add_to_tr( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTP&apos;
                                        i_obj_name = CONV #( lo_hotp_package-&gt;abap_hana_package_id ) &quot;conv needed to extend c length 40 to c length 110
                                        i_transport_request = lv_transport_request
                                        i_is_deletion = lv_is_deletion ).
      IF lv_transport_request NE space.
        INSERT lv_transport_request INTO TABLE lt_used_trkorrs.
      ENDIF.
    ENDLOOP.

    LOOP AT i_hoto_objects INTO DATA(lo_hoto_object).
      CLEAR lv_is_deletion.
      READ TABLE mt_slave REFERENCE INTO DATA(lr_slave) WITH KEY obj_ref COMPONENTS cts_hot_object_ref = lo_hoto_object.
      IF lr_slave-&gt;exists_in_hana = abap_false AND lr_slave-&gt;exists_in_hota = abap_true.
        lv_is_deletion = abap_true.
      ENDIF.

      lv_transport_request = add_to_tr( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTO&apos;
                                        i_obj_name = lo_hoto_object-&gt;transport_object_name
                                        i_transport_request = lv_transport_request
                                        i_is_deletion = lv_is_deletion ).
      IF lv_transport_request NE space.
        INSERT lv_transport_request INTO TABLE lt_used_trkorrs.
      ENDIF.
    ENDLOOP.

    r_result = lt_used_trkorrs.
  ENDMETHOD.


  METHOD add_to_tr.
    DATA:
      lv_text     TYPE string,
      lv_mode     TYPE string,
      lv_devclass TYPE lcl_hota_organizer=&gt;g_type_s_master-devclass.

    r_result = i_transport_request.

    READ TABLE mt_master REFERENCE INTO DATA(lr_master) WITH KEY transport_obj_name = i_obj_name(40).

    IF i_is_deletion = abap_true.
      lv_mode = &apos;DELETION&apos;.
    ENDIF.

    IF lr_master-&gt;exists_in_hota = abap_true. &quot;if so, tadir must also exist already
      lv_devclass = lr_master-&gt;devclass.
    ENDIF.


    TRY.
        r_result = mr_external_calls-&gt;rs_corr_insert(
          EXPORTING
            i_pgmid             = i_pgmid
            i_object_type       = i_obj_type
            i_object_name       = CONV #( i_obj_name )
            i_suppress_dialog   = space
            i_trkorr            = i_transport_request
            i_mode              = lv_mode
            i_masterlang        = lr_master-&gt;masterlang
            i_devclass          = lv_devclass &quot;do not use lr_master-&gt;devclass as it might contain &lt;unbekannt&gt;
        ).
      CATCH cx_cts_hta_wbo INTO DATA(lr_exc).
        DATA(t100_key) = lr_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH lr_exc-&gt;message_variable_1 lr_exc-&gt;message_variable_2 lr_exc-&gt;message_variable_3 lr_exc-&gt;message_variable_4.
        &quot;Ende Programmausfuehrung
    ENDTRY.

    IF r_result IS NOT INITIAL.
      DATA(tr) = |{ r_result }|.
      CONDENSE tr.

      lv_text = &apos;&amp;1 &amp;2 &amp;3 zum Transportauftrag &amp;4 hinzugefügt&apos;(137).
      REPLACE &apos;&amp;1&apos; IN lv_text WITH i_pgmid.
      REPLACE &apos;&amp;2&apos; IN lv_text WITH i_obj_type.
      REPLACE &apos;&amp;3&apos; IN lv_text WITH i_obj_name.
      REPLACE &apos;&amp;4&apos; IN lv_text WITH tr.

      MESSAGE lv_text TYPE &apos;S&apos;.
    ENDIF.
  ENDMETHOD.


  METHOD read_package_data_from_hana.
    LOOP AT mt_master REFERENCE INTO DATA(lr_master) WHERE exists_in_hana = abap_true.
      DATA(ls_package_data) = mr_hot_hana_connector-&gt;read_package_data_from_hana( lr_master-&gt;hana_package_id ).

      IF ls_package_data IS NOT INITIAL.
        lr_master-&gt;hana_delivery_unit = ls_package_data-hana_pack_delivery_unit.
        lr_master-&gt;hana_delivery_unit_vendor = ls_package_data-hana_pack_du_vendor.
        lr_master-&gt;hana_description = ls_package_data-hana_pack_description.
        lr_master-&gt;hana_hints_for_translation = ls_package_data-hana_pack_hints_for_transl.
        IF ls_package_data-hana_pack_is_structural = 1.
          lr_master-&gt;hana_is_structural = &apos;Ja&apos;(149).
        ELSE.
          lr_master-&gt;hana_is_structural = &apos;Nein&apos;(150).
        ENDIF.
        lr_master-&gt;hana_original_language = ls_package_data-hana_pack_orig_lang.
        lr_master-&gt;hana_responsible = ls_package_data-hana_pack_responsible.
        lr_master-&gt;hana_src_system = ls_package_data-hana_pack_src_system.
        lr_master-&gt;hana_src_tenant = ls_package_data-hana_pack_src_tenant.
        lr_master-&gt;hana_text_collection = ls_package_data-hana_pack_text_collection.
        lr_master-&gt;hana_text_status = ls_package_data-hana_pack_text_status.
        lr_master-&gt;hana_text_terminology_domain = ls_package_data-hana_pack_text_term_domain.
      ELSE.
        lr_master-&gt;exists_in_hana = abap_false.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD read_package_data_from_hot.

    DATA: ls_hot_package     TYPE cts_hot_package,
          lr_cts_hot_package TYPE REF TO cl_cts_hot_package.

    LOOP AT mt_master REFERENCE INTO DATA(lr_master).
      CLEAR ls_hot_package.
      SELECT SINGLE * FROM cts_hot_package INTO ls_hot_package WHERE abap_hana_package_id = lr_master-&gt;cts_hot_package_ref-&gt;abap_hana_package_id AND abap_status = &apos;A&apos;.
      IF ls_hot_package IS NOT INITIAL.
        lr_master-&gt;hot_delivery_unit = ls_hot_package-hana_pack_delivery_unit.
        lr_master-&gt;hot_delivery_unit_vendor = ls_hot_package-hana_pack_du_vendor.
        lr_master-&gt;hot_description = ls_hot_package-hana_pack_description.
        lr_master-&gt;hot_hints_for_translation = ls_hot_package-hana_pack_hints_for_transl.
        IF ls_hot_package-hana_pack_is_structural = 0.
          lr_master-&gt;hot_is_structural = &apos;Nein&apos;(150).
        ELSE.
          lr_master-&gt;hot_is_structural = &apos;Ja&apos;(149).
        ENDIF.
        lr_master-&gt;hot_original_language = ls_hot_package-hana_pack_orig_lang.
        lr_master-&gt;hot_responsible = ls_hot_package-hana_pack_responsible.
        lr_master-&gt;hot_src_system = ls_hot_package-hana_pack_src_system.
        lr_master-&gt;hot_src_tenant = ls_hot_package-hana_pack_src_tenant.
        lr_master-&gt;hot_text_collection = ls_hot_package-hana_pack_text_collection.
        lr_master-&gt;hot_text_status = ls_hot_package-hana_pack_text_status.
        lr_master-&gt;hot_text_terminology_domain = ls_hot_package-hana_pack_text_term_domain.
        lr_master-&gt;hot_abap_sync_system = ls_hot_package-abap_sync_system.
        lr_master-&gt;hot_abap_synced_at = create_local_time_string( ls_hot_package-abap_synced_at ).
        lr_master-&gt;hot_abap_synced_by = ls_hot_package-abap_synced_by.
        lr_master-&gt;hot_abap_deployed_at = create_local_time_string( ls_hot_package-abap_deployed_at ).
        lr_master-&gt;hot_abap_deployed_by = ls_hot_package-abap_deployed_by.
        lr_master-&gt;hana_read_system = ls_hot_package-hana_read_system.
        lr_master-&gt;hot_status           = ls_hot_package-hot_status.
        lr_master-&gt;hot_deploy_mode      = ls_hot_package-hot_activation_mode.
        lr_master-&gt;abap_no_translation  = ls_hot_package-abap_no_translation.
        lr_master-&gt;abap_import_timestamp  = create_local_time_string( CONV timestampl( ls_hot_package-abap_import_timestamp(14) ) ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD create_local_time_string.

    DATA: lv_loc_date            TYPE d,
          lv_loc_time            TYPE t,
          lv_timestamp_as_string TYPE string,
          lv_milli_seconds       TYPE string,
          lv_text                TYPE string.

    IF i_timestamp_utc IS NOT INITIAL. &quot;in initial case it contains 0.0000 that would be displayed...
      CONVERT TIME STAMP i_timestamp_utc TIME ZONE sy-zonlo INTO DATE lv_loc_date TIME lv_loc_time.
      IF sy-subrc &lt;&gt; 0.
        lv_text = &apos;Fehler (&amp;1) bei der Umwandlung des Zeitstempels &amp;2&apos;(140).
        REPLACE &apos;&amp;1&apos; IN lv_text WITH &apos;&apos; &amp;&amp; sy-subrc.
        REPLACE &apos;&amp;2&apos; IN lv_text WITH &apos;&apos; &amp;&amp; i_timestamp_utc.
        MESSAGE lv_text TYPE &apos;E&apos;.
      ENDIF.

*      lv_timestamp_as_string = i_timestamp_utc.
*      IF strlen( lv_timestamp_as_string ) &gt;= 18.
*        lv_milli_seconds = lv_timestamp_as_string+15(3).
*      ENDIF.
*
*      IF lv_milli_seconds IS NOT INITIAL.
*        r_local_time = |{ lv_loc_date(4) }-{ lv_loc_date+4(2) }-{ lv_loc_date+6(2) } { lv_loc_time(2) }:{ lv_loc_time+2(2) }:{ lv_loc_time+4(2) }.{ lv_milli_seconds }|.
*      ELSE.
      r_local_time = |{ lv_loc_date(4) }-{ lv_loc_date+4(2) }-{ lv_loc_date+6(2) } { lv_loc_time(2) }:{ lv_loc_time+2(2) }:{ lv_loc_time+4(2) }|.
*      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD conv_hana_actvted_at_to_timest.
    DATA: activated_at TYPE string,
          day          TYPE d,
          time         TYPE t,
          timest       TYPE timestampl.

    activated_at = i_activated_at.

    &quot;remove all unwanted chars in activated_at string (2014-04-14 14:26.13.1000000)
    REPLACE ALL OCCURRENCES OF REGEX &apos;[\-\:\.\s]&apos; IN activated_at WITH &apos;&apos;.

    day = activated_at(8).
    time = activated_at+8(6).

    IF mv_system_timezone IS INITIAL.
      CALL FUNCTION &apos;GET_SYSTEM_TIMEZONE&apos;
        IMPORTING
          timezone            = mv_system_timezone &quot; Zeitzone
        EXCEPTIONS
          customizing_missing = 1
          OTHERS              = 2.

      IF sy-subrc &lt;&gt; 0.
        mv_system_timezone = sy-zonlo.
      ENDIF.
    ENDIF.

    &quot;We do not use HANA timezone as we saw cases that at CET time (November) still CEST was returned (customizing issue SAP internally?).
    &quot;in addition old coding also did not work, just using HANA timezone_offset (cl_cts_hot_hana_connector=&gt;g_hana_timezone_string)
    &quot;because with the currrent timezone_offset we can not create UTC timestamps for times created with DaySavingTime.
    &quot;HANA system and ABAP system must run on same zimezone as per instguide therefore we use ABAP timezone instead
    CONVERT DATE day TIME time INTO TIME STAMP r_timest TIME ZONE mv_system_timezone.

    r_timest = r_timest + ( activated_at+14(3) / 1000 ). &quot;adds the ms to the timestamp
  ENDMETHOD.

  METHOD preselect_all_out_of_sync.

    DATA: lr_selections TYPE REF TO cl_salv_selections,
          lt_rows       TYPE salv_t_row.

*... preselect packages
    LOOP AT mt_master REFERENCE INTO DATA(lr_master).
      IF lr_master-&gt;sync_deploy_state = icon_led_yellow.
        APPEND sy-tabix TO lt_rows.
      ENDIF.
    ENDLOOP.

    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 1 ).
        lr_selections-&gt;set_selected_rows( lt_rows ).
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*... preselect objects
    CLEAR lt_rows.
    LOOP AT mt_slave REFERENCE INTO DATA(lr_slave).
      IF lr_slave-&gt;sync_deploy_state = icon_led_yellow.
        APPEND sy-tabix TO lt_rows.
      ENDIF.
    ENDLOOP.

    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 2 ).
        lr_selections-&gt;set_selected_rows( lt_rows ).
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.


  METHOD select_all_for_package.

    DATA: lr_selections TYPE REF TO cl_salv_selections,
          ls_cell       TYPE salv_s_cell,
          lt_rows       TYPE salv_t_row,
          lv_row        TYPE i,
          lv_text       TYPE string,
          ls_master     LIKE LINE OF mt_master.

*...get cell of cursor in packages.
    TRY.
        ls_cell = mr_hierseq-&gt;get_selections( 1 )-&gt;get_current_cell( ). &quot; 1 stands for hierarchy level &apos;package&apos;
        IF ls_cell IS NOT INITIAL.
          lv_row = ls_cell-row.
          &quot;reset current cell as it might be user moves to legend and then still old cell is set
          CLEAR ls_cell.
          mr_hierseq-&gt;get_selections( 1 )-&gt;set_current_cell( ls_cell ).
        ENDIF.
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*...get cell of cursor in objects if it was not in packages.
    IF lv_row IS INITIAL.
      TRY.
          ls_cell = mr_hierseq-&gt;get_selections( 2 )-&gt;get_current_cell( ). &quot; 2 stands for hierarchy level &apos;object&apos;
          IF ls_cell IS NOT INITIAL.
            READ TABLE mt_master TRANSPORTING NO FIELDS WITH KEY transport_obj_name = mt_slave[ ls_cell-row ]-abap_hana_package_id.
            lv_row = sy-tabix.
            &quot;reset current cell as it might be user moves to legend and then still old cell is set
            CLEAR ls_cell.
            mr_hierseq-&gt;get_selections( 2 )-&gt;set_current_cell( ls_cell ).
          ENDIF.
        CATCH cx_salv_not_found INTO exc.
          &quot;should not happen because we always have 2 levels of data
          ls_msg = exc-&gt;get_message( ).
          MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
      ENDTRY.
    ENDIF.

    IF lv_row IS INITIAL.
      lv_text = &apos;Setzen Sie den Cursor in eine Paket- oder Objektzeile der zu markierenden Daten&apos;(141).
      MESSAGE lv_text TYPE &apos;S&apos;.
      RETURN.
    ENDIF.

*...select package
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 1 ).
        lt_rows = lr_selections-&gt;get_selected_rows( ).

        READ TABLE mt_master INTO ls_master INDEX lv_row.
        IF ls_master-sync_deploy_state = icon_led_red OR ls_master-sync_deploy_state = icon_led_inactive. &quot;icon_led_red(not synconizable) or ICON_LED_INACTIVE
          MESSAGE &apos;Keine Einträge markiert; markieren Sie Einträge mit gelbem oder grünem Status&apos;(241) TYPE &apos;S&apos;.
          &quot; do nothing
          RETURN.
        ENDIF.

        IF NOT line_exists( lt_rows[ table_line = lv_row ] ).
          APPEND lv_row TO lt_rows.
          lr_selections-&gt;set_selected_rows( lt_rows ).
        ENDIF.
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*...select objects of package
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 2 ).
        lt_rows = lr_selections-&gt;get_selected_rows( ).
        DATA(row_added) = abap_false.
        READ TABLE mt_master INDEX lv_row REFERENCE INTO DATA(lr_master).
        LOOP AT mt_slave REFERENCE INTO DATA(lr_slave) WHERE abap_hana_package_id = lr_master-&gt;transport_obj_name.
          IF NOT line_exists( lt_rows[ table_line = sy-tabix ] ).
            APPEND sy-tabix TO lt_rows.
            row_added = abap_true.
          ENDIF.
        ENDLOOP.

        IF row_added = abap_true.
          lr_selections-&gt;set_selected_rows( lt_rows ).
        ENDIF.
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.

  METHOD deselect_all_for_package.

    DATA: lr_selections TYPE REF TO cl_salv_selections,
          ls_cell       TYPE salv_s_cell,
          lt_rows       TYPE salv_t_row,
          ls_row        TYPE i,
          lv_text       TYPE string.

*...get cell of cursor in packages.
    TRY.
        ls_cell = mr_hierseq-&gt;get_selections( 1 )-&gt;get_current_cell( ).
        IF ls_cell IS NOT INITIAL.
          ls_row = ls_cell-row.
          &quot;reset current cell as it might be user moves to legend and then still old cell is set
          CLEAR ls_cell.
          mr_hierseq-&gt;get_selections( 1 )-&gt;set_current_cell( ls_cell ).
        ENDIF.
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*...get cell of cursor in objectsif it was not in packages.
    IF ls_row IS INITIAL.
      TRY.
          ls_cell = mr_hierseq-&gt;get_selections( 2 )-&gt;get_current_cell( ).
          IF ls_cell IS NOT INITIAL.
            READ TABLE mt_master TRANSPORTING NO FIELDS WITH KEY hana_package_id = mt_slave[ ls_cell-row ]-hana_package_id.
            ls_row = sy-tabix.
            &quot;reset current cell as it might be user moves to legend and then still old cell is set
            CLEAR ls_cell.
            mr_hierseq-&gt;get_selections( 2 )-&gt;set_current_cell( ls_cell ).
          ENDIF.
        CATCH cx_salv_not_found INTO exc.
          &quot;should not happen because we always have 2 levels of data
          ls_msg = exc-&gt;get_message( ).
          MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
      ENDTRY.
    ENDIF.

    IF ls_row IS INITIAL.
      lv_text = &apos;Setzen Sie den Cursor in eine Paket- oder Objektzeile der entzumarkierenden Daten&apos;(142).
      MESSAGE lv_text TYPE &apos;S&apos;.
      RETURN.
    ENDIF.

*...deselect package
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 1 ).
        lt_rows = lr_selections-&gt;get_selected_rows( ).
        DELETE TABLE lt_rows FROM ls_row.
        IF sy-subrc = 0.
          lr_selections-&gt;set_selected_rows( lt_rows ).
        ENDIF.
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*...deselect objects of package
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 2 ).
        lt_rows = lr_selections-&gt;get_selected_rows( ).
        DATA(row_deleted) = abap_false.
        READ TABLE mt_master INDEX ls_row REFERENCE INTO DATA(lr_master).
        LOOP AT mt_slave REFERENCE INTO DATA(lr_slave) WHERE abap_hana_package_id = lr_master-&gt;transport_obj_name.
          DELETE TABLE lt_rows FROM sy-tabix.
          IF sy-subrc = 0.
            row_deleted = abap_true.
          ENDIF.
        ENDLOOP.

        IF row_deleted = abap_true.
          lr_selections-&gt;set_selected_rows( lt_rows ).
        ENDIF.
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.

  METHOD select_all.

    DATA: lr_selections TYPE REF TO cl_salv_selections,
          lt_rows       TYPE salv_t_row,
          nr_of_rows    TYPE i.

*... preselect packages
    LOOP AT mt_master ASSIGNING FIELD-SYMBOL(&lt;master&gt;).
      IF &lt;master&gt;-sync_deploy_state &lt;&gt; icon_led_red AND &lt;master&gt;-sync_deploy_state &lt;&gt; icon_led_inactive.
        APPEND sy-tabix TO lt_rows.
      ENDIF.
    ENDLOOP.

    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 1 ).
        lr_selections-&gt;set_selected_rows( lt_rows ).
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*... preselect objects
    CLEAR lt_rows.
    LOOP AT mt_slave ASSIGNING FIELD-SYMBOL(&lt;slave&gt;).
      IF &lt;slave&gt;-sync_deploy_state &lt;&gt; icon_led_red AND &lt;slave&gt;-sync_deploy_state &lt;&gt; icon_led_inactive.
        APPEND sy-tabix TO lt_rows.
      ENDIF.
    ENDLOOP.
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 2 ).
        lr_selections-&gt;set_selected_rows( lt_rows ).
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.


  METHOD deselect_all.

    DATA: lr_selections TYPE REF TO cl_salv_selections,
          lt_rows       TYPE salv_t_row.

*... deselect all packages
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 1 ).
        lr_selections-&gt;set_selected_rows( lt_rows ).
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*... deselect all objects
    TRY.
        lr_selections = mr_hierseq-&gt;get_selections( 2 ).
        lr_selections-&gt;set_selected_rows( lt_rows ).
      CATCH cx_salv_not_found INTO exc.
        &quot;should not happen because we always have 2 levels of data
        ls_msg = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.

  METHOD read_tadir_for_packages.

    DATA: lv_devclass TYPE tadir-devclass.

    LOOP AT mt_master ASSIGNING FIELD-SYMBOL(&lt;master&gt;).
      &quot;##TODO TODO better to use: call function &apos;TR_TADIR_INTERFACE&apos;
      SELECT SINGLE devclass FROM tadir INTO lv_devclass WHERE pgmid = &apos;R3TR&apos; AND object = &apos;HOTA&apos; AND obj_name = &lt;master&gt;-transport_obj_name.
      IF sy-subrc = 0.
        &lt;master&gt;-devclass = lv_devclass.

        set_max_length( EXPORTING i_text = CONV #( &lt;master&gt;-devclass ) CHANGING c_length = mv_max_length_devclass ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD replace_spaces_for_display.

    LOOP AT mt_master ASSIGNING FIELD-SYMBOL(&lt;master&gt;).
      IF &lt;master&gt;-hana_package_id IS INITIAL.
        &lt;master&gt;-hana_package_id = &apos;&lt;unbekannt&gt;&apos;(129).
      ENDIF.

      IF &lt;master&gt;-hana_delivery_unit &lt;&gt; &lt;master&gt;-hot_delivery_unit.
        IF &lt;master&gt;-hana_delivery_unit IS INITIAL.
          &lt;master&gt;-hana_delivery_unit = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_delivery_unit IS INITIAL.
          &lt;master&gt;-hot_delivery_unit = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_delivery_unit_vendor &lt;&gt; &lt;master&gt;-hot_delivery_unit_vendor.
        IF &lt;master&gt;-hana_delivery_unit_vendor IS INITIAL.
          &lt;master&gt;-hana_delivery_unit_vendor = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_delivery_unit_vendor IS INITIAL.
          &lt;master&gt;-hot_delivery_unit_vendor = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_description &lt;&gt; &lt;master&gt;-hot_description.
        IF &lt;master&gt;-hana_description IS INITIAL.
          &lt;master&gt;-hana_description = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_description IS INITIAL.
          &lt;master&gt;-hot_description = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_hints_for_translation &lt;&gt; &lt;master&gt;-hot_hints_for_translation.
        IF &lt;master&gt;-hana_hints_for_translation IS INITIAL.
          &lt;master&gt;-hana_hints_for_translation = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_hints_for_translation IS INITIAL.
          &lt;master&gt;-hot_hints_for_translation = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_is_structural &lt;&gt; &lt;master&gt;-hot_is_structural.
        IF &lt;master&gt;-hana_is_structural IS INITIAL.
          &lt;master&gt;-hana_is_structural = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_is_structural IS INITIAL.
          &lt;master&gt;-hot_is_structural = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_original_language &lt;&gt; &lt;master&gt;-hot_original_language.
        IF &lt;master&gt;-hana_original_language IS INITIAL.
          &lt;master&gt;-hana_original_language = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_original_language IS INITIAL.
          &lt;master&gt;-hot_original_language = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_responsible &lt;&gt; &lt;master&gt;-hot_responsible.
        IF &lt;master&gt;-hana_responsible IS INITIAL.
          &lt;master&gt;-hana_responsible = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_responsible IS INITIAL.
          &lt;master&gt;-hot_responsible = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_src_system &lt;&gt; &lt;master&gt;-hot_src_system.
        IF &lt;master&gt;-hana_src_system IS INITIAL.
          &lt;master&gt;-hana_src_system = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_src_system IS INITIAL.
          &lt;master&gt;-hot_src_system = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_src_tenant &lt;&gt; &lt;master&gt;-hot_src_tenant.
        IF &lt;master&gt;-hana_src_tenant IS INITIAL.
          &lt;master&gt;-hana_src_tenant = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_src_tenant IS INITIAL.
          &lt;master&gt;-hot_src_tenant = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_text_collection &lt;&gt; &lt;master&gt;-hot_text_collection.
        IF &lt;master&gt;-hana_text_collection IS INITIAL.
          &lt;master&gt;-hana_text_collection = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_text_collection IS INITIAL.
          &lt;master&gt;-hot_text_collection = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_text_status &lt;&gt; &lt;master&gt;-hot_text_status.
        IF &lt;master&gt;-hana_text_status IS INITIAL.
          &lt;master&gt;-hana_text_status = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_text_status IS INITIAL.
          &lt;master&gt;-hot_text_status = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-hana_text_terminology_domain &lt;&gt; &lt;master&gt;-hot_text_terminology_domain.
        IF &lt;master&gt;-hana_text_terminology_domain IS INITIAL.
          &lt;master&gt;-hana_text_terminology_domain = &apos;&lt;unbekannt&gt;&apos;(129).
        ELSEIF &lt;master&gt;-hot_text_terminology_domain IS INITIAL.
          &lt;master&gt;-hot_text_terminology_domain = &apos;&lt;unbekannt&gt;&apos;(129).
        ENDIF.
      ENDIF.

      IF &lt;master&gt;-exists_in_hota = abap_false.
        &lt;master&gt;-hot_hana_package_id = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;master&gt;-devclass = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;master&gt;-hot_abap_synced_at = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;master&gt;-hot_abap_synced_by = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;master&gt;-hot_abap_sync_system = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;master&gt;-hot_status_as_text = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;master&gt;-hot_deploy_mode_as_text = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;master&gt;-abap_translation_as_text = &apos;&lt;unbekannt&gt;&apos;(129).
      ELSE.
        CASE &lt;master&gt;-hot_status.
          WHEN if_cts_hot_db_access=&gt;co_hot_status_new.
            &lt;master&gt;-hot_status_as_text = &apos;N - Status gesetzt von Synchronisierung. Kann nicht deployt werden&apos;(160).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted.
            &lt;master&gt;-hot_status_as_text = &apos;D - Wird beim Deployment gelöscht&apos;(161).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_inactive.
            &lt;master&gt;-hot_status_as_text = &apos;I - Noch nicht ins SAP HANA Repository deployt&apos;(162).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_active.
            &lt;master&gt;-hot_status_as_text = &apos;A - Ins SAP HANA Repository deployt&apos;(163).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_deploy_error.
            &lt;master&gt;-hot_status_as_text = &apos;E - Deployment ins SAP HANA Repository fehlgeschlagen&apos;(243).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_delete_error.
            &lt;master&gt;-hot_status_as_text = &apos;Z - Löschung im SAP HANA Repository fehlgeschlagen&apos;(244).
        ENDCASE.

        CASE &lt;master&gt;-hot_deploy_mode.
          WHEN &apos; &apos; OR if_cts_hot_db_access=&gt;co_hot_deploy_mode_always.
            &lt;master&gt;-hot_deploy_mode_as_text = &apos;A - Paket und zugehörige Objekte werden beim Import direkt deployt&apos;(169).
          WHEN if_cts_hot_db_access=&gt;co_hot_deploy_mode_prework.
            &lt;master&gt;-hot_deploy_mode_as_text = &apos;P - Paket und zugehörige Objekte werden nur nach erfolgter Vorarbeit deployt&apos;(170).
        ENDCASE.
        CASE &lt;master&gt;-abap_no_translation.
          WHEN if_cts_hot_db_access=&gt;co_hot_relevant_for_transl. &quot; &apos; &apos;
            &lt;master&gt;-abap_translation_as_text = &apos;Paket und zugehörige Objekte sind relevant für Übersetzung&apos;(197).
          WHEN if_cts_hot_db_access=&gt;co_hot_not_relevant_for_transl. &quot; &apos;X&apos;
            &lt;master&gt;-abap_translation_as_text = &apos;Paket und zugehörige Objekte sind nicht relevant für Übersetzung&apos;(198).
        ENDCASE.
      ENDIF.

      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_description CHANGING c_length = mv_max_length_pack_desc ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_description CHANGING c_length = mv_max_length_pack_desc ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_delivery_unit CHANGING c_length = mv_max_length_pack_du_name ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_delivery_unit CHANGING c_length = mv_max_length_pack_du_name ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_delivery_unit_vendor CHANGING c_length = mv_max_length_pack_du_vendor ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_delivery_unit_vendor CHANGING c_length = mv_max_length_pack_du_vendor ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_hints_for_translation CHANGING c_length = mv_max_length_pack_hint ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_hints_for_translation CHANGING c_length = mv_max_length_pack_hint ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_responsible CHANGING c_length = mv_max_length_pack_responsible ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_responsible CHANGING c_length = mv_max_length_pack_responsible ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_src_system CHANGING c_length = mv_max_length_pack_src_system ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_src_system CHANGING c_length = mv_max_length_pack_src_system ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_src_tenant CHANGING c_length = mv_max_length_pack_src_tenant ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_src_tenant CHANGING c_length = mv_max_length_pack_src_tenant ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_text_collection CHANGING c_length = mv_max_length_pack_text_coll ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_text_collection CHANGING c_length = mv_max_length_pack_text_coll ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_text_terminology_domain CHANGING c_length = mv_max_length_pack_text_domain ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_text_terminology_domain CHANGING c_length = mv_max_length_pack_text_domain ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hana_text_status CHANGING c_length = mv_max_length_pack_text_status ).
      set_max_length( EXPORTING i_text = &lt;master&gt;-hot_text_status CHANGING c_length = mv_max_length_pack_text_status ).
    ENDLOOP.

    LOOP AT mt_slave ASSIGNING FIELD-SYMBOL(&lt;slave&gt;).
      IF &lt;slave&gt;-exists_in_hana = abap_false.
        &quot;usually not possible
        &lt;slave&gt;-hana_package_id = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hana_object_name = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hana_object_suffix = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hana_activated_at = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hana_activated_by = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hana_hana_read_system = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hana_version = &apos;&lt;unbekannt&gt;&apos;(129). &quot;Stephan
      ENDIF.

      IF &lt;slave&gt;-exists_in_hota = abap_false.
        &lt;slave&gt;-hot_hana_package_id = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_hana_object_name = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_hana_object_suffix = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_hana_read_system = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_activated_at = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_activated_by = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_abap_synced_at = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_abap_synced_by = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_abap_sync_system = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_status_as_text = &apos;&lt;unbekannt&gt;&apos;(129).
        &lt;slave&gt;-hot_version = &apos;&lt;unbekannt&gt;&apos;(129).
      ELSE.
        CASE &lt;slave&gt;-hot_status.
          WHEN if_cts_hot_db_access=&gt;co_hot_status_new.
            &lt;slave&gt;-hot_status_as_text = &apos;N - Status set by synchronization. Cannot be deployed.&apos;(160).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted.
            &lt;slave&gt;-hot_status_as_text = &apos;D - Deleted in deployment&apos;(161).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_inactive.
            &lt;slave&gt;-hot_status_as_text = &apos;I - Not yet deployed to SAP HANA repository&apos;(162).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_active.
            &lt;slave&gt;-hot_status_as_text = &apos;A - Deployed to SAP HANA repository&apos;(163).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_deploy_error.
            &lt;slave&gt;-hot_status_as_text = &apos;E - Deployment to SAP HANA Repository failed&apos;(243).
          WHEN if_cts_hot_db_access=&gt;co_hot_status_delete_error.
            &lt;slave&gt;-hot_status_as_text = &apos;Z Z - Deletion in SAP HANA Repository failed&apos;(244).
        ENDCASE.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD set_column_length.

    IF i_max_length &lt; i_min_length.
      i_column-&gt;set_output_length( i_min_length ).
    ELSE.
      i_column-&gt;set_output_length( i_max_length ).
    ENDIF.

  ENDMETHOD.


  METHOD find_package_with_diffrnt_case.

    CLEAR r_hana_package_id.

    DATA(lr_package_api) = cl_nhi_api=&gt;create_instance( )-&gt;get_package( ).
    DATA(lv_hot_hana_package_id_upper) = to_upper( i_hot_hana_package_id ).
    DATA(lv_hota_length) = strlen( lv_hot_hana_package_id_upper ).
    DATA(lr_exists_response) = lr_package_api-&gt;exists(
          lr_package_api-&gt;create_exists_package_req(
                tenant = &apos;&apos;
                package = i_hot_hana_package_id
                ignore_case = abap_true ) ).
*        CATCH cx_nhi_hana_repository.    &quot; .

    &quot;1. check if package exists at all in different case
    IF lr_exists_response-&gt;error_code IS INITIAL AND lr_exists_response-&gt;exists = abap_true.
      &quot;2. if package exists check for spelling (TODO: explain more clearly)
      &quot;    - compare rootpackages in uppercase with first n chars of input package in upper case (n = length of current rootpackage)
      &quot;    - if root package was found, get its sub packages and compare again in upper case mode.
      &quot;    - redo get sub packages until package was found
      DATA(lr_root_package_response) = lr_package_api-&gt;list_root_packages( lr_package_api-&gt;create_list_root_packages_req( tenant = &apos;&apos; ) ).
*        CATCH cx_nhi_hana_repository.    &quot; .
      IF lr_root_package_response-&gt;error_code = &apos;0&apos;.
        LOOP AT lr_root_package_response-&gt;rootpackages ASSIGNING FIELD-SYMBOL(&lt;root_package&gt;).
          DATA(lv_hanap_length) = strlen( &lt;root_package&gt;-&gt;package ).
          IF lv_hota_length = lv_hanap_length AND lv_hot_hana_package_id_upper = to_upper( &lt;root_package&gt;-&gt;package ).
            r_hana_package_id = &lt;root_package&gt;-&gt;package.
            EXIT. &quot;we found our package, exit loop &quot;Test-done
*          ELSEIF lv_hota_length &gt;= lv_hanap_length AND lv_hot_hana_package_id_upper(lv_hanap_length) = to_upper( &lt;root_package&gt;-&gt;package ) AND &quot;TODO: why lv_hota_length &gt;= lv_hanap_length and not lv_hota_length &gt; lv_hanap_length ?
          ELSEIF lv_hota_length &gt; lv_hanap_length AND lv_hot_hana_package_id_upper(lv_hanap_length) = to_upper( &lt;root_package&gt;-&gt;package ) AND
                 lv_hot_hana_package_id_upper+lv_hanap_length(1) = &apos;.&apos;. &quot; &apos;.&apos; is delimeter between package and sub package
            DATA(lv_package) = &lt;root_package&gt;-&gt;package.
            WHILE r_hana_package_id IS INITIAL.
              DATA(lr_get_sub_packages_response) = lr_package_api-&gt;get_sub_packages( lr_package_api-&gt;create_get_sub_packages_req( package = lv_package ) ).
*               CATCH cx_nhi_hana_repository.    &quot;
              IF lr_get_sub_packages_response-&gt;error_code = &apos;0&apos;.
                IF lr_get_sub_packages_response-&gt;subpackages IS INITIAL.
                  EXIT. &quot;TODO: test
                ENDIF.
                LOOP AT lr_get_sub_packages_response-&gt;subpackages ASSIGNING FIELD-SYMBOL(&lt;sub_package&gt;).
                  lv_hanap_length = strlen( &lt;sub_package&gt;-&gt;package ).
                  IF lv_hota_length = lv_hanap_length AND lv_hot_hana_package_id_upper = to_upper( &lt;sub_package&gt;-&gt;package ).
                    r_hana_package_id = &lt;sub_package&gt;-&gt;package.
                    EXIT. &quot;we found our package, exit loop &quot;Test-done
                  ELSEIF lv_hota_length &gt;= lv_hanap_length AND lv_hot_hana_package_id_upper(lv_hanap_length) = to_upper( &lt;sub_package&gt;-&gt;package ) AND
                         lv_hot_hana_package_id_upper+lv_hanap_length(1) = &apos;.&apos;.
                    lv_package = &lt;sub_package&gt;-&gt;package.
                    EXIT. &quot;exit loop and continue while loop with found package &quot;Test-done
                  ENDIF.
                ENDLOOP.
              ELSE.
                &quot;##todo error handling
                EXIT.
              ENDIF.
            ENDWHILE.
            EXIT. &quot;end loop because we found root package &quot;Test-done
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD append_change_color.

    DATA ls_color TYPE lvc_s_scol.

    &quot;default setting for all color columns, blue and intensified
    ls_color-color-col = col_key.
    ls_color-color-int = 1.
    ls_color-color-inv = 0.

    ls_color-fname = i_name1.
    APPEND ls_color TO ch_color_table.

    IF i_name2 IS NOT INITIAL.
      ls_color-fname = i_name2.
      APPEND ls_color TO ch_color_table.
    ENDIF.

  ENDMETHOD.

  METHOD constructor.
    mr_hot_hana_connector = cl_cts_hot_hana_connector=&gt;create_instance( ).
    mr_external_calls = NEW cl_cts_hot_ext_call_intenal( ).
    CREATE OBJECT mr_data_provider TYPE lcl_data_provider.
  ENDMETHOD.

  METHOD refresh_data.
    DATA: lr_content     TYPE REF TO cl_salv_form_element,
          ls_filter_data TYPE ty_filter_data.
    TRY.
        &quot;first clear global data so that layout might be adapted as well
        CLEAR: mt_master,
               mt_slave,
               mv_max_length_devclass,
               mv_max_length_object_name,
               mv_max_length_object_suffix,
               mv_max_length_package_id,
               mv_max_length_pack_desc,
               mv_max_length_pack_du_name,
               mv_max_length_pack_du_vendor,
               mv_max_length_pack_hint,
               mv_max_length_pack_responsible,
               mv_max_length_pack_src_system,
               mv_max_length_pack_src_tenant,
               mv_max_length_pack_text_coll,
               mv_max_length_pack_text_domain,
               mv_max_length_pack_text_status,
               mv_any_object_not_ok_in_hana.

        ls_filter_data = ms_filter_data. &quot;preserve current filter settings

        select_data( i_hana_package_name = mv_search_string i_include_subpackages = mv_include_subpackages ).

        handle_dynamic_columns( ).

        SORT mt_master BY package_id ASCENDING.
        SORT mt_slave BY abap_hana_package_id object_name ASCENDING.

        preselect_all_out_of_sync( ).

*       in case number of packages/objects has been changed, top of list has to be changed as well
        build_header( CHANGING cr_content = lr_content ).
        mr_hierseq-&gt;set_top_of_list( lr_content ).

*... refresh the table in order to see the new data
        mr_hierseq-&gt;refresh( ).

        apply_filter(
            i_green    = ls_filter_data-show_green
            i_yellow   = ls_filter_data-show_yellow
            i_red      = ls_filter_data-show_red
            i_inactive = ls_filter_data-show_inactive
        ).
      CATCH cx_hana_object_transport INTO DATA(hot_exc).
        DATA(t100_key) = hot_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH hot_exc-&gt;msgv1 hot_exc-&gt;msgv2 hot_exc-&gt;hana_error_code hot_exc-&gt;hana_error_msg.
      CATCH cx_nhi_hana_repository INTO DATA(nhi_exc).
        t100_key = nhi_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4.
    ENDTRY.

  ENDMETHOD.

  METHOD show_versioning_for_currnt_cll.

    DATA: lr_selections TYPE REF TO cl_salv_selections,
          ls_cell       TYPE salv_s_cell,
          lt_rows       TYPE salv_t_row,
          ls_row        TYPE i,
          lv_obj_type   TYPE vrsd-objtype,
          lv_obj_name   TYPE vrsd-objname.

*...get cell of cursor in packages.
    TRY.
        ls_cell = mr_hierseq-&gt;get_selections( 1 )-&gt;get_current_cell( ).
        IF ls_cell IS NOT INITIAL.
          lv_obj_type = &apos;HOTP&apos;.
          lv_obj_name = mt_master[ ls_cell-row ]-transport_obj_name.
        ENDIF.
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

*...get cell of cursor in objects if it was not in packages.
    IF lv_obj_type IS INITIAL.
      TRY.
          ls_cell = mr_hierseq-&gt;get_selections( 2 )-&gt;get_current_cell( ).
          IF ls_cell IS NOT INITIAL.
            lv_obj_type = &apos;HOTO&apos;.
            lv_obj_name = mt_slave[ ls_cell-row ]-transport_obj_name.
          ENDIF.
        CATCH cx_salv_not_found INTO exc.
          &quot;should not happen because we always have 2 levels of data
          ls_msg = exc-&gt;get_message( ).
          MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
      ENDTRY.
    ENDIF.

    IF lv_obj_type IS INITIAL.
      MESSAGE &apos;Zur Anzeige der Versionsverwaltung müssen Sie den Cursor in eine Paket- oder Objektzeile setzen&apos;(164) TYPE &apos;S&apos;.
      RETURN.
    ENDIF.

    CALL FUNCTION &apos;SVRS_DISPLAY_DIRECTORY_NEW&apos;
      EXPORTING
        object_type  = lv_obj_type   &quot; Objekttyp (REPS, TABD, ...)
        object_name  = lv_obj_name   &quot; Objektname
        recall       = &apos; &apos;    &quot; &apos;X&apos; Version zurueckholen wird angeboten
      EXCEPTIONS
        no_directory = 1
        OTHERS       = 2.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

  ENDMETHOD.


  METHOD append_hana_objcts_to_mt_slave.

    DATA: ls_slave  TYPE g_type_s_slave.

    LOOP AT i_hana_objects INTO DATA(lr_hana_object).
      DATA(lo_cts_hot_object) = cl_cts_hot_object_v1=&gt;create_instance2(
                                  io_cts_hot_package = i_master-&gt;cts_hot_package_ref
                                  iv_hana_object_name = lr_hana_object-&gt;name
                                  iv_hana_object_suffix = lr_hana_object-&gt;suffix ).
      CLEAR ls_slave.
      ls_slave-abap_hana_package_id = i_master-&gt;transport_obj_name.
      ls_slave-object_name = lr_hana_object-&gt;name.
      ls_slave-object_suffix = lr_hana_object-&gt;suffix.
      ls_slave-hana_package_id = i_master-&gt;hana_package_id.
      ls_slave-hana_object_name = lr_hana_object-&gt;name.
      ls_slave-hana_object_suffix = lr_hana_object-&gt;suffix.
      ls_slave-cts_hot_object_ref = lo_cts_hot_object.
      ls_slave-transport_obj_name = lo_cts_hot_object-&gt;transport_object_name.
      ls_slave-hana_version = lr_hana_object-&gt;metadata-&gt;version_id.
      ls_slave-hana_activated_by = CAST cl_nhi_metadata_active_ver( lr_hana_object-&gt;metadata )-&gt;activated_by.
      ls_slave-hana_activated_at = create_local_time_string( conv_hana_actvted_at_to_timest( CAST cl_nhi_metadata_active_ver( lr_hana_object-&gt;metadata )-&gt;activated_at ) ).
      ls_slave-sync_deploy_state = icon_light_out.
      ls_slave-exists_in_hana = abap_true.
      ls_slave-hana_object_status = i_object_status.

      APPEND ls_slave TO mt_slave.

      set_max_length( EXPORTING i_text = ls_slave-hana_object_name CHANGING c_length = mv_max_length_object_name ).
      set_max_length( EXPORTING i_text = ls_slave-hana_object_suffix CHANGING c_length = mv_max_length_object_suffix ).
    ENDLOOP.

  ENDMETHOD.

  METHOD handle_dynamic_columns.

    TRY.
        &quot;get columns for objects
        DATA(lr_columns) = mr_hierseq-&gt;get_columns( 2 ).

        &quot;set column HANA_OBJECT_STATUS to invisible if all objects are OK but only in sync UI, always show in deploy UI
        DATA(lr_column) = lr_columns-&gt;get_column( &apos;HANA_OBJECT_STATUS&apos; ).
        IF mv_any_object_not_ok_in_hana IS INITIAL AND gv_sync = &apos;X&apos;.
          lr_column-&gt;set_visible( if_salv_c_bool_sap=&gt;false ).
        ELSE.
          lr_column-&gt;set_visible( ).
        ENDIF.
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.

  METHOD hide_name_columns.

    DATA: lv_current_cell TYPE salv_s_cell.

    TRY.
        lv_current_cell = mr_hierseq-&gt;get_selections( 1 )-&gt;get_current_cell( ).

        IF lv_current_cell IS NOT INITIAL.
          &quot;package selected
          CLEAR mt_master[ lv_current_cell-row ]-package_id.
        ELSE.
          &quot;object selected?
          lv_current_cell = mr_hierseq-&gt;get_selections( 2 )-&gt;get_current_cell( ).

          IF lv_current_cell IS NOT INITIAL.
            &quot;object selected?
            CLEAR mt_slave[ lv_current_cell-row ]-object_name.
            CLEAR mt_slave[ lv_current_cell-row ]-object_suffix.
          ELSE.
            &quot;nothing selected...
          ENDIF.
        ENDIF.
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.


  METHOD show_name_columns.

    DATA: lv_current_cell TYPE salv_s_cell.

    TRY.
        lv_current_cell = mr_hierseq-&gt;get_selections( 1 )-&gt;get_current_cell( ).

        IF lv_current_cell IS NOT INITIAL.
          &quot;package was selected
          DATA(ls_master) = mt_master[ lv_current_cell-row ].
          IF ls_master-exists_in_hana = abap_true.
            mt_master[ lv_current_cell-row ]-package_id = ls_master-hana_package_id.
          ELSEIF ls_master-exists_in_hota = abap_true.
            mt_master[ lv_current_cell-row ]-package_id = ls_master-hot_hana_package_id.
          ENDIF.
        ELSE.
          &quot;object selected?
          lv_current_cell = mr_hierseq-&gt;get_selections( 2 )-&gt;get_current_cell( ).

          IF lv_current_cell IS NOT INITIAL.
            &quot;object selected?
            DATA(ls_slave) = mt_slave[ lv_current_cell-row ].
            IF ls_slave-exists_in_hana = abap_true.
              mt_slave[ lv_current_cell-row ]-object_name = ls_slave-hana_object_name.
              mt_slave[ lv_current_cell-row ]-object_suffix = ls_slave-hana_object_suffix.
            ELSEIF ls_slave-exists_in_hota = abap_true.
              mt_slave[ lv_current_cell-row ]-object_name = ls_slave-hot_hana_object_name.
              mt_slave[ lv_current_cell-row ]-object_suffix = ls_slave-hot_hana_object_suffix.
            ENDIF.
          ELSE.
            &quot;nothing selected...
          ENDIF.
        ENDIF.
      CATCH cx_salv_not_found INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.


  METHOD set_max_length.

    DATA: lv_length TYPE i.

    lv_length = strlen( i_text ).
    IF lv_length &gt; c_length.
      c_length = lv_length.
    ENDIF.

  ENDMETHOD.

  METHOD append_packages_to_mt_master.

    DATA: lr_cts_hot_package TYPE REF TO cl_cts_hot_package,
          ls_master          TYPE g_type_s_master.

    LOOP AT i_package_names_hana INTO DATA(lv_package_name_hana).
      &quot;create cl_cts_hotpackage to get abap_hana_packageid, the key for HOTA
      lr_cts_hot_package = cl_cts_hot_package=&gt;create_instance( lv_package_name_hana ).

      CLEAR ls_master.
      ls_master-package_id = lv_package_name_hana.
      ls_master-hana_package_id = lv_package_name_hana.
      ls_master-cts_hot_package_ref = lr_cts_hot_package.
      ls_master-transport_obj_name = lr_cts_hot_package-&gt;abap_hana_package_id.
      ls_master-exists_in_hana = abap_true.
      APPEND ls_master TO mt_master.

      set_max_length( EXPORTING i_text = lv_package_name_hana CHANGING c_length = mv_max_length_package_id ).
    ENDLOOP.

    &quot;add all packages found in HOTA to mt_master but do not duplicate if package was already in HANA, only set HOTA exists then
    LOOP AT i_package_names_hot INTO DATA(lv_package_name_hot).
      &quot;create cl_cts_hotpackage to get abap_hana_package_id, the key for HOTA
      lr_cts_hot_package = cl_cts_hot_package=&gt;create_instance( lv_package_name_hot ).

      READ TABLE mt_master ASSIGNING FIELD-SYMBOL(&lt;master&gt;) WITH KEY transport_obj_name = lr_cts_hot_package-&gt;abap_hana_package_id.
      IF sy-subrc = 0.
        &lt;master&gt;-exists_in_hota = abap_true.
        &lt;master&gt;-hot_hana_package_id = lv_package_name_hot.
      ELSE.
        CLEAR ls_master.
        ls_master-package_id = lv_package_name_hot.
        ls_master-hot_hana_package_id = lv_package_name_hot.
        ls_master-cts_hot_package_ref = lr_cts_hot_package.
        ls_master-transport_obj_name = lr_cts_hot_package-&gt;abap_hana_package_id.
        ls_master-exists_in_hota = abap_true.
        ls_master-exists_in_hana = abap_false.
        APPEND ls_master TO mt_master.

        set_max_length( EXPORTING i_text = lv_package_name_hot CHANGING c_length = mv_max_length_package_id ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD check_packgs_for_diffrnt_cases.

    DATA lv_db_read_done TYPE abap_bool. &quot;to only read from DB once and only in case there is data with exists_in_hota = abap_false

    &quot;for all packages that are in HANA but not in HOTA check if they exist with different name in HOTA
    &quot;1. get all hana_package_ids from HOTA (only once)
    &quot;2. for all packages not in HOTA check for different name in HOT
    LOOP AT mt_master ASSIGNING FIELD-SYMBOL(&lt;master&gt;) WHERE exists_in_hota = abap_false.
      IF lv_db_read_done = abap_false.
        SELECT abap_hana_package_id, hana_package_id FROM cts_hot_package INTO TABLE @DATA(lt_all_hot_packages) WHERE abap_status = &apos;A&apos;.
        lv_db_read_done = abap_true.
      ENDIF.

      READ TABLE lt_all_hot_packages WITH KEY abap_hana_package_id = &lt;master&gt;-transport_obj_name ASSIGNING FIELD-SYMBOL(&lt;hot_package&gt;).
*      SELECT SINGLE hana_package_id FROM cts_hot_package INTO lr_master-&gt;hot_hana_package_id WHERE abap_hana_package_id = lr_master-&gt;transport_obj_name AND abap_status = &apos;A&apos;.
      IF sy-subrc = 0.
        &lt;master&gt;-exists_in_hota = abap_true.
        IF &lt;master&gt;-hana_package_id &lt;&gt; &lt;hot_package&gt;-hana_package_id.
          &lt;master&gt;-hot_hana_package_id = &lt;hot_package&gt;-hana_package_id.
        ENDIF.
      ENDIF.
    ENDLOOP.

    &quot;for all packages that are not in HANA but in HOTA search for different cases in HANA
    LOOP AT mt_master ASSIGNING &lt;master&gt; WHERE exists_in_hota = abap_true AND exists_in_hana = abap_false.
      DATA(tmp_hana_package_id) = find_package_with_diffrnt_case( &lt;master&gt;-hot_hana_package_id ).
      IF tmp_hana_package_id IS NOT INITIAL.
        &lt;master&gt;-hana_package_id = tmp_hana_package_id.
        &lt;master&gt;-exists_in_hana = abap_true.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD set_tooltips.

    DATA:
      lr_tooltips TYPE REF TO cl_salv_tooltips,
      l_value     TYPE lvc_value.

    TRY.
        IF gv_sync = &apos;X&apos;.
          lr_tooltips = mr_hierseq-&gt;get_functional_settings( )-&gt;get_tooltips( ).
          l_value = icon_led_green.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt ist in sync&apos;(143) ) ).
          l_value = icon_led_yellow.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt ist nicht in sync&apos;(144) ) ).
          l_value = icon_led_inactive.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt kann nicht synchron. werden&apos;(145)  ) ).
          l_value = icon_led_red.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt kann nicht synchron. werden&apos;(145) ) ).
        ELSEIF gv_depl = &apos;X&apos;.
          lr_tooltips = mr_hierseq-&gt;get_functional_settings( )-&gt;get_tooltips( ).
          l_value = icon_led_green.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt ist deployt&apos;(230) ) ).
          l_value = icon_led_yellow.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt ist nicht deployt&apos;(211) ) ).
          l_value = icon_led_inactive.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt kann nicht deployt werden&apos;(212) ) ).
          l_value = icon_led_red.
          lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Paket/Objekt kann nicht deployt werden&apos;(212) ) ).
        ENDIF.
        l_value = icon_alert.
        lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Objekt ist defekt&apos;(146) ) ).
        l_value = icon_okay.
        lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Objekt ist OK&apos;(147) ) ).
        l_value = icon_generate.
        lr_tooltips-&gt;add_tooltip( type = cl_salv_tooltip=&gt;c_type_icon value = l_value tooltip = conv LVC_TIP( &apos;Objekt muss neu generiert werden&apos;(148) ) ).
      CATCH cx_salv_existing INTO DATA(exc).
        &quot;should not happen because we always have 2 levels of data
        DATA(ls_msg) = exc-&gt;get_message( ).
        MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
    ENDTRY.

  ENDMETHOD.


  METHOD set_column_long_text.

    DATA: lv_old_text TYPE scrtext_l,
          lv_new_text TYPE string,
          lv_pos      TYPE i.

    lv_new_text = i_text_template.
    lv_old_text = i_column-&gt;get_long_text( ).

    IF strlen( lv_old_text ) &gt; 40 - strlen( i_text_template ).
      lv_pos = 40 - strlen( i_text_template ) - 1. &quot;-1 because of the &apos;.&apos; that we add
      lv_old_text = lv_old_text(lv_pos) &amp;&amp; &apos;.&apos;.
    ENDIF.

    REPLACE &apos;&amp;1&apos; IN lv_new_text WITH lv_old_text.
    i_column-&gt;set_long_text( CONV #( lv_new_text ) ).

  ENDMETHOD.

  METHOD build_header.
    DATA: lv_text     TYPE string,
          lv_tmp_text TYPE string,
          lv_filter   TYPE string,
          lv_info     TYPE string.

    IF me-&gt;is_data_filtered( ) = abap_true.
      lv_filter = &apos;   Filter aktiv&apos;(233).
    ENDIF.

    IF mv_include_subpackages = abap_true.
      lv_info = &apos;Display for&apos;&apos;&amp;1&apos;&apos; with subpackages &amp;2 packages/&amp;3 objects&apos;(133).
    ELSE.
      lv_info = &apos;Display for &apos;&apos;&amp;1&apos;&apos;: &amp;2 packages/&amp;3 objects&apos;(152).
    ENDIF.
    REPLACE &apos;&amp;1&apos; IN lv_info WITH mv_search_string.
    lv_tmp_text = lines( mt_master ).
    CONDENSE lv_tmp_text.
    REPLACE &apos;&amp;2&apos; IN lv_info WITH lv_tmp_text.
    lv_tmp_text = lines( mt_slave ).
    CONDENSE lv_tmp_text.
    REPLACE &apos;&amp;3&apos; IN lv_info WITH lv_tmp_text.
    CONCATENATE lv_info lv_filter INTO lv_text.
    CREATE OBJECT cr_content TYPE cl_salv_form_text
      EXPORTING
        text    = lv_text
        tooltip = lv_text.
  ENDMETHOD.


  METHOD deploy.
    DATA: lr_selections         TYPE REF TO cl_salv_selections,
          lt_rows               TYPE salv_t_row,
          l_row                 TYPE i,
          lv_text               TYPE string,
          lv_popup_question     TYPE string,
          lv_popup_answer       TYPE c LENGTH 1,
          lv_force_deploy       TYPE abap_bool VALUE abap_false,
          lv_ask_for_force_depl TYPE abap_bool VALUE abap_false. &quot;indicates whether user should be asked for force deployment or not (user gets asked if at least one selected package/object has hot_stauts = &apos;A&apos;)

    AUTHORITY-CHECK OBJECT &apos;S_DEVELOP&apos; ID &apos;ACTVT&apos; FIELD &apos;07&apos; ID &apos;OBJTYPE&apos; FIELD &apos;HOTA&apos; ID &apos;OBJNAME&apos; DUMMY ID &apos;DEVCLASS&apos; DUMMY ID &apos;P_GROUP&apos; DUMMY.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID &apos;SCTS_HOT&apos; TYPE&apos;E&apos; NUMBER &apos;031&apos;.
      RETURN.
    ENDIF.

    TRY.
        DATA(lr_hta_api) = cl_cts_hta_api_factory=&gt;create_instance( ).
        DATA(lr_deploy_list) = lr_hta_api-&gt;create_component_list( ).

        me-&gt;get_selected_data(
          IMPORTING
            e_hotp_packages = DATA(lt_hotps)
            e_hota_packages = DATA(lt_hotas)
            e_hoto_objects = DATA(lt_hotos)
            e_hota_objects = DATA(lt_hotos_hota)
        ).

        &quot;for deployment we only care about hotps and hotos and not HOTAs
        APPEND LINES OF lt_hotas TO lt_hotps.
        APPEND LINES OF lt_hotos_hota TO lt_hotos.
        FREE: lt_hotas, lt_hotos_hota.

        IF lt_hotps IS INITIAL AND lt_hotos IS INITIAL.
          MESSAGE &apos;Deployment nicht möglich; markieren Sie Einträge mit gelbem oder grünem Status&apos;(135) TYPE &apos;S&apos;.
          RETURN.
        ENDIF.

        LOOP AT lt_hotps INTO DATA(lr_package).
          IF lv_ask_for_force_depl = abap_false
             AND line_exists( mt_master[ transport_obj_name = lr_package-&gt;abap_hana_package_id sync_deploy_state = icon_led_green ] ).
            lv_ask_for_force_depl = abap_true.
          ENDIF.

          lr_deploy_list-&gt;add_component( lr_hta_api-&gt;create_package_by_trobj_name( CONV #( lr_package-&gt;abap_hana_package_id ) ) ).
        ENDLOOP.

        LOOP AT lt_hotos INTO DATA(lr_object).
          IF lv_ask_for_force_depl = abap_false
               AND line_exists( mt_slave[ transport_obj_name = lr_object-&gt;transport_object_name sync_deploy_state = icon_led_green ] ).
            lv_ask_for_force_depl = abap_true.
          ENDIF.

          lr_deploy_list-&gt;add_component( lr_hta_api-&gt;create_object_by_trobj_name( CONV #( lr_object-&gt;transport_object_name ) ) ).
        ENDLOOP.

        IF lv_ask_for_force_depl = abap_true.
          lv_popup_question = &apos;Sie haben ein oder mehrere Pakete/Objekte selektiert, die bereits deployt wurden. Sollen diese erneut deployt werden?&apos;(206).

          CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
            EXPORTING
              titlebar              = &apos;Pakete/Objekte erneut deployen&apos;(207)    &quot; Titel des Popup* Laenge 60
              text_question         = lv_popup_question    &quot; Fragetext im Popup
              text_button_1         = &apos;Ja&apos;(192)      &quot; Text auf der ersten Drucktaste - 12 Zeichen
              text_button_2         = &apos;Nein&apos;(193)    &quot; Text auf der zweiten Drucktaste
              default_button        = &apos;1&apos;    &quot; Cursorposition
              display_cancel_button = &apos;X&apos;    &quot; Schalter,ob Abbrechen-Drucktaste angezeigt wird
              userdefined_f1_help   = &apos;CTS_HTA_FORCE_DEPLOY_F1&apos;    &quot; Benutzerdefinierte F1-Hilfe
            IMPORTING
              answer                = lv_popup_answer   &quot; Rückgabewerte: &apos;1&apos;, &apos;2&apos;, &apos;A&apos;
            EXCEPTIONS
              OTHERS                = 1.

          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.

          IF lv_popup_answer = &apos;1&apos;.
            lv_force_deploy = abap_true.

          ELSEIF lv_popup_answer = &apos;2&apos;.
            DATA: lv_onlygreen_or_nopacks_selctd TYPE c VALUE &apos;X&apos;,
                  lv_onlygreen_or_noobjs_selctd  TYPE c VALUE &apos;X&apos;.
            LOOP AT lt_hotps INTO lr_package.
              IF NOT line_exists( mt_master[ transport_obj_name = lr_package-&gt;abap_hana_package_id sync_deploy_state = icon_led_green ] ).
                CLEAR lv_onlygreen_or_nopacks_selctd.
                EXIT.
              ELSE.
*               todo: in future lr_deploy_list-&gt;remove_component that shall not be deployed a second time
*                lr_deploy_list-&gt;remove_component( lr_hta_api-&gt;create_package_by_trobj_name( CONV #( lr_package-&gt;abap_hana_package_id ) ) ).
              ENDIF.
            ENDLOOP.

            LOOP AT lt_hotos INTO lr_object.
              IF NOT line_exists( mt_slave[ transport_obj_name = lr_object-&gt;transport_object_name sync_deploy_state = icon_led_green ] ).
                CLEAR lv_onlygreen_or_noobjs_selctd.
                EXIT.
              ELSE.
*               todo: in future lr_deploy_list-&gt;remove_component that shall not be deployed a second time
*                lr_deploy_list-&gt;remove_component( lr_hta_api-&gt;create_object_by_trobj_name( CONV #( lr_object-&gt;transport_object_name ) ) ).
              ENDIF.
            ENDLOOP.

            IF lv_onlygreen_or_nopacks_selctd = &apos;X&apos; AND lv_onlygreen_or_noobjs_selctd = &apos;X&apos;.
              MESSAGE &apos;Packagees/objects that were already deployed have not been deployed again&apos;(239) TYPE &apos;S&apos;.
              RETURN.
            ENDIF.

          ELSEIF lv_popup_answer = &apos;A&apos;.
            MESSAGE &apos;Action canceled by user&apos;(159) TYPE &apos;E&apos;.
            &quot;Ende Programmausfuehrung
          ENDIF.
        ENDIF.

        lr_deploy_list-&gt;deploy( EXPORTING i_force = lv_force_deploy
                                IMPORTING e_overall_deploy_status = DATA(lv_deploy_status)
                                          e_deploy_messages       = DATA(lt_deploy_logs)
        ).

        DATA(lv_logname) = mr_external_calls-&gt;save_deploy_log_to_transdir( i_log_messages  = lt_deploy_logs
                                                                           i_log_name_prefix = &apos;HTA_MANUAL_ACTIVATION&apos; ).
        DATA(lv_level) = &apos;2&apos;.
        IF lv_deploy_status = &apos;I&apos;.
          lv_text = &apos;Erfolg&apos;(208).
        ELSEIF lv_deploy_status = &apos;W&apos;.
          lv_text = &apos;Warnung&apos;(203).
          lv_level = &apos;3&apos;.
        ELSEIF lv_deploy_status = &apos;E&apos;.
          lv_text = &apos;Fehler&apos;(209).
        ELSEIF lv_deploy_status = &apos;A&apos;.
          lv_text = &apos;Fataler Fehler&apos;(210).
        ENDIF.

        DATA(ls_splitted_text) = cl_cts_hot_utility=&gt;split_text_50_chars( CONV #( lv_logname ) ).
        MESSAGE ID &apos;SCTS_HOT&apos; TYPE &apos;S&apos; NUMBER &apos;030&apos; WITH lv_text ls_splitted_text-chunk1 ls_splitted_text-chunk2 ls_splitted_text-chunk3.


        mr_external_calls-&gt;display_deploy_log( i_log_messages = lt_deploy_logs
                                               i_heading = CONV #( lv_logname )
                                               i_level = CONV #( lv_level ) ).

        me-&gt;refresh_data( ).
      CATCH cx_hana_object_transport INTO DATA(hot_exc).
        MESSAGE ID hot_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER hot_exc-&gt;if_t100_message~t100key-msgno WITH hot_exc-&gt;msgv1 hot_exc-&gt;msgv2 hot_exc-&gt;hana_error_code hot_exc-&gt;hana_error_msg.
      CATCH cx_cts_hta INTO DATA(lr_hta_exc).
        MESSAGE ID lr_hta_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER lr_hta_exc-&gt;if_t100_message~t100key-msgno WITH lr_hta_exc-&gt;message_variable_1 lr_hta_exc-&gt;message_variable_2 lr_hta_exc-&gt;message_variable_3 lr_hta_exc-&gt;message_variable_4.
    ENDTRY.
  ENDMETHOD.

  METHOD set_deploy_mode.
    DATA: lv_popup_question     TYPE string,
          lv_popup_answer       TYPE c LENGTH 1,
          lv_target_deploy_mode TYPE cts_hot_activation_mode,
          lr_hot_package        TYPE REF TO cl_cts_hot_package,
          lr_master             TYPE REF TO g_type_s_master,
          lv_transport_request  TYPE trkorr,
          lv_transport_request2 TYPE trkorr,
          lv_count_changed_pkgs TYPE i,
          lv_text               TYPE string,
          lv_changed            TYPE abap_bool, &quot;indicates whether at least one deploy mode was changed
          lv_popup_p_to_a_shown TYPE abap_bool. &quot;indicates whether popup for change from prework to always was shown, to show only once

    TRY.
        get_selected_data( IMPORTING e_hotp_packages = DATA(lt_hotp_packages) e_hota_packages = DATA(lt_hota_packages) e_hota_objects = DATA(lt_hota_objects) e_hoto_objects = DATA(lt_hoto_objects) ).
        &quot;in this method we do not need to distinguish between hota and hotp
        APPEND LINES OF lt_hota_packages TO lt_hotp_packages.

        IF lt_hotp_packages IS INITIAL.
          MESSAGE &apos;Deploy mode cannot be set for packages selected. Select packages with status yellow or green.&apos;(171) TYPE &apos;S&apos;.
          RETURN.
        ENDIF.

        SORT lt_hotp_packages BY table_line-&gt;hana_package_id ASCENDING.

        lv_popup_question = &apos;Which deploy mode do you want to set for the selected packages?&apos;(172).

        CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
          EXPORTING
            titlebar              = &apos;Deploymodus festlegen&apos;(173)    &quot; Titel des Popup
            diagnose_object       = &apos;CTS_HTA_SYNC_UI_DEPLOY_MODE&apos;    &quot; Diagnosetext (Pflege über SE61)
            text_question         = lv_popup_question    &quot; Fragetext im Popup
            text_button_1         = &apos;Mode A&apos;(174)    &quot; Text auf der ersten Drucktaste - 12 Zeichen
*           icon_button_1         = &apos;ICON_CHECKED&apos;    &quot; Ikone auf der ersten Drucktaste - 12 Zeichen
            text_button_2         = &apos;Mode P&apos;(175)    &quot; Text auf der zweiten Drucktaste
*           icon_button_2         = &apos;ICON_CANCEL&apos;    &quot; Ikone auf der zweiten Drucktaste
            default_button        = &apos;1&apos;    &quot; Cursorposition
            display_cancel_button = &apos;X&apos;    &quot; Schalter,ob Abbrechen-Drucktaste angezeigt wird
            userdefined_f1_help   = &apos;CTS_HTA_SYNC_UI_DPL_MODE_F1&apos;    &quot; Benutzerdefinierte F1-Hilfe
*           start_column          =     &quot; Startspalte, in der das POPUP beginnt
*           start_row             =     &quot; Startzeile, in der das POPUP beginnt
*           popup_type            = &apos;ICON_MESSAGE_WARNING&apos;    &quot; Ikonentyp
            iv_quickinfo_button_1 = &apos;Mode A (Standard)&apos;(176)   &quot; Quickinfo auf der ersten Drucktaste
            iv_quickinfo_button_2 = &apos;Mode P (with prework)&apos;(177)    &quot; Quickinfo auf der zweiten Drucktaste
          IMPORTING
            answer                = lv_popup_answer   &quot; Rückgabewerte: &apos;1&apos;, &apos;2&apos;, &apos;A&apos;
*          TABLES
*           parameter             = lt_popup_params   &quot; Übergabetabelle für Parameter im Text
          EXCEPTIONS
            text_not_found        = 1
            OTHERS                = 2.
        IF sy-subrc &lt;&gt; 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.

        IF lv_popup_answer = &apos;1&apos;.
          lv_target_deploy_mode = if_cts_hot_db_access=&gt;co_hot_deploy_mode_always.
        ELSEIF lv_popup_answer = &apos;2&apos;.
          lv_target_deploy_mode = if_cts_hot_db_access=&gt;co_hot_deploy_mode_prework.
        ELSEIF lv_popup_answer = &apos;A&apos;.
          MESSAGE &apos;Action canceled by user&apos;(159) TYPE &apos;E&apos;.
          &quot;Ende Programmausfuehrung
        ENDIF.

        &quot;if target is P, which is not the default, check whether all packages are known in HTA so that P can be set at all.
        IF lv_target_deploy_mode = if_cts_hot_db_access=&gt;co_hot_deploy_mode_prework.
          LOOP AT lt_hotp_packages INTO lr_hot_package.
            READ TABLE mt_master REFERENCE INTO lr_master WITH KEY pack_ref COMPONENTS cts_hot_package_ref = lr_hot_package.
            IF sy-subrc = 0 AND lr_master-&gt;exists_in_hota = abap_false AND lv_target_deploy_mode = if_cts_hot_db_access=&gt;co_hot_deploy_mode_prework.
              MESSAGE &apos;Deploy mode only possible after initial synchronization. Perform synchronization first.&apos;(178) TYPE &apos;E&apos;.
              &quot;Ende Programmausfuehrung
            ENDIF.
          ENDLOOP.
        ENDIF.

        &quot;add package to TR and set deploy mode in case it is changed for some package
        LOOP AT lt_hotp_packages INTO lr_hot_package.
          READ TABLE mt_master REFERENCE INTO lr_master WITH KEY pack_ref COMPONENTS cts_hot_package_ref = lr_hot_package.
          IF sy-subrc = 0 AND                                                                     &quot;A is default. So if package not exist yet in HOTA, it does not matter because A will be used as default during sync
               ( ( lv_target_deploy_mode = if_cts_hot_db_access=&gt;co_hot_deploy_mode_always AND lr_master-&gt;hot_deploy_mode &lt;&gt; if_cts_hot_db_access=&gt;co_hot_deploy_mode_always AND lr_master-&gt;exists_in_hota = abap_true )
                OR ( lv_target_deploy_mode = if_cts_hot_db_access=&gt;co_hot_deploy_mode_prework AND lr_master-&gt;hot_deploy_mode &lt;&gt; if_cts_hot_db_access=&gt;co_hot_deploy_mode_prework ) ). &quot;For setting P the entry needs to exist in HOTA which is checked before.

            lv_transport_request2 = check_object( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTP&apos; i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) ).

            &quot;in case check_object does not return any request, reuse request of previous object if there was a previous object.
            IF lv_transport_request2 IS NOT INITIAL.
              lv_transport_request = lv_transport_request2.
            ENDIF.

            lv_transport_request = add_to_tr( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTP&apos;
                                              i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) &quot;conv needed to extend c length 40 to c length 110
                                              i_transport_request = lv_transport_request
                                              i_is_deletion = abap_false ).

            &quot;update deploy mode in DB
            &quot;##TODO move to cl_ctshot_dbaccess
            UPDATE cts_hot_package SET hot_activation_mode = lv_target_deploy_mode WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id AND abap_status = &apos;A&apos;.

            &quot;update deploy mode global table.
            lr_master-&gt;hot_deploy_mode = lv_target_deploy_mode.
            CASE lr_master-&gt;hot_deploy_mode.
              WHEN &apos; &apos; OR if_cts_hot_db_access=&gt;co_hot_deploy_mode_always.
                lr_master-&gt;hot_deploy_mode_as_text = &apos;A - Package and associated objects deployed directly in import&apos;(169).
              WHEN if_cts_hot_db_access=&gt;co_hot_deploy_mode_prework.
                lr_master-&gt;hot_deploy_mode_as_text = &apos;P - Package and associated objects only deployed after prework done&apos;(170).
            ENDCASE.
            lv_changed = abap_true.

            lv_count_changed_pkgs = lv_count_changed_pkgs + 1.

            IF lv_target_deploy_mode = if_cts_hot_db_access=&gt;co_hot_deploy_mode_always
               AND lv_popup_p_to_a_shown = abap_false.
              MESSAGE ID &apos;SCTS_HOT&apos; TYPE &apos;I&apos; NUMBER 029.
              lv_popup_p_to_a_shown = abap_true.
            ENDIF.

            lv_text = &apos;Deploy mode set to &amp;1 for package &amp;2&apos;(179).
            REPLACE &apos;&amp;1&apos; IN lv_text WITH lv_target_deploy_mode.
            REPLACE &apos;&amp;2&apos; IN lv_text WITH lr_hot_package-&gt;hana_package_id.
            MESSAGE lv_text TYPE &apos;S&apos;.
          ENDIF.
        ENDLOOP.

        IF lv_count_changed_pkgs &gt; 1.
          lv_text = &apos;Deploy mode set to &amp;1 for &amp;2 packages&apos;(183).
          REPLACE &apos;&amp;1&apos; IN lv_text WITH lv_target_deploy_mode.
          REPLACE &apos;&amp;2&apos; IN lv_text WITH |{ lv_count_changed_pkgs }|.
          MESSAGE lv_text TYPE &apos;S&apos;.
        ENDIF.
      CATCH cx_hana_object_transport INTO DATA(hot_exc).
        DATA(t100_key) = hot_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH hot_exc-&gt;msgv1 hot_exc-&gt;msgv2 hot_exc-&gt;hana_error_code hot_exc-&gt;hana_error_msg.
    ENDTRY.

    IF lv_changed = abap_true.
      &quot;preserve selection... therefore do not use refresh_data().
      TRY.
          DATA(lt_rows_packages) = mr_hierseq-&gt;get_selections( 1 )-&gt;get_selected_rows( ).
          DATA(lt_rows_objects) = mr_hierseq-&gt;get_selections( 2 )-&gt;get_selected_rows( ).

          mr_hierseq-&gt;refresh( ). &quot;selektierte Pakete/Objekte gehen verloren...

          mr_hierseq-&gt;get_selections( 1 )-&gt;set_selected_rows( lt_rows_packages ).
          mr_hierseq-&gt;get_selections( 2 )-&gt;set_selected_rows( lt_rows_objects ).
        CATCH cx_salv_not_found INTO DATA(exc).
          &quot;should not happen because we always have 2 levels of data
          DATA(ls_msg) = exc-&gt;get_message( ).
          MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
      ENDTRY.
    ENDIF.
  ENDMETHOD.

  METHOD set_transl_mode.

    DATA: lv_popup_question            TYPE string,
          lv_popup_answer              TYPE c LENGTH 1,
          lr_hot_package               TYPE REF TO cl_cts_hot_package,
          lr_master                    TYPE REF TO g_type_s_master,
          lv_transport_request         TYPE trkorr,
          lv_transport_request2        TYPE trkorr,
          lv_count_changed_pkgs        TYPE i,
          lv_text                      TYPE string,
          lv_changed                   TYPE abap_bool,
          lt_languages                 TYPE STANDARD TABLE OF spras,
          lv_not_relevant_for_transl   TYPE cts_hot_abap_no_translation,
          lv_sync_required_popup_shown TYPE abap_bool VALUE abap_false.

    TRY.
        get_selected_data( IMPORTING e_hotp_packages = DATA(lt_hotp_packages) e_hota_packages = DATA(lt_hota_packages) e_hota_objects = DATA(lt_hota_objects) e_hoto_objects = DATA(lt_hoto_objects) ).
        &quot;in this method we do not need to distinguish between hota and hotp
        APPEND LINES OF lt_hota_packages TO lt_hotp_packages.

        IF lt_hotp_packages IS INITIAL.
          MESSAGE &apos;Translation relevance cannot be set for the selected packages. Select entries with status yellow or green.&apos;(242) TYPE &apos;S&apos;.
          RETURN.
        ENDIF.

        SORT lt_hotp_packages BY table_line-&gt;hana_package_id ASCENDING.

        lv_popup_question = &apos;Are the selected packages and the associated objects translation-relevant?&apos;(190).

        CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
          EXPORTING
            titlebar              = &apos;Define Translation-Relevance&apos;(191)    &quot; Titel des Popup*
*           diagnose_object       = &apos;CTS_HTA_..........&apos;    &quot; Diagnosetext (Pflege über SE61)
            text_question         = lv_popup_question    &quot; Fragetext im Popup
            text_button_1         = &apos;Oui&apos;(192)      &quot; Text auf der ersten Drucktaste - 12 Zeichen
*           icon_button_1         = &apos;ICON_CHECKED&apos; &quot; Ikone auf der ersten Drucktaste - 12 Zeichen
            text_button_2         = &apos;Non&apos;(193)    &quot; Text auf der zweiten Drucktaste
*           icon_button_2         = &apos;ICON_CANCEL&apos;  &quot; Ikone auf der zweiten Drucktaste
            default_button        = &apos;1&apos;    &quot; Cursorposition
            display_cancel_button = &apos;X&apos;    &quot; Schalter,ob Abbrechen-Drucktaste angezeigt wird
            userdefined_f1_help   = &apos;CTS_HTA_SET_TRANSL_MODE_F1&apos;    &quot; Benutzerdefinierte F1-Hilfe
*           start_column          =     &quot; Startspalte, in der das POPUP beginnt
*           start_row             =     &quot; Startzeile, in der das POPUP beginnt
*           popup_type            = &apos;ICON_MESSAGE_WARNING&apos;    &quot; Ikonentyp
            iv_quickinfo_button_1 = &apos;Translate packages and objects&apos;(194)   &quot; Quickinfo auf der ersten Drucktaste
            iv_quickinfo_button_2 = &apos;Do not translate packages and objects&apos;(195) &quot; Quickinfo auf der zweiten Drucktaste
          IMPORTING
            answer                = lv_popup_answer   &quot; Rückgabewerte: &apos;1&apos;, &apos;2&apos;, &apos;A&apos;
*          TABLES
*           parameter             = lt_popup_params   &quot; Übergabetabelle für Parameter im Text
          EXCEPTIONS
            text_not_found        = 1
            OTHERS                = 2.
        IF sy-subrc &lt;&gt; 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.

        IF lv_popup_answer = &apos;1&apos;.
          lv_not_relevant_for_transl = if_cts_hot_db_access=&gt;co_hot_relevant_for_transl.
        ELSEIF lv_popup_answer = &apos;2&apos;.
          lv_not_relevant_for_transl = if_cts_hot_db_access=&gt;co_hot_not_relevant_for_transl. &quot; &apos;X&apos;
        ELSEIF lv_popup_answer = &apos;A&apos;.
          MESSAGE &apos;Action canceled by user&apos;(159) TYPE &apos;E&apos;.
          &quot;Ende Programmausfuehrung
        ENDIF.

        &quot;check if all packages are known in HTA so that the appropriate value can be set at all.
        LOOP AT lt_hotp_packages INTO lr_hot_package.
          READ TABLE mt_master REFERENCE INTO lr_master WITH KEY pack_ref COMPONENTS cts_hot_package_ref = lr_hot_package.
          IF sy-subrc = 0 AND lr_master-&gt;exists_in_hota = abap_false.
            MESSAGE &apos;Translation-relevance can only be set after the first synchronization; perform the synchronization first&apos;(196) TYPE &apos;E&apos;.
            &quot;Ende Programmausfuehrung
          ENDIF.
        ENDLOOP.

        &quot;add package to TR and set translation relevance in case it is changed for some package
        LOOP AT lt_hotp_packages INTO lr_hot_package.
          READ TABLE mt_master REFERENCE INTO lr_master WITH KEY pack_ref COMPONENTS cts_hot_package_ref = lr_hot_package.
          IF sy-subrc = 0 AND  &quot; TODO: ist sy-subrc nicht immer = 0???
            lr_master-&gt;abap_no_translation &lt;&gt; lv_not_relevant_for_transl. &quot; only proceed if translation relevance has changed

            lv_transport_request2 = check_object( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTP&apos; i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) ).

            &quot;in case check_object does not (todo: not?????) return any request, reuse request of previous object if there was a previous object.
            IF lv_transport_request2 IS NOT INITIAL.
              lv_transport_request = lv_transport_request2.
            ENDIF.

            lv_transport_request = add_to_tr( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTP&apos;
                                              i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) &quot;conv needed to extend c length 40 to c length 110
                                              i_transport_request = lv_transport_request
                                              i_is_deletion = abap_false ).

            &quot;update translation relevance in DB
            &quot;##TODO/Daniel move to cl_ctshot_dbaccess
            UPDATE cts_hot_package SET abap_no_translation = lv_not_relevant_for_transl WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id AND abap_status = &apos;A&apos;.

            &quot;if translation is switched off, texts must be deleted and therefore LANG HOTA to be added to TR
            IF lv_not_relevant_for_transl = if_cts_hot_db_access=&gt;co_hot_not_relevant_for_transl.
****** start block without LANG HOTA for deletion (delete in 7.40 SP 13/7.50 SP 2)
              lv_transport_request2 = check_object( i_pgmid = &apos;R3TR&apos; i_obj_type = &apos;HOTA&apos; i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) ).  &quot;##TODO: LANG instead of R3TR

              IF lv_transport_request2 IS NOT INITIAL.
                lv_transport_request = lv_transport_request2.
              ENDIF.

              lv_transport_request = add_to_tr( i_pgmid = &apos;R3TR&apos; i_obj_type = &apos;HOTA&apos; &quot;##TODO: LANG instead of R3TR
                                                i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) &quot;conv needed to extend c length 40 to c length 110
                                                i_transport_request = lv_transport_request
                                                i_is_deletion = abap_false ). &quot;isn&apos;t it a deletion because We delete all texts?

****** Ende block without LANG HOTA for deletion (delete in 7.40 SP 13/7.50 SP 2)
****** Start block with LANG HOTA for deletion (enable in 7.40 SP 13/7.50 SP 2)
*              &quot;get master language from tadir
*              IF lr_master-&gt;masterlang IS INITIAL.
*                &quot;##TODO better to use: call function &apos;TR_TADIR_INTERFACE&apos;
*                SELECT SINGLE masterlang FROM tadir INTO lr_master-&gt;masterlang WHERE pgmid = &apos;R3TR&apos; AND object = &apos;HOTA&apos; AND obj_name = lr_master-&gt;transport_obj_name.
*                IF sy-subrc &lt;&gt; 0.
*                  &quot;no tadir yet, so package was never added to transport before.
*                  MESSAGE &apos;Übersetzungssrelevanz kann erst nach erstmaligem Synchronisieren gesetzt werden; führen Sie zunächst die Synchronisierung durch&apos;(196) TYPE &apos;E&apos;.
*                  &quot;Ende Programmausfuehrung
*                ENDIF.
*              ENDIF.
*
*              &quot;check if there is only master language in HTA so far. If so, add LANG HOTA to transport request.
*              &quot; If there are several languages already there, add R3TR HOTA to transport request (because of
*              &quot; possible exports with mode LSM=master which would not allow different LANG HOTA than master language)
*              CLEAR lt_languages.
*              SELECT DISTINCT language FROM cts_hot_otexts_s INTO TABLE lt_languages WHERE abap_object_reference IN
*                                            ( SELECT abap_object_reference FROM cts_hot_object WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id
*                                                                                                 AND abap_status = &apos;A&apos; ).
*              SELECT DISTINCT language FROM cts_hot_otexts_l APPENDING TABLE lt_languages WHERE abap_object_reference IN
*                                            ( SELECT abap_object_reference FROM cts_hot_object WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id
*                                                                                                 AND abap_status = &apos;A&apos; ).
*
*              SORT lt_languages.
*              DELETE ADJACENT DUPLICATES FROM lt_languages.
*
*              IF lt_languages IS INITIAL OR ( lines( lt_languages ) = 1 AND lt_languages[ 1 ] = lr_master-&gt;masterlang ).
*                lv_transport_request2 = check_langu_object( i_obj_type = &apos;HOTA&apos;
*                                                            i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id )
*                                                            i_masterlang = lr_master-&gt;masterlang ).
*
*                IF lv_transport_request2 IS NOT INITIAL.
*                 lv_transport_request = lv_transport_request2.
*                ENDIF.
*
*                lv_transport_request = add_langu_to_tr( i_obj_type = &apos;HOTA&apos;
*                                                        i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) &quot;conv needed to extend c length 40 to c length 110
*                                                        i_masterlang = lr_master-&gt;masterlang
*                                                        i_transport_request = lv_transport_request ).
*              ELSE.
*                lv_transport_request2 = check_object( i_pgmid = &apos;R3TR&apos; i_obj_type = &apos;HOTA&apos; i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) ).
*
*                IF lv_transport_request2 IS NOT INITIAL.
*                  lv_transport_request = lv_transport_request2.
*                ENDIF.
*
*                lv_transport_request = add_to_tr( i_pgmid = &apos;R3TR&apos; i_obj_type = &apos;HOTA&apos;
*                                                  i_obj_name = CONV #( lr_hot_package-&gt;abap_hana_package_id ) &quot;conv needed to extend c length 40 to c length 110
*                                                  i_transport_request = lv_transport_request
*                                                  i_is_deletion = abap_false ). &quot;isn&apos;t it a deletion because We delete all texts?
*              ENDIF.
*
****** End block with LANG HOTA For deletion (enable in 7.40 SP 13/7.50 SP 2)*

              &quot;Finally delete masterlang and text references from DB for all objects of the package for which language is switched off
              DELETE FROM cts_hot_otexts_h WHERE abap_object_reference IN
                                            ( SELECT abap_object_reference FROM cts_hot_object WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id
                                                                                                 AND abap_status = &apos;A&apos; ).
              DELETE FROM cts_hot_otexts_s WHERE abap_object_reference IN
                                            ( SELECT abap_object_reference FROM cts_hot_object WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id
                                                                                                 AND abap_status = &apos;A&apos; ).
              DELETE FROM cts_hot_otexts_l WHERE abap_object_reference IN
                                            ( SELECT abap_object_reference FROM cts_hot_object WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id
                                                                                                 AND abap_status = &apos;A&apos; ).

              UPDATE cts_hot_object SET abap_object_reference = &apos;&apos; WHERE abap_hana_package_id = lr_hot_package-&gt;abap_hana_package_id AND abap_status = &apos;A&apos;.
            ENDIF.

            &quot;if translation is switched on, show a popup that texts will by synced during next normal object sync only.
            IF lv_not_relevant_for_transl = if_cts_hot_db_access=&gt;co_hot_relevant_for_transl AND lv_sync_required_popup_shown = abap_false.
              lv_text = &apos;The texts of the objects in the chosen packages are not available until the first synchronization of the objects in ABAP.&apos;(202).
              MESSAGE lv_text TYPE &apos;I&apos;.
              lv_sync_required_popup_shown = abap_true.
            ENDIF.

            &quot;update translation relevance in  global table.
            lr_master-&gt;abap_no_translation = lv_not_relevant_for_transl.
            CASE lr_master-&gt;abap_no_translation.
              WHEN if_cts_hot_db_access=&gt;co_hot_relevant_for_transl.
                lr_master-&gt;abap_translation_as_text = &apos;Package and associated objects are relevant for translation&apos;(197).
              WHEN if_cts_hot_db_access=&gt;co_hot_not_relevant_for_transl.
                lr_master-&gt;abap_translation_as_text = &apos;Package and associated objects are not relevant for translation&apos;(198).
            ENDCASE.
            lv_changed = abap_true.

            IF lr_master-&gt;abap_no_translation = if_cts_hot_db_access=&gt;co_hot_relevant_for_transl.
              lv_text = &apos;Package &amp;1 set to translation-relevant&apos;(199).
              REPLACE &apos;&amp;1&apos; IN lv_text WITH lr_hot_package-&gt;hana_package_id.
              MESSAGE lv_text TYPE &apos;S&apos;.
              lv_count_changed_pkgs = lv_count_changed_pkgs + 1.
            ELSEIF lr_master-&gt;abap_no_translation = if_cts_hot_db_access=&gt;co_hot_not_relevant_for_transl.
              lv_text = &apos;Package &amp;1 set to not translation-relevant&apos;(200).
              REPLACE &apos;&amp;1&apos; IN lv_text WITH lr_hot_package-&gt;hana_package_id.
              MESSAGE lv_text TYPE &apos;S&apos;.
              lv_count_changed_pkgs = lv_count_changed_pkgs + 1.
            ENDIF.
          ENDIF.
        ENDLOOP.

        IF lv_count_changed_pkgs &gt; 1.
          IF lv_not_relevant_for_transl = if_cts_hot_db_access=&gt;co_hot_relevant_for_transl.
            lv_text = &apos;&amp;1 Pakete wurden festgelegt auf übersetzungsrelevant&apos;(204).
          ELSEIF lv_not_relevant_for_transl = if_cts_hot_db_access=&gt;co_hot_not_relevant_for_transl.
            lv_text = &apos;&amp;1 Pakete wurden festgelegt auf nicht übersetzungsrelevant&apos;(205).
          ENDIF.
          REPLACE &apos;&amp;1&apos; IN lv_text WITH |{ lv_count_changed_pkgs }|.
          MESSAGE lv_text TYPE &apos;S&apos;.
        ENDIF.
      CATCH cx_hana_object_transport INTO DATA(hot_exc).
        DATA(t100_key) = hot_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH hot_exc-&gt;msgv1 hot_exc-&gt;msgv2 hot_exc-&gt;hana_error_code hot_exc-&gt;hana_error_msg.
    ENDTRY.

    IF lv_changed = abap_true.
      &quot;preserve selection... therefore do not use refresh_data().
      TRY.
          DATA(lt_rows_packages) = mr_hierseq-&gt;get_selections( 1 )-&gt;get_selected_rows( ).
          DATA(lt_rows_objects) = mr_hierseq-&gt;get_selections( 2 )-&gt;get_selected_rows( ).

          mr_hierseq-&gt;refresh( ). &quot;selektierte Pakete/Objekte gehen verloren...

          mr_hierseq-&gt;get_selections( 1 )-&gt;set_selected_rows( lt_rows_packages ).
          mr_hierseq-&gt;get_selections( 2 )-&gt;set_selected_rows( lt_rows_objects ).
        CATCH cx_salv_not_found INTO DATA(exc).
          &quot;should not happen because we always have 2 levels of data
          DATA(ls_msg) = exc-&gt;get_message( ).
          MESSAGE ID ls_msg-msgid TYPE &apos;E&apos; NUMBER ls_msg-msgno WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.
      ENDTRY.
    ENDIF.

  ENDMETHOD.

  METHOD set_masterlang_in_mt_master.
    DATA: lt_sobj_names              TYPE SORTED TABLE OF sobj_name WITH UNIQUE KEY table_line,
          lv_popup_question          TYPE string,
          lv_popup_button1_quickinfo TYPE text132,
          lv_popup_answer            TYPE c LENGTH 1,
          ls_popup_param             TYPE spar,
          lt_popup_params            TYPE STANDARD TABLE OF spar,
          lv_fallback                TYPE i,
          lv_text                    TYPE string.

    &quot;1. create table with all sobj_names of passed data (tadir name)
    LOOP AT i_hota_packages INTO DATA(lr_package).
      INSERT lr_package-&gt;abap_hana_package_id INTO TABLE lt_sobj_names.
    ENDLOOP.
    LOOP AT i_hotp_packages INTO lr_package.
      INSERT lr_package-&gt;abap_hana_package_id INTO TABLE lt_sobj_names.
    ENDLOOP.
    LOOP AT i_hoto_objects INTO DATA(lr_object).
      INSERT lr_object-&gt;abap_hana_package_id INTO TABLE lt_sobj_names.
    ENDLOOP.

    &quot;2. For all sobj_names set ABAP language on package if not yet set during this user session.
    LOOP AT lt_sobj_names INTO DATA(lv_sobj_name).
      READ TABLE mt_master REFERENCE INTO DATA(lr_master) WITH KEY transport_obj_name = lv_sobj_name.

      &quot;##TODO maybe ask user every time whether masterlang in tadir is still OK if not yet maintained in HANA?
      IF lr_master-&gt;exists_in_hana = abap_false &quot;deletion case. language not needed because tadir should already exists
          OR lr_master-&gt;exists_in_hota = abap_true &quot;already exists in HOTA, language not needed because tadir already exists
          OR lr_master-&gt;masterlang IS NOT INITIAL. &quot;language already set
        CONTINUE.
      ENDIF.

      TRY.
          lr_master-&gt;masterlang = mr_external_calls-&gt;determine_masterlang_for_tadir(
            EXPORTING
              i_hana_package_name            = lr_master-&gt;hana_package_id
              i_hana_original_language       = lr_master-&gt;hana_original_language
              i_suppress_dialog              = space
              i_translation_relevance        = ce_cts_hta_translation=&gt;relevant_for_translation
          ).

          IF lr_master-&gt;masterlang = sy-langu AND lr_master-&gt;hana_original_language IS INITIAL.
            lr_master-&gt;abap_no_translation = if_cts_hot_db_access=&gt;co_hot_not_relevant_for_transl.
            lr_master-&gt;abap_translation_as_text = &apos;Paket und zugehörige Objekte sind nicht relevant für Übersetzung&apos;(198).
          ENDIF.
        CATCH cx_cts_hta_unknown_master_lang cx_cts_hta INTO DATA(lr_exc).
          DATA(t100_key) = lr_exc-&gt;if_t100_message~t100key.
          MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH lr_exc-&gt;message_variable_1 lr_exc-&gt;message_variable_2 lr_exc-&gt;message_variable_3 lr_exc-&gt;message_variable_4.
          &quot;Ende Programmausfuehrung
      ENDTRY.
    ENDLOOP.

  ENDMETHOD.

  METHOD check_objects.
    DATA: lv_transport_request TYPE trkorr.

    LOOP AT i_hota_packages INTO DATA(lr_package).
      lv_transport_request = check_object( i_pgmid = &apos;R3TR&apos; i_obj_type = &apos;HOTA&apos;
                                           i_obj_name = CONV cts_hot_object_name( lr_package-&gt;abap_hana_package_id ) ).
      IF lv_transport_request IS NOT INITIAL.
        INSERT lv_transport_request INTO TABLE r_result.
      ENDIF.
    ENDLOOP.

    LOOP AT i_hotp_packages INTO lr_package.
      lv_transport_request = check_object( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTP&apos;
                                           i_obj_name = CONV cts_hot_object_name( lr_package-&gt;abap_hana_package_id ) ).
      IF lv_transport_request IS NOT INITIAL.
        INSERT lv_transport_request INTO TABLE r_result.
      ENDIF.
    ENDLOOP.

    LOOP AT i_hoto_objects INTO DATA(lr_object).
      lv_transport_request = check_object( i_pgmid = &apos;LIMU&apos; i_obj_type = &apos;HOTO&apos;
                                           i_obj_name = lr_object-&gt;transport_object_name ).
      IF lv_transport_request IS NOT INITIAL.
        INSERT lv_transport_request INTO TABLE r_result.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD check_object.
    DATA:
      lv_text        TYPE string,
      lv_global_lock TYPE c.

    check_transport_tools( ).

    READ TABLE mt_master REFERENCE INTO DATA(lr_master) WITH KEY transport_obj_name = i_obj_name(40).

    TRY.
        r_result = mr_external_calls-&gt;rs_corr_check(
            i_pgmid           = i_pgmid
            i_object_type     = i_obj_type
            i_object_name     = CONV #( i_obj_name )
            i_suppress_dialog = space
        ).
      CATCH cx_cts_hta_wbo INTO DATA(lr_exc).
        DATA(t100_key) = lr_exc-&gt;if_t100_message~t100key.
        MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH lr_exc-&gt;message_variable_1 lr_exc-&gt;message_variable_2 lr_exc-&gt;message_variable_3 lr_exc-&gt;message_variable_4.
        &quot;Ende Programmausfuehrung
    ENDTRY.
  ENDMETHOD.


  METHOD check_langu_object.
    DATA:
      lv_text        TYPE string,
      lv_global_lock TYPE c,
      ls_wi_ko200    TYPE ko200.

    check_transport_tools( ).

    ls_wi_ko200-pgmid = &apos;LANG&apos;.
    ls_wi_ko200-object = i_obj_type.
    ls_wi_ko200-obj_name = i_obj_name.
    ls_wi_ko200-lang = i_masterlang.

    CALL FUNCTION &apos;TR_OBJECT_CHECK&apos;
      EXPORTING
        wi_ko200                = ls_wi_ko200    &quot; Eingabe zu editierendes Objekt
*       iv_no_standard_editor   = &apos; &apos;    &quot; Allgemeines Flag
*       iv_no_show_option       = &apos; &apos;    &quot; Kein &apos;Anzeigen&apos; auf Fehlerpopup
*       iv_externalps           = &apos; &apos;
*       iv_externalid           = &apos; &apos;
*       iv_no_ps                = &apos; &apos;    &quot; Allgemeines Flag
*       it_e071k_str            =     &quot; (obsolet - IT_OBJ_ENTRIES verwenden) Tabellenschlüssel mit S
*       it_obj_entry            =     &quot; Schnittstellenstruktur für Objekte mit Keys im CTS
      IMPORTING
        we_order                = r_result    &quot; gewählter Auftrag (Transportauftrag)
*       we_task                 =     &quot; gewählte Aufgabe (Korrektur/Reparatur)
*       we_ko200                =     &quot; Ausgabe zu editierendes Objekt
*       we_object_appendable    =     &quot; &apos;X&apos;: TR_OBJECT_INSERT wird Objekt aufnehmen
*       es_tadir                =     &quot; Ausgabe Objektkatalogeintrag
*      TABLES
*       wt_e071k                =     &quot; Eingabetabelle zu editierender Objekt-keys
      EXCEPTIONS
        cancel_edit_other_error = 1
        show_only_other_error   = 2
        OTHERS                  = 3.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      &quot;Ende Programmausfuehrung
    ENDIF.
  ENDMETHOD.


  METHOD add_langu_to_tr.
    DATA: ls_wi_ko200 TYPE ko200.

    ls_wi_ko200-pgmid = &apos;LANG&apos;.
    ls_wi_ko200-object = i_obj_type.
    ls_wi_ko200-obj_name = i_obj_name.
    ls_wi_ko200-lang = i_masterlang.

    CALL FUNCTION &apos;TR_OBJECT_INSERT&apos;
      EXPORTING
        wi_order                = i_transport_request    &quot; vorgeschlagener Auftrag (Prio vor Auftragssuche)
        wi_ko200                = ls_wi_ko200   &quot; Eingabe editiertes Objekt
*       iv_no_standard_editor   = &apos; &apos;    &quot; Allgemeines Flag
*       iv_no_show_option       = &apos; &apos;    &quot; Kein &apos;Anzeigen&apos; auf Fehlerpopup
*       iv_externalps           = &apos; &apos;
*       iv_externalid           = &apos; &apos;
*       iv_no_ps                = &apos; &apos;    &quot; Allgemeines Flag
*       iv_old_call             =     &quot; Alte Semantik
*       it_e071k_str            =     &quot; (obsolet - IT_OBJ_ENTRIES verwenden) Tabellenschlüssel mit S
*       it_obj_entry            =     &quot; Schnittstellenstruktur für Objekte mit Keys im CTS
      IMPORTING
        we_order                = r_result   &quot; gewählter Auftrag (Transportauftrag)
*       we_task                 =     &quot; gewählte Aufgabe (Korrektur/Reparatur)
*       we_ko200                =     &quot; Ausgabe editiertes Objekt
*       es_tadir                =     &quot; Ausgabe Objektkatalogeintrag
*      TABLES
*       wt_e071k                =     &quot; Eingabetabelle editierter Objekt-keys
      EXCEPTIONS
        cancel_edit_other_error = 1
        show_only_other_error   = 2
        OTHERS                  = 3.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      &quot;Ende Programmausfuehrung
    ENDIF.
  ENDMETHOD.


  METHOD check_transport_tools.
    TRY.
        mr_external_calls-&gt;check_transport_tools_for_sync( i_suppress_dialog = abap_false ).
      CATCH cx_cts_hta INTO DATA(lo_exc).
        MESSAGE ID lo_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER lo_exc-&gt;if_t100_message~t100key-msgno
                WITH lo_exc-&gt;message_variable_1 lo_exc-&gt;message_variable_2 lo_exc-&gt;message_variable_3 lo_exc-&gt;message_variable_4.
    ENDTRY.
  ENDMETHOD.


  METHOD calculate_depl_status.
    FIELD-SYMBOLS: &lt;master&gt; TYPE g_type_s_master,
                   &lt;slave&gt;  TYPE g_type_s_slave.

* ... 1.  handle packages
    LOOP AT mt_master ASSIGNING &lt;master&gt;.
      &quot;set sync status
      IF &lt;master&gt;-exists_in_hana = abap_true AND &lt;master&gt;-exists_in_hota = abap_true AND &lt;master&gt;-hana_package_id &lt;&gt; &lt;master&gt;-hot_hana_package_id.
        &lt;master&gt;-sync_deploy_state = icon_led_red. &quot;Do not allow sync for case different packages
      ELSEIF &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_inactive
        OR &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_deploy_error
        OR &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted
        OR &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_delete_error.
        &lt;master&gt;-sync_deploy_state = icon_led_yellow.
      ELSEIF &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_active.
        &lt;master&gt;-sync_deploy_state = icon_led_green.
      ELSEIF &lt;master&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_new
        OR  &lt;master&gt;-exists_in_hota = abap_false.
        &lt;master&gt;-sync_deploy_state = icon_led_inactive.
      ELSE. &quot;for other cases
        &lt;master&gt;-sync_deploy_state = icon_led_inactive.
      ENDIF.

      mark_difference_package( IMPORTING ev_master = &lt;master&gt; ).
    ENDLOOP.

* ... 2. handle objects
    UNASSIGN &lt;master&gt;.
    LOOP AT mt_slave ASSIGNING &lt;slave&gt;.

      IF &lt;master&gt; IS NOT ASSIGNED OR &lt;master&gt;-transport_obj_name &lt;&gt; &lt;slave&gt;-abap_hana_package_id.
        READ TABLE mt_master ASSIGNING &lt;master&gt; WITH KEY transport_obj_name = &lt;slave&gt;-abap_hana_package_id.
      ENDIF.

      IF &lt;master&gt;-sync_deploy_state = icon_led_red &quot;set object status to red if package has case difference, because this is currently not supported
        OR ( &lt;slave&gt;-exists_in_hana = abap_true AND &lt;slave&gt;-exists_in_hota = abap_true
            AND ( &lt;slave&gt;-hana_package_id &lt;&gt; &lt;slave&gt;-hot_hana_package_id
                  OR &lt;slave&gt;-hana_object_name &lt;&gt; &lt;slave&gt;-hot_hana_object_name
                  OR &lt;slave&gt;-hana_object_suffix &lt;&gt; &lt;slave&gt;-hot_hana_object_suffix ) ).
        &lt;slave&gt;-sync_deploy_state = icon_led_red.
      ELSEIF &lt;slave&gt;-exists_in_hota = abap_false
        OR   &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_new.
        &lt;slave&gt;-sync_deploy_state = icon_led_inactive.
      ELSEIF &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_inactive
        OR &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_deploy_error
        OR &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted
        OR &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_delete_error.
        &lt;slave&gt;-sync_deploy_state = icon_led_yellow.
      ELSEIF &lt;slave&gt;-hot_status = if_cts_hot_db_access=&gt;co_hot_status_active.
        &lt;slave&gt;-sync_deploy_state = icon_led_green.
      ELSE.
        &lt;slave&gt;-sync_deploy_state = icon_led_inactive.
      ENDIF.

      IF &lt;slave&gt;-sync_deploy_state &lt;&gt; icon_led_red.
        &quot;no colors to be set for these slaves as the objects can not be compared
        mark_difference_object( IMPORTING ev_slave = &lt;slave&gt; ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD mark_difference_package.
    FIELD-SYMBOLS &lt;master_c&gt; TYPE g_type_s_master.
    ASSIGN ev_master TO  &lt;master_c&gt;.

    IF &lt;master_c&gt;-hana_package_id &lt;&gt; &lt;master_c&gt;-hot_hana_package_id.
      append_change_color( EXPORTING i_name1 = &apos;HANA_PACKAGE_ID&apos; i_name2 = &apos;HOT_HANA_PACKAGE_ID&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
      append_change_color( EXPORTING i_name1 = &apos;PACKAGE_ID&apos; i_name2 = &apos;PACKAGE_ID&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_description &lt;&gt; &lt;master_c&gt;-hot_description.
      append_change_color( EXPORTING i_name1 = &apos;HANA_DESCRIPTION&apos; i_name2 = &apos;HOT_DESCRIPTION&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_hints_for_translation &lt;&gt; &lt;master_c&gt;-hot_hints_for_translation.
      append_change_color( EXPORTING i_name1 = &apos;HANA_HINTS_FOR_TRANSLATION&apos; i_name2 = &apos;HOT_HINTS_FOR_TRANSLATION&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_is_structural &lt;&gt; &lt;master_c&gt;-hot_is_structural.
      append_change_color( EXPORTING i_name1 = &apos;HANA_IS_STRUCTURAL&apos; i_name2 = &apos;HOT_IS_STRUCTURAL&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_original_language &lt;&gt; &lt;master_c&gt;-hot_original_language.
      append_change_color( EXPORTING i_name1 = &apos;HANA_ORIGINAL_LANGUAGE&apos; i_name2 = &apos;HOT_ORIGINAL_LANGUAGE&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_responsible &lt;&gt; &lt;master_c&gt;-hot_responsible.
      append_change_color( EXPORTING i_name1 = &apos;HANA_RESPONSIBLE&apos; i_name2 = &apos;HOT_RESPONSIBLE&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_src_system &lt;&gt; &lt;master_c&gt;-hot_src_system.
      append_change_color( EXPORTING i_name1 = &apos;HANA_SRC_SYSTEM&apos; i_name2 = &apos;HOT_SRC_SYSTEM&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_src_tenant &lt;&gt; &lt;master_c&gt;-hot_src_tenant.
      append_change_color( EXPORTING i_name1 = &apos;HANA_SRC_TENANT&apos; i_name2 = &apos;HOT_SRC_TENANT&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_text_collection &lt;&gt; &lt;master_c&gt;-hot_text_collection.
      append_change_color( EXPORTING i_name1 = &apos;HANA_TEXT_COLLECTION&apos; i_name2 = &apos;HOT_TEXT_COLLECTION&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_text_status &lt;&gt; &lt;master_c&gt;-hot_text_status.
      append_change_color( EXPORTING i_name1 = &apos;HANA_TEXT_STATUS&apos; i_name2 = &apos;HOT_TEXT_STATUS&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.
    IF &lt;master_c&gt;-hana_text_terminology_domain &lt;&gt; &lt;master_c&gt;-hot_text_terminology_domain.
      append_change_color( EXPORTING i_name1 = &apos;HANA_TEXT_TERMINOLOGY_DOMAIN&apos; i_name2 = &apos;HOT_TEXT_TERMINOLOGY_DOMAIN&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

    IF &lt;master_c&gt;-hana_hints_for_translation &lt;&gt; &lt;master_c&gt;-hot_hints_for_translation.
      append_change_color( EXPORTING i_name1 = &apos;HANA_HINTS_FOR_TRANSLATION&apos; i_name2 = &apos;HOT_HINTS_FOR_TRANSLATION&apos;
                           CHANGING ch_color_table = &lt;master_c&gt;-t_color  ).
    ENDIF.

  ENDMETHOD.

  METHOD mark_difference_object.

    FIELD-SYMBOLS &lt;slave_c&gt; TYPE g_type_s_slave.
    ASSIGN ev_slave TO  &lt;slave_c&gt;.

    IF &lt;slave_c&gt;-hana_package_id &lt;&gt; &lt;slave_c&gt;-hot_hana_package_id.
      append_change_color( EXPORTING i_name1 = &apos;PACKAGE_ID&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
      append_change_color( EXPORTING i_name1 = &apos;HANA_PACKAGE_ID&apos; i_name2 = &apos;HOT_HANA_PACKAGE_ID&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
    ENDIF.

    IF &lt;slave_c&gt;-hana_object_name &lt;&gt; &lt;slave_c&gt;-hot_hana_object_name.
      append_change_color( EXPORTING i_name1 = &apos;OBJECT_NAME&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
      append_change_color( EXPORTING i_name1 = &apos;HANA_OBJECT_NAME&apos; i_name2 = &apos;HOT_HANA_OBJECT_NAME&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
    ENDIF.

    IF &lt;slave_c&gt;-hana_object_suffix &lt;&gt; &lt;slave_c&gt;-hot_hana_object_suffix.
      append_change_color( EXPORTING i_name1 = &apos;HANA_OBJECT_SUFFIX&apos; i_name2 = &apos;HOT_HANA_OBJECT_SUFFIX&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
      append_change_color( EXPORTING i_name1 = &apos;OBJECT_SUFFIX&apos; i_name2 = &apos;HANA_OBJECT_SUFFIX&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
    ENDIF.

    IF &lt;slave_c&gt;-hana_version &lt;&gt; &lt;slave_c&gt;-hot_version. &quot;Stephan
      append_change_color( EXPORTING i_name1 = &apos;HANA_VERSION&apos; i_name2 = &apos;HOT_VERSION&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
    ENDIF.

    IF &lt;slave_c&gt;-hana_activated_at &lt;&gt; &lt;slave_c&gt;-hot_activated_at.
      append_change_color( EXPORTING i_name1 = &apos;HANA_ACTIVATED_AT&apos; i_name2 = &apos;HOT_ACTIVATED_AT&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
    ENDIF.

    IF &lt;slave_c&gt;-hana_activated_by &lt;&gt; &lt;slave_c&gt;-hot_activated_by.
      append_change_color( EXPORTING i_name1 = &apos;HANA_ACTIVATED_BY&apos; i_name2 = &apos;HOT_ACTIVATED_BY&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
    ENDIF.

    IF &lt;slave_c&gt;-hana_hana_read_system &lt;&gt; &lt;slave_c&gt;-hot_hana_read_system.
      append_change_color( EXPORTING i_name1 = &apos;HANA_HANA_READ_SYSTEM&apos; i_name2 = &apos;HOT_HANA_READ_SYSTEM&apos;
                           CHANGING ch_color_table = &lt;slave_c&gt;-t_color  ).
    ENDIF.

  ENDMETHOD.


  METHOD is_data_filtered.
    IF ms_filter_data-show_green = abap_false
          OR ms_filter_data-show_yellow = abap_false
          OR ms_filter_data-show_red = abap_false
          OR ms_filter_data-show_inactive = abap_false.
      r_result = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD get_filter_data.
    r_filter_data = ms_filter_data.
  ENDMETHOD.

  METHOD transport_order.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle
    &quot; -----------------------------------------------------------

    IF iv_trkorr IS INITIAL.
      &quot; Aucun OT
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Libération de l&apos;OT
    &quot; -----------------------------------------------------------

    zcl_transport_request_celio=&gt;request_create(
      EXPORTING
        it_trkorr = VALUE #( ( iv_trkorr ) )
        is_system = VALUE #( mandt = sy-mandt sysid = zcl_transport_request_celio=&gt;mc_system-preprod ) &quot;#EC NOTEXT
*      IMPORTING
*        es_return =     &quot; Paramètre de retour
    ).

    &quot; -----------------------------------------------------------
    &quot; Création Demande de Transport
    &quot; -----------------------------------------------------------

    &quot; Si RE1 : DE1 =&gt; IE1 / IE1 =&gt; RE1


  ENDMETHOD.

ENDCLASS.


&quot;! Test class for checking status icons in the Deployment UI
CLASS ltc_deployment DEFINITION FOR TESTING RISK LEVEL HARMLESS DURATION SHORT.
  PRIVATE SECTION.
    CLASS-METHODS:
      &quot;! to check whether we are on HANA or not. Currently required as instantiating o_cut will try to connect to HANA.
      class_setup. &quot;todo: Check for running on HANA to be removed if we support read only mode on NOT HANA DBs
    METHODS:
      deploy_yellow FOR TESTING,
      deploy_grey FOR TESTING,
      deploy_red FOR TESTING,
      deploy_green FOR TESTING.
ENDCLASS.


CLASS ltc_deployment IMPLEMENTATION.
  METHOD class_setup.
    TRY.
        cl_nhi_api=&gt;create_instance( ).
      CATCH cx_nhi_not_supported.
        cl_abap_unit_assert=&gt;abort( msg = &apos;Tests can only be executed on an ABAP on HANA System, but this system is not an ABAP on HANA system&apos; ).
    ENDTRY.
  ENDMETHOD.

  METHOD deploy_yellow.
    DATA: o_cut TYPE REF TO lcl_hota_organizer.

    TRY.
        CREATE OBJECT o_cut.
      CATCH cx_hana_object_transport INTO DATA(hota_exc).
        MESSAGE ID hota_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER hota_exc-&gt;if_t100_message~t100key-msgno.
    ENDTRY.

    FIELD-SYMBOLS: &lt;master&gt; TYPE o_cut-&gt;g_type_s_master,
                   &lt;slave&gt;  TYPE o_cut-&gt;g_type_s_slave.

    TRY.
        DATA(pkg1) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_1` ).
        DATA(pkg2) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_2` ).
        DATA(pkg3) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_3` ).
        DATA(pkg4) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_4` ).

        DATA(obj1) = cl_cts_hot_object_v1=&gt;create_instance(
                      iv_hana_package_id       = &apos;depl_test_1&apos;
                      iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                      iv_hana_object_suffix    = &apos;attributeview&apos; ).
        DATA(obj2) = cl_cts_hot_object_v1=&gt;create_instance(
                      iv_hana_package_id       = &apos;depl_test_2&apos;
                      iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                      iv_hana_object_suffix    = &apos;attributeview&apos; ).
        DATA(obj3) = cl_cts_hot_object_v1=&gt;create_instance(
                      iv_hana_package_id       = &apos;depl_test_3&apos;
                      iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                      iv_hana_object_suffix    = &apos;attributeview&apos; ).
        DATA(obj4) = cl_cts_hot_object_v1=&gt;create_instance(
                      iv_hana_package_id       = &apos;depl_test_4&apos;
                      iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                      iv_hana_object_suffix    = &apos;attributeview&apos; ).
      CATCH cx_hana_object_transport INTO DATA(hota_exc_p).
        DATA(t100_key) = hota_exc_p-&gt;if_t100_message~t100key.
        IF t100_key = cx_hana_object_transport=&gt;cx_nhi_hana_repository_error.
          DATA(nhi_exc) = CAST cx_nhi_hana_repository( hota_exc-&gt;previous ).
          t100_key = nhi_exc-&gt;if_t100_message~t100key.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
        ELSE.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH hota_exc-&gt;msgv1 hota_exc_p-&gt;msgv2 hota_exc-&gt;hana_error_code hota_exc-&gt;hana_error_msg DISPLAY LIKE &apos;E&apos;.
        ENDIF.
      CATCH cx_nhi_hana_repository INTO nhi_exc.
        t100_key = nhi_exc-&gt;if_t100_message~t100key.
        &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
        MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
    ENDTRY.

    o_cut-&gt;mt_master = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_inactive
    transport_obj_name = &apos;depl_test_1&apos; hana_package_id = &apos;depl_test_1&apos;
    hot_hana_package_id = &apos;depl_test_1&apos; package_id = &apos;depl_test_1&apos;
    cts_hot_package_ref = pkg1 )
    ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted
    transport_obj_name = &apos;depl_test_2&apos; hana_package_id = &apos;depl_test_2&apos;
    hot_hana_package_id = &apos;depl_test_2&apos; package_id = &apos;depl_test_2&apos;
    cts_hot_package_ref = pkg2 )
    ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_deploy_error
    transport_obj_name = &apos;depl_test_3&apos; hana_package_id = &apos;depl_test_3&apos;
    hot_hana_package_id = &apos;depl_test_3&apos; package_id = &apos;depl_test_3&apos;
    cts_hot_package_ref = pkg3 )
    ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_delete_error
    transport_obj_name = &apos;depl_test_4&apos; hana_package_id = &apos;depl_test_4&apos;
    hot_hana_package_id = &apos;depl_test_4&apos; package_id = &apos;depl_test_4&apos;
    cts_hot_package_ref = pkg4 )
    ).

    o_cut-&gt;mt_slave = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_inactive
    transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_1&apos; hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_1&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hana = abap_false exists_in_hota = abap_true
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj1 )
    ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_to_be_deleted
    transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_2&apos; hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_2&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hana = abap_false exists_in_hota = abap_true
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj2 )
    ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_deploy_error
    transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_3&apos; hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_3&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hana = abap_false exists_in_hota = abap_true
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj3 )
    ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_delete_error
    transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_4&apos; hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_4&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hana = abap_false exists_in_hota = abap_true
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj4 )
    ).

    o_cut-&gt;calculate_depl_status( ).

* All packages should be marked yellow (inactive, to be delete, deploy error and delete error)
    LOOP AT o_cut-&gt;mt_master ASSIGNING &lt;master&gt;.
      cl_aunit_assert=&gt;assert_equals( act    = &lt;master&gt;-sync_deploy_state
                                    exp    = icon_led_yellow
                                    msg    = &apos;The status is wrong.&apos; ).
    ENDLOOP.
  ENDMETHOD.

  METHOD deploy_grey.
    DATA: result TYPE icon_d.
    DATA: o_cut TYPE REF TO lcl_hota_organizer.

    TRY.
        CREATE OBJECT o_cut.
      CATCH cx_hana_object_transport INTO DATA(lr_hot_exc).
        MESSAGE ID lr_hot_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER lr_hot_exc-&gt;if_t100_message~t100key-msgno.
    ENDTRY.

    FIELD-SYMBOLS: &lt;master&gt; TYPE o_cut-&gt;g_type_s_master,
                   &lt;slave&gt;  TYPE o_cut-&gt;g_type_s_slave.

    TRY.
        DATA(pkg1) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_1` ).
        DATA(pkg2) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_2` ).

        DATA(obj1) = cl_cts_hot_object_v1=&gt;create_instance(
                      iv_hana_package_id       = &apos;depl_test_1&apos;
                      iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                      iv_hana_object_suffix    = &apos;attributeview&apos; ).
        DATA(obj2) = cl_cts_hot_object_v1=&gt;create_instance(
                      iv_hana_package_id       = &apos;depl_test_2&apos;
                      iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                      iv_hana_object_suffix    = &apos;attributeview&apos; ).

      CATCH cx_hana_object_transport INTO DATA(hota_exc).
        DATA(t100_key) = hota_exc-&gt;if_t100_message~t100key.
        IF t100_key = cx_hana_object_transport=&gt;cx_nhi_hana_repository_error.
          DATA(nhi_exc) = CAST cx_nhi_hana_repository( hota_exc-&gt;previous ).
          t100_key = nhi_exc-&gt;if_t100_message~t100key.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
        ELSE.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH hota_exc-&gt;msgv1 hota_exc-&gt;msgv2 hota_exc-&gt;hana_error_code hota_exc-&gt;hana_error_msg DISPLAY LIKE &apos;E&apos;.
        ENDIF.
      CATCH cx_nhi_hana_repository INTO nhi_exc.
        t100_key = nhi_exc-&gt;if_t100_message~t100key.
        &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
        MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
    ENDTRY.

    o_cut-&gt;mt_master = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_new
    transport_obj_name = &apos;depl_test_1&apos; hana_package_id = &apos;depl_test_1&apos;
    hot_hana_package_id = &apos;depl_test_1&apos; package_id = &apos;depl_test_1&apos;
    cts_hot_package_ref = pkg1 )
    (
    exists_in_hota = abap_false
    transport_obj_name = &apos;depl_test_2&apos; hana_package_id = &apos;depl_test_2&apos;
    hot_hana_package_id = &apos;depl_test_2&apos; package_id = &apos;depl_test_2&apos;
    cts_hot_package_ref = pkg2 ) ).

    o_cut-&gt;mt_slave = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_new
    transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_1&apos; hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_1&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hana = abap_false exists_in_hota = abap_true
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj1 )
    (
    transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_2&apos; hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_2&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hota = abap_false
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj2 ) ).

    o_cut-&gt;calculate_depl_status( ).

* Test case 1: hot_status = new
    LOOP AT o_cut-&gt;mt_master ASSIGNING &lt;master&gt; WHERE hana_package_id = &apos;depl_test_1&apos;.
      result = &lt;master&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_inactive
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

    LOOP AT o_cut-&gt;mt_slave ASSIGNING &lt;slave&gt; WHERE hana_package_id = &apos;depl_test_1&apos;.
      result = &lt;slave&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_inactive
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

* Test case 2: exists in hota = false
    LOOP AT o_cut-&gt;mt_master ASSIGNING &lt;master&gt; WHERE hana_package_id = &apos;depl_test_2&apos;.
      result = &lt;master&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_inactive
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

    LOOP AT o_cut-&gt;mt_slave ASSIGNING &lt;slave&gt; WHERE hana_package_id = &apos;depl_test_2&apos;.
      result = &lt;slave&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_inactive
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

  ENDMETHOD.

  METHOD deploy_red.
    DATA: result TYPE icon_d.
    DATA: o_cut TYPE REF TO lcl_hota_organizer.

    TRY.
        CREATE OBJECT o_cut.
      CATCH cx_hana_object_transport INTO DATA(lr_hot_exc).
        MESSAGE ID lr_hot_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER lr_hot_exc-&gt;if_t100_message~t100key-msgno.
    ENDTRY.

    FIELD-SYMBOLS: &lt;master&gt; TYPE o_cut-&gt;g_type_s_master,
                   &lt;slave&gt;  TYPE o_cut-&gt;g_type_s_slave.

    TRY.
        DATA(pkg1) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_1` ).
        DATA(obj1) = cl_cts_hot_object_v1=&gt;create_instance(
                  iv_hana_package_id       = &apos;depl_test_1&apos;
                  iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                  iv_hana_object_suffix    = &apos;attributeview&apos; ).
        DATA(obj2) = cl_cts_hot_object_v1=&gt;create_instance(
                      iv_hana_package_id       = &apos;depl_test_1&apos;
                      iv_hana_object_name      = &apos;depl_test_b.attributeview&apos;
                      iv_hana_object_suffix    = &apos;attributeview&apos; ).
      CATCH cx_hana_object_transport INTO DATA(hota_exc).
        DATA(t100_key) = hota_exc-&gt;if_t100_message~t100key.
        IF t100_key = cx_hana_object_transport=&gt;cx_nhi_hana_repository_error.
          DATA(nhi_exc) = CAST cx_nhi_hana_repository( hota_exc-&gt;previous ).
          t100_key = nhi_exc-&gt;if_t100_message~t100key.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
        ELSE.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH hota_exc-&gt;msgv1 hota_exc-&gt;msgv2 hota_exc-&gt;hana_error_code hota_exc-&gt;hana_error_msg DISPLAY LIKE &apos;E&apos;.
        ENDIF.
      CATCH cx_nhi_hana_repository INTO nhi_exc.
        t100_key = nhi_exc-&gt;if_t100_message~t100key.
        &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
        MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
    ENDTRY.

    o_cut-&gt;mt_master = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_new
    exists_in_hana = abap_true exists_in_hota = abap_true
    transport_obj_name = &apos;depl_test_1&apos; hana_package_id = &apos;depl_test_1&apos;
    hot_hana_package_id = &apos;depl_test_2&apos; package_id = &apos;depl_test_1&apos;
    cts_hot_package_ref = pkg1 ) ).

    o_cut-&gt;mt_slave = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_new
   transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
   hana_package_id = &apos;depl_test_1&apos; hot_hana_package_id = &apos;depl_test_2&apos;
   hana_object_name = &apos;depl_test_a.attributeview&apos;
   abap_hana_package_id = &apos;depl_test_1&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
   exists_in_hana = abap_true exists_in_hota = abap_true
   hana_object_status = &apos;A&apos; cts_hot_object_ref = obj1 )
   ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_new
   transport_obj_name = &apos;depl_test_b&apos; hot_hana_object_suffix = &apos;attributeview&apos;
   hana_package_id = &apos;depl_test_1&apos; hana_object_name = &apos;depl_test_b.attributeview&apos;
   abap_hana_package_id = &apos;depl_test_1&apos; object_suffix = &apos;depl_test_b.attributeview&apos;
   exists_in_hana = abap_false exists_in_hota = abap_true
   hana_object_status = &apos;A&apos; cts_hot_object_ref = obj2 ) ).

    o_cut-&gt;calculate_depl_status( ).

* Test case 1: hana package id &lt;&gt; hot_hana_package_id
    LOOP AT o_cut-&gt;mt_master ASSIGNING &lt;master&gt; WHERE hana_package_id = &apos;depl_test_1&apos;.
      result = &lt;master&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_red
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

    LOOP AT o_cut-&gt;mt_slave ASSIGNING &lt;slave&gt; WHERE hana_package_id = &apos;depl_test_1&apos;.
      result = &lt;slave&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_red
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

* Test case 2: &lt;master&gt;-sync_deploy_state = red
    LOOP AT o_cut-&gt;mt_slave ASSIGNING &lt;slave&gt; WHERE transport_obj_name = &apos;depl_test_b&apos;.
      result = &lt;slave&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_red
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

  ENDMETHOD.

  METHOD deploy_green.
    DATA: result TYPE icon_d.
    DATA: o_cut TYPE REF TO lcl_hota_organizer.

    TRY.
        CREATE OBJECT o_cut.
      CATCH cx_hana_object_transport INTO DATA(lr_hot_exc).
        MESSAGE ID lr_hot_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER lr_hot_exc-&gt;if_t100_message~t100key-msgno.
    ENDTRY.

    FIELD-SYMBOLS: &lt;master&gt; TYPE o_cut-&gt;g_type_s_master,
                   &lt;slave&gt;  TYPE o_cut-&gt;g_type_s_slave.


    TRY.
        DATA(pkg1) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_1` ).
        DATA(pkg2) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_2` ).
        DATA(pkg3) = cl_cts_hot_package=&gt;create_instance( iv_hana_package_id = `depl_test_3` ).
        DATA(obj1) = cl_cts_hot_object_v1=&gt;create_instance(
                  iv_hana_package_id       = &apos;depl_test_1&apos;
                  iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
                  iv_hana_object_suffix    = &apos;attributeview&apos; ).
        DATA(obj2) = cl_cts_hot_object_v1=&gt;create_instance(
    iv_hana_package_id       = &apos;depl_test_2&apos;
    iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
    iv_hana_object_suffix    = &apos;attributeview&apos; ).
        DATA(obj3) = cl_cts_hot_object_v1=&gt;create_instance(
iv_hana_package_id       = &apos;depl_test_3&apos;
iv_hana_object_name      = &apos;depl_test_a.attributeview&apos;
iv_hana_object_suffix    = &apos;attributeview&apos; ).
      CATCH cx_hana_object_transport INTO DATA(hota_exc).
        DATA(t100_key) = hota_exc-&gt;if_t100_message~t100key.
        IF t100_key = cx_hana_object_transport=&gt;cx_nhi_hana_repository_error.
          DATA(nhi_exc) = CAST cx_nhi_hana_repository( hota_exc-&gt;previous ).
          t100_key = nhi_exc-&gt;if_t100_message~t100key.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
        ELSE.
          &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
          MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH hota_exc-&gt;msgv1 hota_exc-&gt;msgv2 hota_exc-&gt;hana_error_code hota_exc-&gt;hana_error_msg DISPLAY LIKE &apos;E&apos;.
        ENDIF.
      CATCH cx_nhi_hana_repository INTO nhi_exc.
        t100_key = nhi_exc-&gt;if_t100_message~t100key.
        &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
        MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
    ENDTRY.

    o_cut-&gt;mt_master = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_active
    exists_in_hana = abap_true exists_in_hota = abap_true
    transport_obj_name = &apos;depl_test_1&apos; hana_package_id = &apos;depl_test_1&apos;
    hot_hana_package_id = &apos;depl_test_1&apos; package_id = &apos;depl_test_1&apos;
    cts_hot_package_ref = pkg1 )
               ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_active
    exists_in_hana = abap_true exists_in_hota = abap_true
    transport_obj_name = &apos;depl_test_2&apos; hana_package_id = &apos;depl_test_2&apos;
    hot_hana_package_id = &apos;depl_test_2&apos; package_id = &apos;depl_test_2&apos;
    hana_src_system = &apos;YI3&apos; cts_hot_package_ref = pkg2 )
            ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_active
    exists_in_hana = abap_false exists_in_hota = abap_true
    transport_obj_name = &apos;depl_test_3&apos; hana_package_id = &apos;depl_test_3&apos;
    hot_hana_package_id = &apos;depl_test_3&apos; package_id = &apos;depl_test_3&apos;
    cts_hot_package_ref = pkg3 )
    ).

    o_cut-&gt;mt_slave = VALUE #( ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_active
   transport_obj_name = &apos;depl_test_a&apos;
   hot_hana_object_suffix = &apos;attributeview&apos; hana_object_suffix = &apos;attributeview&apos;
   hana_package_id = &apos;depl_test_1&apos; hot_hana_package_id = &apos;depl_test_1&apos;
   hana_object_name = &apos;depl_test_a.attributeview&apos; hot_hana_object_name  = &apos;depl_test_a.attributeview&apos;
   abap_hana_package_id = &apos;depl_test_1&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
   exists_in_hana = abap_true exists_in_hota = abap_true
   hana_version = 1 hot_version = 1
   hana_object_status = &apos;A&apos; cts_hot_object_ref = obj1 )
          ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_active transport_obj_name = &apos;depl_test_a&apos;
    hot_hana_object_suffix = &apos;attributeview&apos; hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_2&apos; hot_hana_package_id = &apos;depl_test_2&apos;
    hana_object_name = &apos;depl_test_a.attributeview&apos; hot_hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_2&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hana = abap_true exists_in_hota = abap_true
    hana_version = 1 hot_version = 2 hana_activated_by = &apos;test&apos;
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj2 )
    ( hot_status = if_cts_hot_db_access=&gt;co_hot_status_active
    transport_obj_name = &apos;depl_test_a&apos; hot_hana_object_suffix = &apos;attributeview&apos;
    hana_package_id = &apos;depl_test_3&apos; hana_object_name = &apos;depl_test_a.attributeview&apos;
    abap_hana_package_id = &apos;depl_test_3&apos; object_suffix = &apos;depl_test_a.attributeview&apos;
    exists_in_hana = abap_false exists_in_hota = abap_true
    hana_object_status = &apos;A&apos; cts_hot_object_ref = obj3 )
).
    o_cut-&gt;calculate_depl_status( ).

* Test case 1: hot_status = active, equivalent versions
    LOOP AT o_cut-&gt;mt_master ASSIGNING &lt;master&gt; WHERE hana_package_id = &apos;depl_test_1&apos;.
      result = &lt;master&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_green
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

    LOOP AT o_cut-&gt;mt_slave ASSIGNING &lt;slave&gt; WHERE hana_package_id = &apos;depl_test_1&apos;.
      result = &lt;slave&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_green
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

*     Test case 2: hot_status = active, varying versions
    LOOP AT o_cut-&gt;mt_master ASSIGNING &lt;master&gt; WHERE hana_package_id = &apos;depl_test_2&apos;.
      result = &lt;master&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_green
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

    LOOP AT o_cut-&gt;mt_slave ASSIGNING &lt;slave&gt; WHERE hana_package_id = &apos;depl_test_2&apos;.
      result = &lt;slave&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_green
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

* Test case 3: hot_status = active, exists in hana = false
    LOOP AT o_cut-&gt;mt_master ASSIGNING &lt;master&gt; WHERE hana_package_id = &apos;depl_test_3&apos;.
      result = &lt;master&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_green
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

    LOOP AT o_cut-&gt;mt_slave ASSIGNING &lt;slave&gt; WHERE hana_package_id = &apos;depl_test_3&apos;.
      result = &lt;slave&gt;-sync_deploy_state .
    ENDLOOP.

    cl_aunit_assert=&gt;assert_equals( act    = result
                                    exp    = icon_led_green
                                    msg    = &apos;The status is wrong.&apos; ).
    CLEAR result.

  ENDMETHOD.
ENDCLASS.

*----------------------------------------------------------------------*
DATA gr_hot_organizer TYPE REF TO lcl_hota_organizer.

*----------------------------------------------------------------------*
* INITIALIZATION
*----------------------------------------------------------------------*
INITIALIZATION.

  IF sy-tcode = &apos;SCTS_HTA_DEPLOY&apos;.
    SET PF-STATUS &apos;START_DEPL&apos;.
    SET TITLEBAR &apos;DEPLOYMENT&apos;.
    gv_sync = &apos; &apos;.
    gv_depl = &apos;X&apos;.
  ELSE.
    SET PF-STATUS &apos;START_SYNC&apos;.
    SET TITLEBAR &apos;SYNCHRONISATION&apos;.
    gv_sync = &apos;X&apos;.
    gv_depl = &apos; &apos;.
  ENDIF.

  TRY.
      CREATE OBJECT gr_hot_organizer.
    CATCH cx_hana_object_transport INTO DATA(lr_hot_exc).
      MESSAGE ID lr_hot_exc-&gt;if_t100_message~t100key-msgid TYPE &apos;E&apos; NUMBER lr_hot_exc-&gt;if_t100_message~t100key-msgno.
  ENDTRY.
  &quot;TODO: HOTA READ ONLY MODUS ???? not yet possible for DB not equal HANA
*----------------------------------------------------------------------*
* SELECTION-SCREEN                                                     *
*----------------------------------------------------------------------*
  SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE lv_title.
  PARAMETERS:
    pv_pack TYPE cts_hot_package-hana_package_id LOWER CASE MEMORY ID hta_pack,
    pv_sub  TYPE abap_bool AS CHECKBOX DEFAULT abap_false MEMORY ID hta_sub. &quot;handle ALL subpackages as well
  SELECTION-SCREEN END OF BLOCK b1.

  DATA lv_pack(40).
*
  GET PARAMETER ID &apos;hta_pack&apos; FIELD lv_pack.
  pv_pack = lv_pack.

  IF sy-tcode = &apos;SCTS_HTA_DEPLOY&apos;.
    lv_title = &apos;Paketauswahl für Deployment&apos;(231).
  ELSE.
    lv_title = &apos;Paketauswahl für Synchronisierung&apos;(100).
  ENDIF.


*----------------------------------------------------------------------*
* START-OF-SELECTION                                                   *
*----------------------------------------------------------------------*
START-OF-SELECTION.
*----------------------------------------------------------------------*
* AT SELECTION-SCREEN.                                                 *
*----------------------------------------------------------------------*
AT SELECTION-SCREEN.

  CASE sy-ucomm.
    WHEN &apos;AUSF&apos;.
      IF pv_pack IS INITIAL OR pv_pack = &apos;*&apos;.
        MESSAGE &apos;Geben Sie ein SAP-HANA-Repository-Paket an&apos;(003) TYPE &apos;E&apos;.
      ELSE.
        TRY.
            gr_hot_organizer-&gt;select_data( i_hana_package_name = pv_pack i_include_subpackages = pv_sub ).
          CATCH cx_hana_object_transport INTO DATA(hota_exc).
            DATA(t100_key) = hota_exc-&gt;if_t100_message~t100key.
            MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH hota_exc-&gt;msgv1 hota_exc-&gt;msgv2 hota_exc-&gt;hana_error_code hota_exc-&gt;hana_error_msg.
          CATCH cx_nhi_hana_repository INTO DATA(nhi_exc).
            t100_key = nhi_exc-&gt;if_t100_message~t100key.
            MESSAGE ID t100_key-msgid TYPE &apos;E&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4.
        ENDTRY.

        lv_pack = pv_pack.
        SET PARAMETER ID: &apos;hta_pack&apos; FIELD lv_pack.

        gr_hot_organizer-&gt;display_data( ).
      ENDIF.

    WHEN &apos;&amp;F03&apos; OR &apos;&amp;F12&apos; OR &apos;&amp;F15&apos;.
      DATA: lv_pack(40).
      lv_pack = pv_pack.

      SET PARAMETER ID: &apos;hta_pack&apos; FIELD lv_pack.
      LEAVE PROGRAM.

    WHEN &apos;INFO_S&apos;.
      CALL FUNCTION &apos;DSYS_SHOW_FOR_F1HELP&apos;
        EXPORTING
          dokclass = &apos;TX&apos; &quot; allgemeiner Text - SE61
          dokname  = &apos;CTS_HTA_INTRO_SYNC&apos;
*         short_text = &apos;X&apos;
        EXCEPTIONS
          OTHERS   = 1.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

    WHEN &apos;INFO_D&apos;.
      CALL FUNCTION &apos;DSYS_SHOW_FOR_F1HELP&apos;
        EXPORTING
          dokclass = &apos;TX&apos; &quot; allgemeiner Text - SE61
          dokname  = &apos;CTS_HTA_INTRO_DEPL&apos;
*         short_text = &apos;X&apos;
        EXCEPTIONS
          OTHERS   = 1.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

    WHEN &apos;SYNC_T&apos;.
      lv_pack = pv_pack.

      SET PARAMETER ID: &apos;hta_pack&apos; FIELD lv_pack.

      CALL TRANSACTION &apos;SCTS_HTA&apos; WITH AUTHORITY-CHECK.

    WHEN &apos;DEPL_T&apos;.
      lv_pack = pv_pack.

      SET PARAMETER ID: &apos;hta_pack&apos; FIELD lv_pack.

      CALL TRANSACTION &apos;SCTS_HTA_DEPLOY&apos; WITH AUTHORITY-CHECK.
  ENDCASE.

*----------------------------------------------------------------------*
* AT SELECTION-SCREEN OUTPUT.                                          *
*----------------------------------------------------------------------*
*AT SELECTION-SCREEN OUTPUT.
*   comment = &apos;Der Organizer zeigt fuer das gewaehlte Paket bzw. die gewaehlten Pakete die Daten aus dem SAP HANA Repository an und vergleicht diese mit den Daten die aktuell im HOTA Repository liegen. Bei der Paketwahl wird * als Wildcard untesrtuetzt.&apos;.

*----------------------------------------------------------------------*
* AT SELECTION-SCREEN - F4 Help                                                     *
*----------------------------------------------------------------------*
AT SELECTION-SCREEN ON VALUE-REQUEST FOR pv_pack.
  DATA(lv_user_input_string) = gr_hot_organizer-&gt;read_user_value( &apos;PV_PACK&apos; ).
  DATA(lv_include_subpackages) = gr_hot_organizer-&gt;read_user_value( &apos;PV_SUB&apos; ).

  TRY.
      pv_pack = gr_hot_organizer-&gt;f4help_packages( i_hana_package_name = lv_user_input_string i_include_subpackages = CONV abap_bool( lv_include_subpackages ) ).
    CATCH cx_hana_object_transport INTO DATA(hota_exc).
      DATA(t100_key) = hota_exc-&gt;if_t100_message~t100key.
      IF t100_key = cx_hana_object_transport=&gt;cx_nhi_hana_repository_error.
        DATA(nhi_exc) = CAST cx_nhi_hana_repository( hota_exc-&gt;previous ).
        t100_key = nhi_exc-&gt;if_t100_message~t100key.
        &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
        MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
      ELSE.
        &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
        MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH hota_exc-&gt;msgv1 hota_exc-&gt;msgv2 hota_exc-&gt;hana_error_code hota_exc-&gt;hana_error_msg DISPLAY LIKE &apos;E&apos;.
      ENDIF.
    CATCH cx_nhi_hana_repository INTO nhi_exc.
      t100_key = nhi_exc-&gt;if_t100_message~t100key.
      &quot;Type &apos;E&apos; not possible (dumps) in AT SELECTION-SCREEN ON VALUE-REQUEST
      MESSAGE ID t100_key-msgid TYPE &apos;I&apos; NUMBER t100_key-msgno WITH nhi_exc-&gt;msgv1 nhi_exc-&gt;msgv2 nhi_exc-&gt;msgv3 nhi_exc-&gt;msgv4 DISPLAY LIKE &apos;E&apos;.
  ENDTRY.


*----------------------------------------------------------------------*
* END-OF-SELECTION                                                     *
*----------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp; Module STATUS_2000 OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;---------------------------------------------------------------------*
MODULE status_2000 OUTPUT.

  DATA: fcode    TYPE TABLE OF sy-ucomm,
        wa_fcode TYPE sy-ucomm.
  DATA: green    TYPE c,
        inactive TYPE c,
        yellow   TYPE c,
        red      TYPE c.
  DATA: lv_initialized TYPE c.
  DATA: no_p_green(6)    TYPE c,
        no_o_green(6)    TYPE c,
        no_p_yellow(6)   TYPE c,
        no_o_yellow(6)   TYPE c,
        no_p_red(6)      TYPE c,
        no_o_red(6)      TYPE c,
        no_p_inactive(6) TYPE c,
        no_o_inactive(6) TYPE c,
        text_green       TYPE string,
        text_yellow      TYPE string,
        text_red         TYPE string,
        text_inactive    TYPE string,
        text_pakete_1    TYPE string,
        text_pakete_2    TYPE string,
        text_pakete_3    TYPE string,
        text_pakete_4    TYPE string,
        text_objekte_1   TYPE string,
        text_objekte_2   TYPE string,
        text_objekte_3   TYPE string,
        text_objekte_4   TYPE string.

  text_pakete_1 = text_pakete_2 = text_pakete_3 = text_pakete_4 = &apos;Packages /&apos;(232).
  text_objekte_1 = text_objekte_2 = text_objekte_3 = text_objekte_4 = &apos;Objects&apos;(234).

  wa_fcode = &apos;SYNC &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;ETA &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;REFRESH &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;DESEL_ALL &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;SEL_PACK &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;DESEL_PACK &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;SEL_SYNC &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;OL0 &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;SELECT_ALL &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;OAD &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;AVE &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;CRL &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;CRR &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;CRB &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;&amp;CRE &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;LEGEND &apos;. APPEND wa_fcode TO fcode.
  wa_fcode = &apos;INFO&apos;. APPEND wa_fcode TO fcode.

  SET PF-STATUS &apos;HOTA_SYNC&apos; EXCLUDING fcode.
  SET TITLEBAR &apos;FILTER_TITEL&apos;.

  IF gv_sync = &apos;X&apos;.
    text_green = &apos;Package/object is in sync&apos;(143).
    text_yellow = &apos;Package/object is not in sync&apos;(144).
    text_red = &apos;Cannot synchronize package/object&apos;(145).
    text_inactive = &apos;Cannot synchronize package/object&apos;(145).
  ELSEIF gv_depl = &apos;X&apos;.
    text_green = &apos;Package/object is deployed&apos;(230).
    text_yellow = &apos;Package/object not deployed&apos;(211).
    text_red = &apos;Package/object cannot be deployed&apos;(212).
    text_inactive = &apos;Package/object cannot be deployed&apos;(212).
  ENDIF.

  DATA(ls_filter_data) = gr_hot_organizer-&gt;get_filter_data( ).

  green = ls_filter_data-show_green.
  yellow = ls_filter_data-show_yellow.
  red = ls_filter_data-show_red.
  inactive = ls_filter_data-show_inactive.
  no_p_green = ls_filter_data-nr_packages_green.
  no_p_yellow = ls_filter_data-nr_packages_yellow.
  no_p_red = ls_filter_data-nr_packages_red.
  no_p_inactive = ls_filter_data-nr_packages_inactive.
  no_o_green = ls_filter_data-nr_objects_green.
  no_o_yellow = ls_filter_data-nr_objects_yellow.
  no_o_red = ls_filter_data-nr_objects_red.
  no_o_inactive = ls_filter_data-nr_objects_inactive.

  IF sy-ucomm = &apos;&amp;F12&apos;.
    LEAVE TO SCREEN 0.
  ENDIF.

ENDMODULE.
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_2000  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_2000 INPUT.
  IF sy-ucomm = &apos;FILTER&apos;.
    gr_hot_organizer-&gt;apply_filter( i_green = green
                                    i_yellow = yellow
                                    i_red = red
                                    i_inactive = inactive ).
  ENDIF.

  LEAVE TO SCREEN 0.
ENDMODULE.</source>
 </PROG>
 <PROG NAME="Z_A_BC_TRANSPORT_DEPENDENCIES" VARCL="X" SUBC="1" APPL="*" RSTAT="K" RMAND="200" RLOAD="F" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="001" ENTRY="Oui" LENGTH="13 "/>
    <textElement ID="I" KEY="002" ENTRY="Non" LENGTH="13 "/>
    <textElement ID="I" KEY="Q01" ENTRY="Aucune dépendance saisie. Voulez-vous poursuivre le traitement ?" LENGTH="132 "/>
    <textElement ID="I" KEY="TB1" ENTRY="Ordre de Transport" LENGTH="28 "/>
    <textElement ID="I" KEY="TB2" ENTRY="Liste OTs dépendances" LENGTH="42 "/>
    <textElement ID="R" ENTRY="Transport - Dépendances" LENGTH="23 "/>
    <textElement ID="S" KEY="P_TKRORR" ENTRY="        OT" LENGTH="10 "/>
    <textElement ID="S" KEY="S_TRKORR" ENTRY="        Dépendances" LENGTH="22 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_A_BC_TRANSPORT_DEPENDENCIES
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*
REPORT z_a_bc_transport_dependencies.

DATA :
  gv_done   TYPE xsdboolean,
  gv_trkorr TYPE e070-trkorr.

DATA :
      gt_attributes TYPE trwbo_t_e070a.

***==================================================================***
**                         SELECTION-SCREEN                           **
***==================================================================***

TABLES : e070.

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-tb1.
&quot; -----------------------------------------------------------
&quot; Critère de sélection
&quot; -----------------------------------------------------------

&quot; OT
PARAMETERS : p_tkrorr TYPE e070-trkorr.

SELECTION-SCREEN SKIP 1.

SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE text-tb2.
&quot; -----------------------------------------------------------
&quot; Liste OT dépendances
&quot; -----------------------------------------------------------

&quot; Dépendance
SELECT-OPTIONS : s_trkorr FOR e070-trkorr NO INTERVALS MODIF ID loc.

SELECTION-SCREEN END OF BLOCK b2.

PARAMETERS : p_attr TYPE e070a-attribute
                 DEFAULT zcl_transport_request_celio=&gt;mc_attribute_dependencies
                      NO-DISPLAY.

SELECTION-SCREEN END OF BLOCK b1.

***==================================================================***
**                     AT SELECTION-SCREEN OUTPUT                     **
***==================================================================***
AT SELECTION-SCREEN OUTPUT.
  PERFORM at_selection_screen_output.


START-OF-SELECTION.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
        lt_attributes TYPE trwbo_t_e070a.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
     lv_answer TYPE char1.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF p_tkrorr IS INITIAL.
    &quot; OT obligatoire
    &quot;&quot;  --&gt; Arrêt du traitement
    MESSAGE s008(ztools) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
    RETURN.

  ENDIF.

  IF gv_done EQ abap_false.
    &quot; Pas de modification de l&apos;écran de sélection
    &quot;&quot;  --&gt; Veuillez d&apos;abord valider la saisie de l&apos;OT
    MESSAGE s008(ztools) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
    RETURN.

  ENDIF.

  IF s_trkorr[] IS INITIAL.
    &quot; Aucune dépendance
    &quot;&quot;  --&gt; PopUp Confirmation
    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        titlebar              = text-tb2
        text_question         = text-q01
        text_button_1         = text-001
        text_button_2         = text-002
        default_button        = &apos;1&apos; ##NOTEXT
        display_cancel_button = abap_true
      IMPORTING
        answer                = lv_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF sy-subrc NE 0 OR lv_answer NE &apos;1&apos;.
      &quot; L&apos;utiisateur ne souhaite pas poursuivre
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Initialisation Attribut
  &quot; -----------------------------------------------------------

  &quot; Suppression des Dépendances
  DELETE gt_attributes WHERE attribute EQ p_attr.

  &quot; Ajout des Attributs
  LOOP AT s_trkorr ASSIGNING FIELD-SYMBOL(&lt;lfs_s_trkorr&gt;).

    APPEND VALUE #(
     trkorr    = p_tkrorr
     attribute = p_attr
     reference = &lt;lfs_s_trkorr&gt;-low
    ) TO gt_attributes.

  ENDLOOP.

  &quot; Tri et suppression doublon
  SORT gt_attributes BY attribute reference.
  DELETE ADJACENT DUPLICATES FROM gt_attributes COMPARING attribute reference.

  &quot; -----------------------------------------------------------
  &quot; MàJ Attribut
  &quot; -----------------------------------------------------------

  &quot; Modification des dépendances
  CALL FUNCTION &apos;TR_REPLACE_ATTRIBUTES&apos;
    EXPORTING
      iv_request        = p_tkrorr
      it_attributes     = gt_attributes
    IMPORTING
      et_attributes     = gt_attributes
    EXCEPTIONS
      invalid_request   = 1
      invalid_attribute = 2
      no_authorization  = 3
      enqueue_failed    = 4
      db_access_error   = 5
      OTHERS            = 6.
  IF sy-subrc NE 0.
    &quot; Erreur lors de la MàJ
    &quot;&quot;  --&gt; Rollback
    MESSAGE s010(ztools) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
    CALL FUNCTION &apos;BAPI_TRANSACTION_ROLLBACK&apos;.

  ELSE.
    &quot; MàJ effectuée
    &quot;&quot;  --&gt; Commit
    MESSAGE s011(ztools) DISPLAY LIKE if_msg_output=&gt;msgtype_success.
    CALL FUNCTION &apos;BAPI_TRANSACTION_COMMIT&apos;.

  ENDIF.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  AT_SELECTION_SCREEN_OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM at_selection_screen_output.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot;
  &quot; -----------------------------------------------------------

  IF p_tkrorr NE gv_trkorr.
    &quot; Changement numéro OT
    &quot;&quot;  --&gt; Réinitialise témoin
    CLEAR : gv_done.

    &quot;&quot;  --&gt; Changement OT
    gv_trkorr = p_tkrorr.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  &quot; Récupération des Attributs de l&apos;OT
  CALL FUNCTION &apos;TR_READ_ATTRIBUTES&apos;
    EXPORTING
      iv_request       = p_tkrorr
    IMPORTING
      et_attributes    = gt_attributes
    EXCEPTIONS
      invalid_request  = 1
      no_authorization = 2
      OTHERS           = 3.
  IF sy-subrc NE 0.
    &quot; Erreur lecture attribut
    &quot;&quot;  --&gt; Réinitialise la liste
    REFRESH : s_trkorr.

  ENDIF.

  LOOP AT SCREEN INTO DATA(ls_screen).

    CASE ls_screen-group1.

      WHEN &apos;LOC&apos;. ##NOTEXT
        &quot; Liste OT
        IF gv_done EQ abap_false.
          &quot;&quot;  --&gt; Charge la liste
          LOOP AT gt_attributes ASSIGNING FIELD-SYMBOL(&lt;lfs_s_attributes&gt;)
            WHERE attribute EQ p_attr.

            APPEND VALUE #(
              low    = &lt;lfs_s_attributes&gt;-reference
              sign   = if_trba_selection_c=&gt;gc_sign_incl
              option = if_trba_selection_c=&gt;gc_option_eq
            ) TO s_trkorr.

          ENDLOOP.
          IF sy-subrc NE 0.
            &quot; Aucun Attribut de Dépendance
            &quot;&quot;  --&gt; Réinitialise la liste
            REFRESH : s_trkorr.

          ENDIF.

          &quot; Témoin traitement effectué
          gv_done = abap_true.

        ENDIF.

      WHEN OTHERS.
        &quot; Autre
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

    ENDCASE.

    &quot; Modification écran
    MODIFY screen FROM ls_screen.

  ENDLOOP.

ENDFORM.</source>
 </PROG>
 <PROG NAME="Z_A_BC_TRANSPORT_CHECK" VARCL="X" SUBC="1" APPL="*" RSTAT="K" RMAND="200" RLOAD="F" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="E00" ENTRY="@0A@" LENGTH="14 "/>
    <textElement ID="I" KEY="I00" ENTRY="@09@" LENGTH="14 "/>
    <textElement ID="I" KEY="MES" ENTRY="Message" LENGTH="17 "/>
    <textElement ID="I" KEY="MIS" ENTRY="OT manquant" LENGTH="21 "/>
    <textElement ID="I" KEY="S00" ENTRY="@08@" LENGTH="14 "/>
    <textElement ID="I" KEY="SOI" ENTRY="Séquence saisie" LENGTH="24 "/>
    <textElement ID="I" KEY="SOP" ENTRY="Séquence proposée" LENGTH="27 "/>
    <textElement ID="I" KEY="TB1" ENTRY="Critères de sélection" LENGTH="42 "/>
    <textElement ID="I" KEY="TB2" ENTRY="Options supplémentaires" LENGTH="46 "/>
    <textElement ID="I" KEY="TB3" ENTRY="Options de contrôle" LENGTH="48 "/>
    <textElement ID="R" ENTRY="Transport - Contrôle Ordre de Transport" LENGTH="39 "/>
    <textElement ID="S" KEY="P_IOLDV" ENTRY='        Ignorer Versions &quot;abstentes&quot;' LENGTH="36 "/>
    <textElement ID="S" KEY="P_IRECEN" ENTRY="        Ignorer Versions plus récente" LENGTH="37 "/>
    <textElement ID="S" KEY="P_PROP" ENTRY="        Proposer Ordre de séquence" LENGTH="34 "/>
    <textElement ID="S" KEY="P_REIMP" ENTRY="        Réimport" LENGTH="16 "/>
    <textElement ID="S" KEY="P_REQ" ENTRY="D       ." LENGTH="18 "/>
    <textElement ID="S" KEY="P_SYSID" ENTRY="        Système cible" LENGTH="21 "/>
    <textElement ID="S" KEY="S_EXC_OT" ENTRY="        Liste OT à exclure" LENGTH="26 "/>
    <textElement ID="S" KEY="S_TRKORR" ENTRY="D       ." LENGTH="19 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Programme       : Z_A_BC_TRANSPORT_CHECK                            *
*&amp; Description     : Contrôle cohérence d&apos;une Demande de Transport     *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Créé par     : Olivier Véhier                                       *
*                                                                      *
*&amp; Créé le      : 15/07/2020                                           *
*                                                                      *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp; Liste des modifications                                             *
*&amp; Auteur      Date       Signature  Objet de la modification          *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*                                                                      *

REPORT z_a_bc_transport_check.

TABLES : e070, ztbrequest.

***==================================================================***
**                         SELECTION-SCREEN                           **
***==================================================================***

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-tb1.
&quot; -----------------------------------------------------------
&quot; Critères de sélection
&quot; -----------------------------------------------------------

&quot; Numéro de Demande
PARAMETERS : p_req TYPE ztbrequest-zedreqnb.

&quot; Liste OT
SELECT-OPTIONS : s_trkorr FOR e070-trkorr NO INTERVALS.

&quot; Système Cible
PARAMETERS : p_sysid TYPE ztbdestrfc-zedtargsys.

SELECTION-SCREEN END OF BLOCK b1.

SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE text-tb2.
&quot; -----------------------------------------------------------
&quot; Options
&quot; -----------------------------------------------------------

&quot; Proposer Ordre de séquence
PARAMETERS : p_prop AS CHECKBOX MODIF ID pro. &quot; DEFAULT &apos;X&apos;.                &quot;#EC NOTEXT

SELECTION-SCREEN BEGIN OF BLOCK b3 WITH FRAME TITLE text-tb3.

&quot; Suggérer OT plus récent
PARAMETERS : p_irecen AS CHECKBOX.                          &quot;#EC NOTEXT

&quot; Contrôle toutes les Versions
PARAMETERS : p_ioldv AS CHECKBOX.

&quot; Réimport
PARAMETERS : p_reimp AS CHECKBOX.

SELECTION-SCREEN END OF BLOCK b3.

&quot; Liste OT volontairement exclus
SELECT-OPTIONS : s_exc_ot FOR e070-trkorr NO INTERVALS.

SELECTION-SCREEN END OF BLOCK b2.

*----------------------------------------------------------------------*
*       CLASS LCL_main DEFINIION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_main DEFINITION FINAL CREATE PRIVATE.

*-- Publique
  PUBLIC SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Génération instance de la Classe
    CLASS-METHODS factory
      RETURNING VALUE(ro_instance) TYPE REF TO lcl_main.

    &quot; Modification écran de sélectio
    METHODS at_selection_screen_ouput.

    &quot; Système Cible - Aide à la recherche
    METHODS sysid_value_help.

    &quot; Traitement Principal
    METHODS start_of_selection
      RETURNING VALUE(rv_subrc) TYPE sy-subrc.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs

*-- Privée
  PRIVATE SECTION.

***------------------------------------------------------------------***
**                              TYPES                                 **
***------------------------------------------------------------------***

*   Déclaration de type

    TYPES :
      BEGIN OF ts_sel_criteria_sel,
        or_trkorr  LIKE REF TO s_trkorr[],
        ov_request LIKE REF TO p_req,
      END OF   ts_sel_criteria_sel.

    TYPES :
      BEGIN OF ts_sel_criteria_option,
        ov_reimport           LIKE REF TO p_reimp,
        ov_target_sys         LIKE REF TO p_sysid,
        ov_proposal_seq       LIKE REF TO p_prop,
        ov_ignore_recent      LIKE REF TO p_irecen,
        or_excluded_trkorr    LIKE REF TO s_exc_ot[],
        ov_ignore_old_version LIKE REF TO p_ioldv,
      END OF   ts_sel_criteria_option.

    TYPES :
      BEGIN OF ts_selection_criteria,
        criteria TYPE lcl_main=&gt;ts_sel_criteria_sel,
        options  TYPE lcl_main=&gt;ts_sel_criteria_option,
      END OF   ts_selection_criteria.


    TYPES :
      BEGIN OF ts_sequence,
        trkorr_main    TYPE e070-trkorr,
        trkorr_task    TYPE e070-trkorr,
        trfunction     TYPE e070-trfunction,
        sequence_order TYPE ztborderseq-zedreqpos,
      END OF   ts_sequence.

    TYPES : tt_sequence TYPE STANDARD TABLE OF ts_sequence
                    WITH NON-UNIQUE KEY primary_key COMPONENTS trkorr_main
                    WITH NON-UNIQUE SORTED KEY ot_key COMPONENTS trkorr_main
                    WITH NON-UNIQUE SORTED KEY task_key COMPONENTS trkorr_task.
    TYPES :
      BEGIN OF ts_e071,
        trkorr   TYPE e071-trkorr,
        pgmid    TYPE e071-pgmid,
        object   TYPE e071-object,
        obj_name TYPE e071-obj_name,
      END OF   ts_e071.

    TYPES : tt_e071 TYPE STANDARD TABLE OF ts_e071
                    WITH NON-UNIQUE KEY primary_key COMPONENTS trkorr pgmid object obj_name.

    TYPES :
      BEGIN OF ts_vrsd,
        objtype TYPE vrsd-objtype,
        objname TYPE vrsd-objname,
        versno  TYPE vrsd-versno,
        korrnum TYPE vrsd-korrnum,
      END OF   ts_vrsd.

    TYPES : tt_vrsd TYPE STANDARD TABLE OF ts_vrsd
                    WITH NON-UNIQUE KEY primary_key COMPONENTS objtype objname versno
                    WITH NON-UNIQUE SORTED KEY object_key COMPONENTS objtype objname
                    WITH NON-UNIQUE SORTED KEY ot_key COMPONENTS korrnum.

    TYPES :
      BEGIN OF ts_result,
        type                   TYPE sy-msgty,
        icon                   TYPE icon-id,
        trkorr                 TYPE e070-trkorr,
        sequence_order_input   TYPE ztborderseq-zedreqpos,
        sequence_order_prop    TYPE ztborderseq-zedreqpos,
        objtype                TYPE vrsd-objtype,
        objname                TYPE vrsd-objname,
        versno                 TYPE vrsd-versno,
        message                TYPE string,
        import_date            TYPE sy-datum,
        import_time            TYPE sy-uzeit,
        use_sequence_order     TYPE xsdboolean,
        not_in_previous_system TYPE xsdboolean,
      END OF   ts_result.

    TYPES : tt_result TYPE STANDARD TABLE OF ts_result
                    WITH NON-UNIQUE KEY primary_key COMPONENTS trkorr objtype objname
                    WITH NON-UNIQUE SORTED KEY object_key_vers COMPONENTS objtype objname versno.

    TYPES :
      BEGIN OF ts_e070a,
        trkorr    TYPE e070a-trkorr,
        attribute TYPE e070a-attribute,
        reference TYPE e070a-reference,
      END OF   ts_e070a.

    TYPES : tt_e070a TYPE SORTED TABLE OF ts_e070a
                    WITH NON-UNIQUE KEY primary_key COMPONENTS trkorr attribute.

    TYPES :
      BEGIN OF ts_output_length,
        message TYPE lvc_outlen,
        objname TYPE lvc_outlen,
      END OF   ts_output_length.

    TYPES :
      BEGIN OF ts_output_format,
        length TYPE lcl_main=&gt;ts_output_length,
      END OF   ts_output_format.

    TYPES :
      BEGIN OF ts_result_check,
        error           TYPE xsdboolean,
        has_more_recent TYPE xsdboolean,
        t_result        TYPE lcl_main=&gt;tt_result,
      END OF   ts_result_check.

    TYPES :
      BEGIN OF ts_sequence_data,
        t_vrsd               TYPE lcl_main=&gt;tt_vrsd,
        t_e070a              TYPE lcl_main=&gt;tt_e070a,
        t_ot_exist           TYPE trkorrs,
        t_sequence_input     TYPE lcl_main=&gt;tt_sequence,
        t_last_version_input TYPE lcl_main=&gt;tt_vrsd,
      END OF   ts_sequence_data.

    TYPES :
      BEGIN OF ts_work_area,
        sys_previous    TYPE ztbdestrfc-zedtargsys,
        s_sequence_data TYPE lcl_main=&gt;ts_sequence_data,
        s_output_format TYPE lcl_main=&gt;ts_output_format,
        s_result_check  TYPE lcl_main=&gt;ts_result_check,
      END OF   ts_work_area.

***------------------------------------------------------------------***
**                           MÉTHODES                                 **
***------------------------------------------------------------------***

*	Déclaration de méthodes

    &quot; Constructeur
    METHODS constructor.

    &quot; Saisie - Contrôle
    METHODS criteria_check
      RETURNING VALUE(rv_subrc) TYPE sy-subrc.

    &quot; Données - Récupération
    METHODS data_get
      RETURNING VALUE(rv_subrc) TYPE sy-subrc.

    &quot; Séquence - Contrôle
    METHODS sequence_check
      RETURNING VALUE(rv_subrc) TYPE sy-subrc.

    &quot; Initialisation de la séquence
    METHODS sequence_order_set.

    &quot; Affichage message
    METHODS message_set.

    &quot; Résultat - Affichage
    METHODS result_display
      RETURNING VALUE(rv_subrc) TYPE sy-subrc.

    &quot; Résultat - Ajout
    METHODS result_add
      IMPORTING
        !iv_trkorr              TYPE e070-trkorr
        !iv_objname             TYPE vrsd-objname OPTIONAL
        !iv_objtype             TYPE vrsd-objtype OPTIONAL
        !iv_versno              TYPE vrsd-versno OPTIONAL
        !iv_sequence_order_prop TYPE numeric OPTIONAL
        VALUE(iv_msgty)         TYPE sy-msgty DEFAULT if_msg_output=&gt;msgtype_error
        !iv_msgid               TYPE sy-msgid DEFAULT &apos;ZBC&apos; &quot;#EC NOTEXT
        !iv_msgno               TYPE sy-msgno OPTIONAL
        !iv_msgv1               TYPE sy-msgv1 OPTIONAL
        !iv_msgv2               TYPE sy-msgv2 OPTIONAL
        !iv_msgv3               TYPE sy-msgv3 OPTIONAL
        !iv_msgv4               TYPE sy-msgv4 OPTIONAL.

    &quot; Récupération numéro OT
    METHODS _main_ot_get
      IMPORTING
                !iv_trkorr       TYPE e070-trkorr
      RETURNING VALUE(rv_trkorr) TYPE e070-trkorr.

***------------------------------------------------------------------***
**                            ATTRIBUTS                               **
***------------------------------------------------------------------***

*	Déclaration d&apos;attributs

    DATA : ms_work_area TYPE lcl_main=&gt;ts_work_area.
    DATA : ms_selection_criteria TYPE lcl_main=&gt;ts_selection_criteria.
    CLASS-DATA : mc_activate_proposal TYPE xsdboolean VALUE abap_false.
    CONSTANTS : mc_version_active TYPE vrsd-versno VALUE &apos;99999&apos;.

ENDCLASS.             &quot;lcl_main DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_main IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_main IMPLEMENTATION.

  METHOD at_selection_screen_ouput.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Modification écran de sélection
    &quot; -----------------------------------------------------------

    LOOP AT SCREEN INTO DATA(ls_screen).

      &quot; Suivant l&apos;élément
      CASE ls_screen-group1.

        WHEN &apos;PRO&apos;.                                         &quot;#EC NOTEXT
          &quot; Proposition
          IF lcl_main=&gt;mc_activate_proposal EQ abap_true.
            ls_screen-input  = 1.

          ELSE.
            ls_screen-input  = 0.
            CLEAR : me-&gt;ms_selection_criteria-options-ov_proposal_seq-&gt;*.

          ENDIF.

        WHEN OTHERS.
          &quot; Autres
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

      ENDCASE.

      &quot; Modification de l&apos;écran
      MODIFY screen FROM ls_screen.

    ENDLOOP.

  ENDMETHOD.

  METHOD factory.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Génération Instance
    &quot; -----------------------------------------------------------

    &quot; Génération instance
    ro_instance = NEW #( ).

  ENDMETHOD.

  METHOD constructor.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Initialisation attributs
    &quot; -----------------------------------------------------------

    &quot; Critère de sélection - Critères
    me-&gt;ms_selection_criteria-criteria-ov_request = REF #( p_req ).
    me-&gt;ms_selection_criteria-criteria-or_trkorr  = REF #( s_trkorr[] ).

    &quot; Critère de sélection - Options
    me-&gt;ms_selection_criteria-options-ov_reimport           = REF #( p_reimp ).
    me-&gt;ms_selection_criteria-options-ov_target_sys         = REF #( p_sysid ).
    me-&gt;ms_selection_criteria-options-ov_proposal_seq       = REF #( p_prop ).
    me-&gt;ms_selection_criteria-options-ov_ignore_recent      = REF #( p_irecen ).
    me-&gt;ms_selection_criteria-options-or_excluded_trkorr    = REF #( s_exc_ot[] ).
    me-&gt;ms_selection_criteria-options-ov_ignore_old_version = REF #( p_ioldv ).

    &quot; Chargement liste OT à exclure
    SELECT @if_trba_selection_c=&gt;gc_sign_incl AS sign,
           @if_trba_selection_c=&gt;gc_option_eq AS option,
           trkorr AS low
      FROM ztec_trkorr_exc
       APPENDING TABLE @me-&gt;ms_selection_criteria-options-or_excluded_trkorr-&gt;*.

  ENDMETHOD.

  METHOD sysid_value_help.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
    DATA :
      lt_fields   TYPE wlf_tt_help_value,
      lt_valuetab TYPE file_buffer_table.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Aide à la Recherche Système Cible
    &quot; -----------------------------------------------------------

    lt_fields = VALUE #(
      (
        tabname   = &apos;ZTBDESTRFC&apos;                            &quot;#EC NOTEXT
        fieldname = &apos;ZEDTARGSYS&apos;                            &quot;#EC NOTEXT
        selectflag = abap_true
      )
    ).

    &quot; Récupération Liste des Systèmes Cibles
    SELECT DISTINCT ( zedtargsys ) FROM ztbdestrfc
     WHERE loekz EQ @abap_false ORDER BY zedtargsys
      INTO TABLE @lt_valuetab.

    &quot; Affiche PopUp Sélection
    CALL FUNCTION &apos;HELP_VALUES_GET_WITH_TABLE&apos;
      EXPORTING
        display                       = abap_false
        fieldname                     = &apos;ZEDTARSYS&apos;  &quot;#EC NOTEXT
        tabname                       = &apos;ZTBDESTRFC&apos; &quot;#EC NOTEXT
        show_all_values_at_first_time = abap_true
      IMPORTING
        select_value                  = p_sysid
      TABLES
        fields                        = lt_fields
        valuetab                      = lt_valuetab
      EXCEPTIONS
        field_not_in_ddic             = 1
        more_then_one_selectfield     = 2
        no_selectfield                = 3
        OTHERS                        = 4.
    IF sy-subrc NE 0.
      &quot; Erreur sélection
      CLEAR : p_sysid.

    ENDIF.

  ENDMETHOD.

  METHOD criteria_check.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; Tri et suppression doublons
    SORT me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;* BY sign option low high.
    DELETE ADJACENT DUPLICATES FROM me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*.

    &quot; -----------------------------------------------------------
    &quot; Contrôle saisie
    &quot; -----------------------------------------------------------

    IF  me-&gt;ms_selection_criteria-criteria-ov_request-&gt;*  IS INITIAL
    AND me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*[] IS INITIAL.
      &quot; Aucun des deux saisies
      &quot;&quot;  --&gt; Arrêt du traitement
      rv_subrc = 1.
      MESSAGE s665(ez) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
      RETURN.

    ELSEIF NOT me-&gt;ms_selection_criteria-criteria-ov_request-&gt;*  IS INITIAL
       AND NOT me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*[] IS INITIAL.
      &quot; Les deux ...
      &quot;&quot;  --&gt; Arrêt du traitement
      rv_subrc = 2.
      MESSAGE s538(m3) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
      RETURN.

    ELSEIF NOT me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*[] IS INITIAL.
      &quot; Liste d&apos;OT
      IF p_sysid IS INITIAL.
        &quot; Système cible vide
        &quot;&quot;  --&gt; Arrêt du traitement
        rv_subrc = 3.
        MESSAGE s009(zhardcode) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
        RETURN.

      ENDIF.

      &quot;&quot;  --&gt; Contrôle cohérence saisie
      READ TABLE me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*
        WITH KEY option = if_trba_selection_c=&gt;gc_option_cp TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        &quot; Recherche sur Pattern non autorisée
        &quot;&quot;  --&gt; Arrêt du traitement
        rv_subrc = 4.
        MESSAGE s129(fb) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
        RETURN.

      ENDIF.

    ELSEIF NOT me-&gt;ms_selection_criteria-criteria-ov_request IS INITIAL.
      &quot; Demande de Transport
      &quot;&quot;  --&gt; Récupération système cible
      SELECT SINGLE zedtargsys FROM ztbrequest
              WHERE zedreqnb EQ @me-&gt;ms_selection_criteria-criteria-ov_request-&gt;*
               INTO @me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;*.
      IF sy-subrc NE 0.
        &quot; Aucun OT sélectionné
        &quot;&quot;  --&gt; Arrêt du traitement
        rv_subrc = 6.
        MESSAGE s172(l3) DISPLAY LIKE if_msg_output=&gt;msgtype_error.
        RETURN.

      ENDIF.

      &quot;&quot;  --&gt; Récupération liste des OTs et des Tâches de la Demande
      SELECT zedtrpord, zedreqpos
        FROM ztborderseq
       WHERE zedreqnb EQ @me-&gt;ms_selection_criteria-criteria-ov_request-&gt;*
       ORDER BY zedreqpos
        INTO TABLE @DATA(lt_ztborderseq).
      IF sy-subrc EQ 0.
        &quot; Au moins une correspondance
        &quot;&quot;  --&gt; Initialisation range des OTs dans l&apos;Ordre de la séquence
        LOOP AT lt_ztborderseq ASSIGNING FIELD-SYMBOL(&lt;lfs_s_orderseq&gt;).

          APPEND VALUE #(
            sign   = if_trba_selection_c=&gt;gc_sign_incl
            option = if_trba_selection_c=&gt;gc_option_eq
            low    = &lt;lfs_s_orderseq&gt;-zedtrpord
          ) TO me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*.

        ENDLOOP.

      ENDIF.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Récupération système cible précédent
    &quot; -----------------------------------------------------------

    &quot; Récupération du système cible précédent
    SELECT SINGLE zedsoursys FROM ztbdestrfc
            WHERE zedtargsys   EQ @me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;*
              AND loekz        EQ @space
             INTO @me-&gt;ms_work_area-sys_previous.
    IF sy-subrc NE 0.
      &quot; Aucun système précédent
      &quot;&quot;  --&gt; Système précédent = Système cible
      me-&gt;ms_work_area-sys_previous = me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;*.

    ENDIF.

    IF me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;* EQ zcl_transport_request_celio=&gt;mc_system-production.
      &quot; -----------------------------------------------------------
      &quot; Contrôle Transport en Recette des OTs
      &quot; -----------------------------------------------------------

      LOOP AT me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*
        ASSIGNING FIELD-SYMBOL(&lt;lfs_s_trkorr&gt;).

        IF zcl_transport_request=&gt;transport_request_check_import(
            iv_trkorr    = &lt;lfs_s_trkorr&gt;-low
            iv_tarsystem = me-&gt;ms_work_area-sys_previous
        ) NE abap_true.
          &quot; OT non transportée dans le précédent système cible
          &quot;&quot;  --&gt; Ajout erreur
          me-&gt;result_add(
            iv_trkorr = &lt;lfs_s_trkorr&gt;-low
            iv_msgno  = 024
            iv_msgv1  = CONV #( me-&gt;ms_work_area-sys_previous )
          ).

*          &quot;&quot;  --&gt; Code retour en erreur
*          rv_subrc = 8.

        ELSEIF  zcl_transport_request=&gt;transport_request_check_import(
            iv_trkorr    = &lt;lfs_s_trkorr&gt;-low
            iv_tarsystem = me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;*
        ) EQ abap_true.
          &quot; Cas Réimport
          &quot;&quot;  --&gt; Force contrôle Réimport
          me-&gt;ms_selection_criteria-options-ov_reimport-&gt;* = abap_true.

        ENDIF.

      ENDLOOP.

    ENDIF.

  ENDMETHOD.

  METHOD data_get.

***------------------------------------------------------------------***
**                             RANGES                                 **
***------------------------------------------------------------------***
    DATA :
          lr_trkorr TYPE ucon_tr_req_range.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_vrsd TYPE lcl_main=&gt;ts_vrsd.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Récupération des Tâches composant ces OTs
    &quot; -----------------------------------------------------------

    &quot; Récupération liste des Tâches de la Demande
    SELECT
      CASE WHEN main~strkorr EQ @space THEN main~trkorr ELSE main~strkorr END AS trkorr_main,
      CASE WHEN task~strkorr IS NULL THEN main~trkorr ELSE task~trkorr END AS trkorr_task,
      main~trfunction
      FROM e070 AS main
      LEFT OUTER JOIN e070 AS task ON main~strkorr EQ main~trkorr
     WHERE main~trkorr   IN @me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*
        OR main~strkorr  IN @me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*
      INTO TABLE @me-&gt;ms_work_area-s_sequence_data-t_sequence_input.
    IF sy-subrc NE 0.
      &quot; Aucun OT sélectionné
      &quot;&quot;  --&gt; Arrêt du traitement
      rv_subrc = 3.
      MESSAGE s000(zbc) WITH text-e02 space space space DISPLAY LIKE if_msg_output=&gt;msgtype_error.
      RETURN.

    ENDIF.

    &quot; Suppression des OTs de Custo
    DELETE me-&gt;ms_work_area-s_sequence_data-t_sequence_input
     WHERE trfunction EQ cl_smt_config_const=&gt;gc_request_type_customizing
        OR trfunction EQ cl_smt_config_const=&gt;gc_task_type_customizing.
    IF me-&gt;ms_work_area-s_sequence_data-t_sequence_input[] IS INITIAL.
      &quot; Plus de d&apos;OT
      rv_subrc = 4.
      MESSAGE s009(ztools) DISPLAY LIKE if_msg_output=&gt;msgtype_warning.
      RETURN.

    ENDIF.

    &quot; Initialisation numéro de séquence
    LOOP AT me-&gt;ms_work_area-s_sequence_data-t_sequence_input
      ASSIGNING FIELD-SYMBOL(&lt;lfs_s_sequence&gt;).

      &quot; Récupération Ordre de saisie
      READ TABLE me-&gt;ms_selection_criteria-criteria-or_trkorr-&gt;*
        WITH KEY low = &lt;lfs_s_sequence&gt;-trkorr_main TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        &quot; Correspondance
        &quot;&quot;  --&gt; Initialisation position de l&apos;Ordre
        &lt;lfs_s_sequence&gt;-sequence_order = sy-tabix.

      ENDIF.

      &quot; Extraction liste OT
      APPEND VALUE #(
        low    = &lt;lfs_s_sequence&gt;-trkorr_main
        sign   = if_trba_selection_c=&gt;gc_sign_incl
        option = if_trba_selection_c=&gt;gc_option_eq
      ) TO lr_trkorr.

    ENDLOOP.

    &quot; -----------------------------------------------------------
    &quot; Récupération des Objets contenus dans les OTs
    &quot; -----------------------------------------------------------

    &quot; Récupération objet contenu dans les OTs
    SELECT object AS objtype, obj_name AS objname, trkorr AS korrnum
      FROM e071 FOR ALL ENTRIES IN @me-&gt;ms_work_area-s_sequence_data-t_sequence_input
     WHERE trkorr EQ @me-&gt;ms_work_area-s_sequence_data-t_sequence_input-trkorr_task
           INTO CORRESPONDING FIELDS OF TABLE @me-&gt;ms_work_area-s_sequence_data-t_vrsd.

    IF sy-subrc EQ 0.
    &quot; -----------------------------------------------------------
    &quot; Récupération des Versions des Objets contenus dans les OTs
    &quot; -----------------------------------------------------------

      &quot; Récupération des Versions des Objets
      SELECT objtype, objname, versno, korrnum
        FROM vrsd
         FOR ALL ENTRIES IN @me-&gt;ms_work_area-s_sequence_data-t_vrsd
       WHERE objtype EQ @me-&gt;ms_work_area-s_sequence_data-t_vrsd-objtype
         AND objname EQ @me-&gt;ms_work_area-s_sequence_data-t_vrsd-objname
         AND korrnum NE @space
        INTO TABLE @me-&gt;ms_work_area-s_sequence_data-t_vrsd.

    ENDIF.

    IF sy-subrc EQ 0.
      &quot; -----------------------------------------------------------
      &quot; Récupération des OTs des Versions
      &quot; -----------------------------------------------------------

      SELECT trkorr    FROM e070
         FOR ALL ENTRIES IN @me-&gt;ms_work_area-s_sequence_data-t_vrsd
                      WHERE ( trkorr   EQ @me-&gt;ms_work_area-s_sequence_data-t_vrsd-korrnum
                         OR   strkorr  EQ @me-&gt;ms_work_area-s_sequence_data-t_vrsd-korrnum )
                 INTO TABLE @me-&gt;ms_work_area-s_sequence_data-t_ot_exist.
      SORT me-&gt;ms_work_area-s_sequence_data-t_ot_exist BY table_line.

      &quot; -----------------------------------------------------------
      &quot; Modification Numéro de Version active
      &quot; -----------------------------------------------------------

      &quot; Version Active = &apos;000000&apos; ==&gt; Modifie pour avoir la position la plus haute
      ls_vrsd-versno = lcl_main=&gt;mc_version_active.
      MODIFY me-&gt;ms_work_area-s_sequence_data-t_vrsd
        FROM ls_vrsd TRANSPORTING versno
       WHERE versno  IS INITIAL.

      &quot; -----------------------------------------------------------
      &quot; Récupération des plus hautes Versions des Objets
      &quot; -----------------------------------------------------------

      &quot; Conserve la plus haute Version des Objets
      me-&gt;ms_work_area-s_sequence_data-t_last_version_input[] = me-&gt;ms_work_area-s_sequence_data-t_vrsd[].
      SORT me-&gt;ms_work_area-s_sequence_data-t_last_version_input BY objtype objname versno DESCENDING.
      DELETE ADJACENT DUPLICATES FROM me-&gt;ms_work_area-s_sequence_data-t_last_version_input COMPARING objtype objname.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Récupération des dépendances
    &quot; -----------------------------------------------------------

    SELECT trkorr, attribute, reference
      FROM e070a WHERE trkorr IN @lr_trkorr[]
            INTO TABLE @me-&gt;ms_work_area-s_sequence_data-t_e070a.

  ENDMETHOD.

  METHOD sequence_check.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
    DATA :
        lt_vrsd_st TYPE lcl_main=&gt;tt_vrsd.
***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
      ls_cofile_header TYPE tstrfcofih.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_count             TYPE int4,
      lv_in_list           TYPE xsdboolean,
      lv_strkorr           TYPE e070-trkorr,
      lv_imported_sys      TYPE xsdboolean,
      lv_imported_prev_sys TYPE xsdboolean.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Pré-Traitement
    &quot; -----------------------------------------------------------

    &quot; Tri par Position
    SORT me-&gt;ms_work_area-s_sequence_data-t_sequence_input BY sequence_order.

    &quot; Tri par Objet / Version
    SORT me-&gt;ms_work_area-s_sequence_data-t_vrsd BY objtype objname versno DESCENDING.

    &quot; Conserve la Version la plus récente de l&apos;Objet
    lt_vrsd_st[] = me-&gt;ms_work_area-s_sequence_data-t_vrsd[].
    DELETE ADJACENT DUPLICATES FROM lt_vrsd_st COMPARING objtype objname.

    &quot; Supprime Version active
    DELETE me-&gt;ms_work_area-s_sequence_data-t_vrsd WHERE versno EQ lcl_main=&gt;mc_version_active.

    &quot; -----------------------------------------------------------
    &quot; Contrôle cohérence de Transport
    &quot; -----------------------------------------------------------

    &quot; Contrôle chaque Objet
    LOOP AT lt_vrsd_st ASSIGNING FIELD-SYMBOL(&lt;lfs_s_vrsd_st&gt;).

      CLEAR : lv_in_list.

      IF NOT me-&gt;ms_selection_criteria-options-or_excluded_trkorr-&gt;* IS INITIAL
         AND &lt;lfs_s_vrsd_st&gt;-korrnum IN me-&gt;ms_selection_criteria-options-or_excluded_trkorr-&gt;*.
        &quot; OT dans la liste à Exclure
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Récupération de la Version de l&apos;Objet le plus récent dans la liste
      READ TABLE me-&gt;ms_work_area-s_sequence_data-t_last_version_input
        WITH KEY object_key COMPONENTS objtype = &lt;lfs_s_vrsd_st&gt;-objtype
                                       objname = &lt;lfs_s_vrsd_st&gt;-objname
                             ASSIGNING FIELD-SYMBOL(&lt;lfs_s_last_version&gt;).

      &quot; Recherche si l&apos;OT est à transporter
      READ TABLE me-&gt;ms_work_area-s_sequence_data-t_sequence_input
        WITH KEY task_key COMPONENTS trkorr_task = &lt;lfs_s_vrsd_st&gt;-korrnum
                        TRANSPORTING NO FIELDS.
      lv_in_list = xsdbool( sy-subrc EQ 0 ).

      IF me-&gt;ms_selection_criteria-options-ov_ignore_recent-&gt;* EQ abap_false.
        &quot; Contrôle version plus récente
        IF lv_in_list EQ abap_false.
          &quot; OT non présent dans la liste
          &quot;&quot;  --&gt; Averti l&apos;utilisateur que celle-ci n&apos;est pas transportée
          me-&gt;result_add(
            iv_trkorr  = &lt;lfs_s_vrsd_st&gt;-korrnum
            iv_objname = &lt;lfs_s_vrsd_st&gt;-objname
            iv_objtype = &lt;lfs_s_vrsd_st&gt;-objtype
            iv_versno  = &lt;lfs_s_vrsd_st&gt;-versno
            iv_msgno   = 022
            iv_msgty   = if_msg_output=&gt;msgtype_warning
          ).

          &quot;&quot;  --&gt; Initialisation témoin présence OT plus récent
          me-&gt;ms_work_area-s_result_check-has_more_recent = abap_true.

        ENDIF.

      ENDIF.

      IF lv_in_list EQ abap_true.
        &quot; OT présent dans la liste
        &quot;&quot;  --&gt; Contrôle si l&apos;OT est dans le système cible
        IF zcl_transport_request=&gt;transport_request_check_import(
          iv_trkorr    = me-&gt;_main_ot_get( &lt;lfs_s_vrsd_st&gt;-korrnum )
          iv_tarsystem = me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;*
        ) EQ abap_false.
          IF me-&gt;ms_selection_criteria-options-ov_reimport-&gt;* EQ abap_false.
            &quot;&quot;  --&gt; Ajout dans la liste de résultat
            me-&gt;result_add(
              iv_trkorr  = &lt;lfs_s_vrsd_st&gt;-korrnum
              iv_objname = &lt;lfs_s_vrsd_st&gt;-objname
              iv_objtype = &lt;lfs_s_vrsd_st&gt;-objtype
              iv_versno  = &lt;lfs_s_vrsd_st&gt;-versno
            ).

          ENDIF.

        ENDIF.

      ENDIF.

      &quot; Récupération position première itération de l&apos;Objet
      READ TABLE me-&gt;ms_work_area-s_sequence_data-t_vrsd
        WITH KEY objtype = &lt;lfs_s_vrsd_st&gt;-objtype
                 objname = &lt;lfs_s_vrsd_st&gt;-objname
              TRANSPORTING NO FIELDS BINARY SEARCH.
      IF sy-subrc NE 0.
        &quot; Aucune version
        &quot;&quot;  --&gt; Passe à l&apos;itération suivante
        CONTINUE.

      ENDIF.

      &quot; Parcours chaque version de l&apos;Objet
      LOOP AT me-&gt;ms_work_area-s_sequence_data-t_vrsd
           ASSIGNING FIELD-SYMBOL(&lt;lfs_s_vrsd&gt;) FROM sy-tabix.

        CLEAR : lv_imported_prev_sys, lv_imported_sys.

        IF &lt;lfs_s_vrsd&gt;-objtype NE &lt;lfs_s_vrsd_st&gt;-objtype
        OR &lt;lfs_s_vrsd&gt;-objname NE &lt;lfs_s_vrsd_st&gt;-objname.
          &quot; On ne traite plus le même objet
          &quot;&quot;  --&gt; Arrêt du traitement
          EXIT.

        ENDIF.

        &quot;&quot; --&gt; Récupération OT
        lv_strkorr = me-&gt;_main_ot_get( &lt;lfs_s_vrsd&gt;-korrnum ).

        IF NOT me-&gt;ms_selection_criteria-options-or_excluded_trkorr-&gt;*[] IS INITIAL
           AND lv_strkorr IN me-&gt;ms_selection_criteria-options-or_excluded_trkorr-&gt;*.
          &quot; OT dans la liste à Exclure
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot; Vérifie que l&apos;OT existe encore
        READ TABLE me-&gt;ms_work_area-s_sequence_data-t_ot_exist
          WITH KEY table_line = &lt;lfs_s_vrsd&gt;-korrnum
            BINARY SEARCH TRANSPORTING NO FIELDS.
        IF sy-subrc NE 0.
          &quot; OT n&apos;existe plus
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot;&quot;  --&gt; OT transporté dans le Système Cible ?
        lv_imported_sys = zcl_transport_request=&gt;transport_request_check_import(
          EXPORTING
            iv_trkorr        = lv_strkorr
            iv_tarsystem     = me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;*
          IMPORTING
            es_cofile_header = ls_cofile_header
        ).
        IF ls_cofile_header IS INITIAL.
          &quot; OT n&apos;existe plus
          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ENDIF.

        &quot;&quot;  --&gt; OT transporté dans le Système Précédent ?
        lv_imported_prev_sys = zcl_transport_request=&gt;transport_request_check_import(
            iv_trkorr    = lv_strkorr
            iv_tarsystem = me-&gt;ms_work_area-sys_previous
        ).

        &quot;&quot;  --&gt; Contrôle que l&apos;OT soit dans la liste de ceux à transporter
        READ TABLE me-&gt;ms_work_area-s_sequence_data-t_sequence_input
          WITH KEY task_key COMPONENTS trkorr_task = &lt;lfs_s_vrsd&gt;-korrnum
                             ASSIGNING FIELD-SYMBOL(&lt;lfs_s_sequence&gt;).
        IF sy-subrc NE 0.
          &quot; Cette version n&apos;est pas dans la liste des OTs
          &quot;&quot;  --&gt; Contrôle si l&apos;OT est dans le système cible
          IF lv_imported_sys EQ abap_true.
            &quot; OT transporté // Cela signifie que les autres versions sont déjà transportées
            IF me-&gt;ms_selection_criteria-options-ov_reimport-&gt;* EQ abap_true
            AND &lt;lfs_s_last_version&gt;-versno LT &lt;lfs_s_vrsd&gt;-versno.
              &quot; Réimport &amp; Versions plus récéntes dans le Système cible
              &quot;&quot;  --&gt; Ajout pour séquence manquante (erreur)
              me-&gt;result_add(
                iv_trkorr  = lv_strkorr
                iv_objname = &lt;lfs_s_vrsd&gt;-objname
                iv_objtype = &lt;lfs_s_vrsd&gt;-objtype
                iv_versno  = &lt;lfs_s_vrsd&gt;-versno
                iv_msgno   = 028
                iv_msgty   = if_msg_output=&gt;msgtype_error
                iv_msgv1   = CONV #( &lt;lfs_s_vrsd&gt;-korrnum )
              ).

            ELSEIF me-&gt;ms_selection_criteria-options-ov_reimport-&gt;*        EQ abap_false
            AND me-&gt;ms_selection_criteria-options-ov_ignore_old_version-&gt;* EQ abap_true.
              &quot;&quot;  --&gt; Suppression des entrées portant sur cet Objet
              DELETE me-&gt;ms_work_area-s_sequence_data-t_vrsd
               WHERE objname = &lt;lfs_s_vrsd&gt;-objname
                 AND objtype = &lt;lfs_s_vrsd&gt;-objtype.

            ENDIF.

          ELSE.
            &quot; OT non transporté
            IF lv_imported_prev_sys EQ abap_false.
              &quot; OT non importé dans le système précédent
              READ TABLE me-&gt;ms_work_area-s_result_check-t_result
                WITH KEY objtype = &lt;lfs_s_vrsd&gt;-objtype
                         objname = &lt;lfs_s_vrsd&gt;-objname
               ASSIGNING FIELD-SYMBOL(&lt;lfs_s_result_temp&gt;).
              IF sy-subrc NE 0
              OR ( &lt;lfs_s_result_temp&gt;-versno GT &lt;lfs_s_vrsd&gt;-versno
              AND  me-&gt;ms_selection_criteria-options-ov_ignore_old_version-&gt;* EQ abap_false ).
                &quot;&quot;  --&gt; Ajout pour séquence manquante (erreur)
                me-&gt;result_add(
                  iv_trkorr  = lv_strkorr
                  iv_objname = &lt;lfs_s_vrsd&gt;-objname
                  iv_objtype = &lt;lfs_s_vrsd&gt;-objtype
                  iv_versno  = &lt;lfs_s_vrsd&gt;-versno
                  iv_msgno   = 024
                  iv_msgty   = if_msg_output=&gt;msgtype_error
                  iv_msgv1   = CONV #( me-&gt;ms_work_area-sys_previous )
                ).

              ENDIF.

            ELSEIF &lt;lfs_s_last_version&gt;-versno EQ lcl_main=&gt;mc_version_active.
              &quot; Dernière Version à transporter et celle en cours n&apos;est pas à Transporter
              &quot;&quot;  --&gt; Ajout pour séquence manquante (erreur)
              me-&gt;result_add(
                iv_trkorr  = lv_strkorr
                iv_objname = &lt;lfs_s_vrsd&gt;-objname
                iv_objtype = &lt;lfs_s_vrsd&gt;-objtype
                iv_versno  = &lt;lfs_s_vrsd&gt;-versno
                iv_msgno   = 023
                iv_msgty   = if_msg_output=&gt;msgtype_error
                iv_msgv1   = CONV #( &lt;lfs_s_vrsd&gt;-korrnum )
              ).

            ELSEIF &lt;lfs_s_last_version&gt;-versno LT &lt;lfs_s_vrsd&gt;-versno
            AND me-&gt;ms_selection_criteria-options-ov_ignore_recent-&gt;* EQ abap_false.
              &quot; Tenir compte des Versions plus récente
              IF line_exists(
                me-&gt;ms_work_area-s_result_check-t_result[
                  objtype = &lt;lfs_s_vrsd&gt;-objtype
                  objname = &lt;lfs_s_vrsd&gt;-objname
                  type    = if_msg_output=&gt;msgtype_error
                ]
              ).
                &quot; Version plus récente transporté mais celle-là manque
                &quot;&quot;  --&gt; Ajout pour séquence manquante (erreur)
                me-&gt;result_add(
                  iv_trkorr  = lv_strkorr
                  iv_objname = &lt;lfs_s_vrsd&gt;-objname
                  iv_objtype = &lt;lfs_s_vrsd&gt;-objtype
                  iv_versno  = &lt;lfs_s_vrsd&gt;-versno
                  iv_msgno   = 024
                  iv_msgty   = if_msg_output=&gt;msgtype_error
                  iv_msgv1   = CONV #( me-&gt;ms_work_area-sys_previous )
                ).

              ELSE.
                &quot; Pas d&apos;OT plus récent non importé
                &quot;&quot;  --&gt; Ajout pour séquence manquante (avertissement)
                me-&gt;result_add(
                  iv_trkorr  = lv_strkorr
                  iv_objname = &lt;lfs_s_vrsd&gt;-objname
                  iv_objtype = &lt;lfs_s_vrsd&gt;-objtype
                  iv_versno  = &lt;lfs_s_vrsd&gt;-versno
                  iv_msgno   = 022
                  iv_msgty   = if_msg_output=&gt;msgtype_warning
                  iv_msgv1   = CONV #( &lt;lfs_s_vrsd&gt;-korrnum )
                ).

              ENDIF.

              &quot;&quot;  --&gt; Témoin version plus récente
              me-&gt;ms_work_area-s_result_check-has_more_recent = abap_true.

            ELSEIF &lt;lfs_s_last_version&gt;-versno GT &lt;lfs_s_vrsd&gt;-versno.
              &quot; Version moins récente
              &quot;&quot;  --&gt; Ajout pour séquence manquante (erreur)
              me-&gt;result_add(
                iv_trkorr  = lv_strkorr
                iv_objname = &lt;lfs_s_vrsd&gt;-objname
                iv_objtype = &lt;lfs_s_vrsd&gt;-objtype
                iv_versno  = &lt;lfs_s_vrsd&gt;-versno
                iv_msgno   = 023
                iv_msgty   = if_msg_output=&gt;msgtype_error
                iv_msgv1   = CONV #( &lt;lfs_s_vrsd&gt;-korrnum )
              ).

            ENDIF.

          ENDIF.

          &quot;&quot;  --&gt; Passe à l&apos;itération suivante
          CONTINUE.

        ELSE.
          &quot; OT présent dans la liste
          IF  lv_imported_sys EQ abap_true
          AND me-&gt;ms_selection_criteria-options-ov_reimport-&gt;* EQ abap_false.
            &quot; OT déjà importé et option réimport non sélectionné
            &quot;&quot;  --&gt; Passe à l&apos;itération suivante
            CONTINUE.

          ENDIF.

          &quot;&quot;  --&gt; Ajout pour séquence
          me-&gt;result_add(
            iv_trkorr  = &lt;lfs_s_vrsd&gt;-korrnum
            iv_objname = &lt;lfs_s_vrsd&gt;-objname
            iv_objtype = &lt;lfs_s_vrsd&gt;-objtype
            iv_versno  = &lt;lfs_s_vrsd&gt;-versno
          ).

        ENDIF.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.

  METHOD sequence_order_set.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_order        TYPE sy-tabix VALUE 1,
      lv_not_imported TYPE xsdboolean.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Réorganisation du résultat final
    &quot; -----------------------------------------------------------

    IF me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;* EQ zcl_transport_request_celio=&gt;mc_system-production.
      &quot; Destination Production !
      &quot;&quot;  --&gt; Tri par Date d&apos;Import dans l&apos;environnement précédent
      SORT me-&gt;ms_work_area-s_result_check-t_result BY import_date import_time trkorr.

      &quot;&quot;  --&gt; Initialisation passage par Date Import
      LOOP AT me-&gt;ms_work_area-s_result_check-t_result
        ASSIGNING FIELD-SYMBOL(&lt;lfs_s_result&gt;).

        AT NEW trkorr.
          &quot; A chaque changement d&apos;OT
          IF &lt;lfs_s_result&gt;-not_in_previous_system IS INITIAL.
            &quot; OT non importé dans système précedent
            &quot;&quot;  --&gt; ToDo : Détermination de la séquence proposée
            &lt;lfs_s_result&gt;-sequence_order_prop = -1.

          ELSE.
            &quot; OT importé
            &quot;&quot;  --&gt; Initialisation séquence proposée
            &lt;lfs_s_result&gt;-sequence_order_prop = lv_order.

          ENDIF.

          &quot;&quot;  --&gt; Modification dans toute la table
          MODIFY me-&gt;ms_work_area-s_result_check-t_result
            FROM &lt;lfs_s_result&gt; TRANSPORTING sequence_order_prop
           WHERE trkorr EQ &lt;lfs_s_result&gt;-trkorr.

          &quot;&quot;  --&gt; Incrémentation séquence
          ADD 1 TO lv_order.

        ENDAT.

      ENDLOOP.

      &quot; Tri par Ordre de passage
      SORT me-&gt;ms_work_area-s_result_check-t_result BY sequence_order_prop.

    ENDIF.

  ENDMETHOD.

  METHOD message_set.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Message
    &quot; -----------------------------------------------------------

    &quot; Contrôle cohérence OK ?
    IF line_exists( me-&gt;ms_work_area-s_result_check-t_result[
        type = if_msg_output=&gt;msgtype_error ]
       ).
      &quot; Une erreur dans le contrôle
      &quot;&quot;  --&gt; Message erreur
      me-&gt;ms_work_area-s_result_check-error = abap_true.

      &quot;&quot;  --&gt; Tri pour faire apparaître les Erreurs en premier
      SORT me-&gt;ms_work_area-s_result_check-t_result BY type.

      IF me-&gt;ms_selection_criteria-options-ov_reimport-&gt;* EQ abap_true.
        &quot; Réimport
        &quot;&quot;  --&gt; Message d&apos;erreur spécifique
        MESSAGE s029(zbc) DISPLAY LIKE if_msg_output=&gt;msgtype_error.

      ELSE.
        &quot; Classique
        MESSAGE s025(zbc) DISPLAY LIKE if_msg_output=&gt;msgtype_error.

      ENDIF.

    ELSE.
      &quot; Aucune erreur dans le contrôle
      &quot;&quot;  --&gt; Recherche présence de message de succès
      IF line_exists( me-&gt;ms_work_area-s_result_check-t_result[
          type = if_msg_output=&gt;msgtype_success ]
         ).
        &quot;&quot;  --&gt; Message succès
        MESSAGE s026(zbc).

      ELSE.
        &quot;&quot;  --&gt; Message avertissement rien à faire
        MESSAGE s027(zbc) DISPLAY LIKE if_msg_output=&gt;msgtype_warning.

      ENDIF.

      IF me-&gt;ms_work_area-s_result_check-has_more_recent EQ abap_false.
        &quot;&quot;  --&gt; Suppression des doublons
        SORT me-&gt;ms_work_area-s_result_check-t_result BY trkorr.
        DELETE ADJACENT DUPLICATES FROM me-&gt;ms_work_area-s_result_check-t_result COMPARING trkorr.

        &quot;&quot;  --&gt; Réinitialisation autres champs
        me-&gt;ms_work_area-s_result_check-t_result[] = CORRESPONDING #(
          me-&gt;ms_work_area-s_result_check-t_result
            MAPPING type                 = type
                    icon                 = icon
                    trkorr               = trkorr
                    import_date          = import_date
                    import_time          = import_time
                    sequence_order_prop  = sequence_order_prop
                    sequence_order_input = sequence_order_input
             EXCEPT *
        ).

      ENDIF.

    ENDIF.

  ENDMETHOD.

  METHOD _main_ot_get.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    CLEAR : rv_trkorr.

    &quot; -----------------------------------------------------------
    &quot; Récupération de l&apos;OT
    &quot; -----------------------------------------------------------

    &quot; Récupération du parent de la Tâche
    SELECT SINGLE strkorr FROM e070
            WHERE trkorr  EQ @iv_trkorr
             INTO @rv_trkorr.
    IF rv_trkorr IS INITIAL.
      &quot; OT = Tâche
      &quot;&quot;  --&gt; Initialise OT
      rv_trkorr = iv_trkorr.

    ENDIF.

  ENDMETHOD.

  METHOD result_add.

***------------------------------------------------------------------***
**                            STRUCTURE                               **
***------------------------------------------------------------------***
    DATA :
          ls_result TYPE lcl_main=&gt;ts_result.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
    DATA :
      lv_strlen TYPE int4.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Ajout dans la table de Retour
    &quot; -----------------------------------------------------------

    &quot; Initialisation données
    ls_result-type                = SWITCH #( iv_msgno
      WHEN space THEN if_msg_output=&gt;msgtype_success
      ELSE iv_msgty
    ).
    ls_result-versno              = iv_versno.
    ls_result-trkorr              = iv_trkorr.
    ls_result-objname             = iv_objname.
    ls_result-objtype             = iv_objtype.
    ls_result-sequence_order_prop = iv_sequence_order_prop.

    &quot; Initialisation position de l&apos;OT dans la séquence
    READ TABLE me-&gt;ms_work_area-s_sequence_data-t_sequence_input
      WITH KEY task_key COMPONENTS trkorr_task = iv_trkorr
      ASSIGNING FIELD-SYMBOL(&lt;lfs_s_sequence_input&gt;).
    IF sy-subrc NE 0.
      READ TABLE me-&gt;ms_work_area-s_sequence_data-t_sequence_input
        WITH KEY ot_key COMPONENTS trkorr_main = iv_trkorr
        ASSIGNING &lt;lfs_s_sequence_input&gt;.

    ENDIF.
    IF sy-subrc EQ 0.
      ls_result-sequence_order_input = &lt;lfs_s_sequence_input&gt;-sequence_order.

    ENDIF.

    IF NOT iv_msgid IS INITIAL AND NOT iv_msgno IS INITIAL.
      &quot; ID Message &amp; Numéro de Message
      &quot;&quot;  --&gt; Construction du message
      IF iv_msgty IS INITIAL. iv_msgty = if_msg_output=&gt;msgtype_error. ENDIF.
      MESSAGE ID iv_msgid TYPE iv_msgty NUMBER iv_msgno
            WITH iv_msgv1 iv_msgv2 iv_msgv3 iv_msgv4
            INTO ls_result-message.

    ENDIF.

    &quot; Récupération données CoFile
    DATA(lt_cofile) = zcl_transport_request=&gt;transport_request_cofile_get( iv_trkorr ).

    &quot; Récupération dernière Date de Transport
    SORT lt_cofile BY tarsystem function trdate DESCENDING trtime DESCENDING.
    READ TABLE lt_cofile WITH KEY tarsystem = me-&gt;ms_work_area-sys_previous
                                  function  = cl_cts_change_tracking_api=&gt;co_import_status_imported
                        ASSIGNING FIELD-SYMBOL(&lt;lfs_s_cofile&gt;) BINARY SEARCH.
    IF sy-subrc EQ 0.
      &quot; L&apos;OT a été transportée dans l&apos;environnement précédent
      &quot;&quot;  --&gt; Initialisation date de transport
      ls_result-import_date = &lt;lfs_s_cofile&gt;-trdate.
      ls_result-import_time = &lt;lfs_s_cofile&gt;-trtime.

    ELSE.
      &quot; OT non transportée dans l&apos;environnement précédent
      &quot;&quot;  --&gt; Cas traité en anomalie ou système &lt;&gt; PE1
      ls_result-use_sequence_order     = abap_true.
      ls_result-not_in_previous_system = abap_true.

      &quot;&quot;  --&gt; Récupération de la Version plus récente
      LOOP AT me-&gt;ms_work_area-s_result_check-t_result
        ASSIGNING FIELD-SYMBOL(&lt;lfs_s_result&gt;)
        WHERE objtype EQ ls_result-objtype
          AND objname EQ ls_result-objname
          AND versno  GT ls_result-versno.

        &quot; Initialisation Date de Transport de la Version plus récente
        ls_result-import_date = &lt;lfs_s_result&gt;-import_date.
        ls_result-import_time = &lt;lfs_s_result&gt;-import_time.

        &quot; Arrêt de la boucle
        EXIT.

      ENDLOOP.

    ENDIF.

    &quot; Icône
    ls_result-icon = SWITCH #( ls_result-type
      WHEN if_msg_output=&gt;msgtype_error   THEN text-e00
      WHEN if_msg_output=&gt;msgtype_success THEN text-s00
      WHEN if_msg_output=&gt;msgtype_warning THEN text-i00
    ).

    &quot; Ajout de l&apos;entrée
    APPEND ls_result TO me-&gt;ms_work_area-s_result_check-t_result.

    &quot; -----------------------------------------------------------
    &quot; Condition d&apos;affichage
    &quot; -----------------------------------------------------------

    &quot; Taille affichage - Message
    lv_strlen = strlen( ls_result-message ).
    IF lv_strlen GT me-&gt;ms_work_area-s_output_format-length-message.
      &quot; Taille message plus grande
      &quot;&quot;  --&gt; Utilisation de cette taille
      me-&gt;ms_work_area-s_output_format-length-message = lv_strlen + 2.

    ENDIF.

    &quot; Taille affichage - Objet
    lv_strlen = strlen( ls_result-objname ).
    IF lv_strlen GT me-&gt;ms_work_area-s_output_format-length-objname.
      &quot; Taille objet plus grande
      &quot;&quot;  --&gt; Utilisation de cette taille
      me-&gt;ms_work_area-s_output_format-length-objname = lv_strlen + 2.

    ENDIF.

  ENDMETHOD.

  METHOD result_display.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
    DATA :
      lo_column     TYPE REF TO cl_salv_column,
      lo_columns    TYPE REF TO cl_salv_columns,
      lo_salv_table TYPE REF TO cl_salv_table.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle
    &quot; -----------------------------------------------------------

    IF me-&gt;ms_work_area-s_result_check-t_result[] IS INITIAL.
      &quot; Aucun OT
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    TRY.
        &quot; -----------------------------------------------------------
        &quot; Génération Instance ALV
        &quot; -----------------------------------------------------------

        &quot; Génération instance
        cl_salv_table=&gt;factory(
          EXPORTING
            list_display   = sy-batch
          IMPORTING
            r_salv_table   = lo_salv_table
          CHANGING
            t_table        = me-&gt;ms_work_area-s_result_check-t_result
        ).

        &quot; -----------------------------------------------------------
        &quot; Customization
        &quot; -----------------------------------------------------------

        lo_salv_table-&gt;get_functions( )-&gt;set_all( abap_true ).

        TRY.
            &quot; -----------------------------------------------------------
            &quot; Modification Affichage
            &quot; -----------------------------------------------------------

            &quot; Récupération instance des Colonnes
            lo_columns = lo_salv_table-&gt;get_columns( ).

            TRY.
                &quot; Récupération de la Colonne &quot;TYPE&quot; - Type de message
                lo_column = lo_columns-&gt;get_column( &apos;TYPE&apos; ). &quot;#EC NOTEXT

                &quot; Affiche la colonne en cas d&apos;erreur
                lo_column-&gt;set_visible( abap_false ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.


            TRY.
                &quot; Récupération de la Colonne &quot;ICON&quot; - Icône
                lo_column = lo_columns-&gt;get_column( &apos;ICON&apos; ). &quot;#EC NOTEXT
*                lo_column-&gt;set_

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;TRKORR&quot; - Numéro OT
                lo_column = lo_columns-&gt;get_column( &apos;TRKORR&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_output_length( 10 ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;OBJTYPE&quot; - Type d&apos;Objet
                lo_column = lo_columns-&gt;get_column( &apos;OBJTYPE&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_output_length( 6 ).

                &quot; Affiche la colonne en cas d&apos;erreur
                lo_column-&gt;set_visible( boolc(
                    me-&gt;ms_work_area-s_result_check-error           EQ abap_true OR
                    me-&gt;ms_work_area-s_result_check-has_more_recent EQ abap_true
                  )
                ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;OBJNAME&quot; - Nom d&apos;Objet
                lo_column = lo_columns-&gt;get_column( &apos;OBJNAME&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_output_length( me-&gt;ms_work_area-s_output_format-length-objname ).

                &quot; Affiche la colonne en cas d&apos;erreur
                lo_column-&gt;set_visible( boolc(
                    me-&gt;ms_work_area-s_result_check-error           EQ abap_true OR
                    me-&gt;ms_work_area-s_result_check-has_more_recent EQ abap_true
                  )
                ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;VERSNO&quot; - Numéro de Version
                lo_column = lo_columns-&gt;get_column( &apos;VERSNO&apos; ). &quot;#EC NOTEXT

                &quot; Affiche la colonne en cas d&apos;erreur
                lo_column-&gt;set_visible( boolc(
                    me-&gt;ms_work_area-s_result_check-error           EQ abap_true OR
                    me-&gt;ms_work_area-s_result_check-has_more_recent EQ abap_true
                  )
                ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;MESSAGE&quot; - Message
                lo_column = lo_columns-&gt;get_column( &apos;MESSAGE&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_visible( boolc(
                    me-&gt;ms_work_area-s_result_check-error           EQ abap_true OR
                    me-&gt;ms_work_area-s_result_check-has_more_recent EQ abap_true
                  )
                ).
                lo_column-&gt;set_output_length( me-&gt;ms_work_area-s_output_format-length-message ).
                lo_column-&gt;set_long_text( CONV #( text-mes ) ).
                lo_column-&gt;set_short_text( CONV #( text-mes ) ).
                lo_column-&gt;set_medium_text( CONV #( text-mes ) ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;IMPORT_DATE&quot; - Date d&apos;Import
                lo_column = lo_columns-&gt;get_column( &apos;IMPORT_DATE&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_visible( lcl_main=&gt;mc_activate_proposal ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;IMPORT_TIME&quot; - Heure d&apos;Import
                lo_column = lo_columns-&gt;get_column( &apos;IMPORT_TIME&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_visible( lcl_main=&gt;mc_activate_proposal ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;SEQUENCE_ORDER_INPUT&quot; - Séquence saisie
                lo_column = lo_columns-&gt;get_column( &apos;SEQUENCE_ORDER_INPUT&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_visible( lcl_main=&gt;mc_activate_proposal ).
                lo_column-&gt;set_output_length( &apos;13&apos; ).
                lo_column-&gt;set_long_text( CONV #( text-soi ) ).
                lo_column-&gt;set_short_text( CONV #( text-soi ) ).
                lo_column-&gt;set_medium_text( CONV #( text-soi ) ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;SEQUENCE_ORDER_PROP&quot; - Séquence proposée
                lo_column = lo_columns-&gt;get_column( &apos;SEQUENCE_ORDER_PROP&apos; ). &quot;#EC NOTEXT.
                lo_column-&gt;set_visible( boolc(
                  lcl_main=&gt;mc_activate_proposal EQ abap_true
                  OR me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;* EQ zcl_transport_request_celio=&gt;mc_system-production ) &quot;#EC NOTEXT
                ).
                lo_column-&gt;set_output_length( &apos;16&apos; ).
                lo_column-&gt;set_long_text( CONV #( text-sop ) ).
                lo_column-&gt;set_short_text( CONV #( text-sop ) ).
                lo_column-&gt;set_medium_text( CONV #( text-sop ) ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;USE_SEQUENCE_ORDER&quot; - Utilise Ordre de la séquence
                lo_column = lo_columns-&gt;get_column( &apos;USE_SEQUENCE_ORDER&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_visible( abap_false ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

            TRY.
                &quot; Récupération de la Colonne &quot;NOT_IN_PREVIOUS_SYSTEM&quot; - Pas dans le précédent système
                lo_column = lo_columns-&gt;get_column( &apos;NOT_IN_PREVIOUS_SYSTEM&apos; ). &quot;#EC NOTEXT
                lo_column-&gt;set_visible( abap_false ).

              CATCH : cx_salv_not_found, cx_salv_data_error.
                &quot; Une erreur est survenue
                &quot;&quot;  --&gt; Tant pis ...

            ENDTRY.

          CATCH cx_root.
            &quot; Une erreur est survenue

        ENDTRY.

        &quot; -----------------------------------------------------------
        &quot; Affichage
        &quot; -----------------------------------------------------------

        &quot; Affichage de l&apos;ALV
        lo_salv_table-&gt;display( ).

      CATCH cx_salv_msg.

    ENDTRY.

  ENDMETHOD.

  METHOD start_of_selection.

***==================================================================***
**                           TRAITEMENT                               **
***==================================================================***

    &quot; -----------------------------------------------------------
    &quot; Contrôle saisie
    &quot; -----------------------------------------------------------

    &quot; Contrôle saisie
    IF me-&gt;criteria_check( ) NE 0
    OR me-&gt;ms_selection_criteria-options-ov_target_sys-&gt;*
      NE zcl_transport_request_celio=&gt;mc_system-production.
      &quot; Erreur de saisie
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Récupération des données
    &quot; -----------------------------------------------------------

    &quot; Récupération des données
    IF me-&gt;data_get( ) NE 0.
      &quot; Erreur
      &quot;&quot;  --&gt; Arrêt du traitement
      RETURN.

    ENDIF.

    &quot; -----------------------------------------------------------
    &quot; Contrôle séquence
    &quot; -----------------------------------------------------------

    &quot; Contrôle séquence
    me-&gt;sequence_check( ).

    &quot; -----------------------------------------------------------
    &quot; Réorganisation du résultat final
    &quot; -----------------------------------------------------------

    &quot; Initialisation de l&apos;Ordre
    me-&gt;sequence_order_set( ).

    &quot; -----------------------------------------------------------
    &quot; Affiche message traitement
    &quot; -----------------------------------------------------------

    &quot; Affichage message
    me-&gt;message_set( ).

    &quot; -----------------------------------------------------------
    &quot; Affichage résultat
    &quot; -----------------------------------------------------------

    &quot; Affichage résultat
    me-&gt;result_display( ).

  ENDMETHOD.

ENDCLASS.

DATA : go_main TYPE REF TO lcl_main.

***==================================================================***
**                           INITIALIZATION                           **
***==================================================================***
INITIALIZATION.
  &quot; Génération instance
  go_main = lcl_main=&gt;factory( ).

***==================================================================***
**                     AT SELECTION-SCREEN OUTPUT                     **
***==================================================================***
AT SELECTION-SCREEN OUTPUT.
  &quot; Modification écran de sélection
  go_main-&gt;at_selection_screen_ouput( ).

***==================================================================***
**                AT SELECTION-SCREEN ON VALUE REQUEST                **
***==================================================================***
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_sysid.
  &quot; Système Cible - Aide à la recherche
  go_main-&gt;sysid_value_help( ).

***==================================================================***
**                         START-OF-SELECTION                         **
***==================================================================***
START-OF-SELECTION.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; Traitement principal
  go_main-&gt;start_of_selection( ).

END-OF-SELECTION.</source>
 </PROG>
 <PROG NAME="Z_A_BC_TRANSPORT_WF_RESEND" VARCL="X" SUBC="1" APPL="*" RSTAT="K" RMAND="200" RLOAD="F" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="TB1" ENTRY="Crtière de sélection" LENGTH="40 "/>
    <textElement ID="R" ENTRY="Transport - Workflow - Relance" LENGTH="30 "/>
    <textElement ID="S" KEY="P_FT2" ENTRY="        Express ?" LENGTH="17 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_A_BC_TRANSPORT_WF_RESEND
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*
REPORT z_a_bc_transport_wf_resend.

&quot; -----------------------------------------------------------
&quot; Critère de sélection
&quot; -----------------------------------------------------------

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-tb1.

&quot; Express
PARAMETERS : p_ft2 AS CHECKBOX.

SELECTION-SCREEN END OF BLOCK b1.

START-OF-SELECTION.
***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
    lt_request  TYPE STANDARD TABLE OF ztbrequest
      WITH NON-UNIQUE KEY primary_key COMPONENTS zedreqnb,
    lt_orderseq TYPE STANDARD TABLE OF ztborderseq
      WITH NON-UNIQUE KEY primary_key COMPONENTS zedreqnb zedreqpos.

***------------------------------------------------------------------***
**                             RANGES                                 **
***------------------------------------------------------------------***
  DATA :
    lr_user    TYPE ddtrange,
    lr_date    TYPE ddtrange,
    lr_target  TYPE ddtrange,
    lr_valuser TYPE ddtrange.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_since TYPE zedvaldate.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Pré-Traitement
  &quot; -----------------------------------------------------------

  &quot; Cible
  lr_target = VALUE #(
    (
      low    = zcl_transport_request_celio=&gt;mc_system-production
      sign   = if_trba_selection_c=&gt;gc_sign_incl
      option = if_trba_selection_c=&gt;gc_option_eq
    )
  ).

  &quot; -----------------------------------------------------------
  &quot; Récupération des Demandes en Attente de Validation
  &quot; -----------------------------------------------------------

  &quot; Récupération des Demandes non validées
  CALL FUNCTION &apos;Z_BC_TRANSPORT_GET_TABLE&apos;
    EXPORTING
      iv_code             = abap_true
      iv_lock             = abap_true
      iv_trtdate_empty    = space
      iv_since            = lv_since
    TABLES
      rs_user             = lr_user
      rs_date             = lr_date
      rs_target           = lr_target
      rs_valusr           = lr_valuser
      rs_valid_target     = lr_target
      et_read_ztbrequest  = lt_request
      et_read_ztborderseq = lt_orderseq.
  IF lt_request[] IS INITIAL.
    &quot; Pas de Demande en cours de Validation
    &quot;&quot;  --&gt; Arrêt du traitement
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Relance Notification
  &quot; -----------------------------------------------------------

  IF p_ft2 EQ abap_true.
    &quot; Uniquement Demande Express
    &quot;&quot;  --&gt; Supprime les Demandes non Express
    DELETE lt_request WHERE zedeligible EQ abap_false.

  ENDIF.

  LOOP AT lt_request ASSIGNING FIELD-SYMBOL(&lt;lfs_s_request&gt;).

    &quot; Relance Notification
    zcl_transport_request_workflow=&gt;workflow_validation_resend( &lt;lfs_s_request&gt;-zedreqnb  ).

  ENDLOOP.</source>
 </PROG>
 <PROG NAME="Z_A_OBJECT_CHECK_VERSION" VARCL="X" SUBC="1" APPL="*" RSTAT="K" RMAND="200" RLOAD="F" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="F">
    <textElement ID="I" KEY="E00" ENTRY="@0A@" LENGTH="14 "/>
    <textElement ID="I" KEY="E02" ENTRY="Objet(s) non présent dans OT" LENGTH="56 "/>
    <textElement ID="I" KEY="I00" ENTRY="@09@" LENGTH="14 "/>
    <textElement ID="I" KEY="S00" ENTRY="@08@" LENGTH="14 "/>
    <textElement ID="I" KEY="TB1" ENTRY="Objet(s) à vérifier" LENGTH="26 "/>
    <textElement ID="I" KEY="TPR" ENTRY="Production" LENGTH="20 "/>
    <textElement ID="I" KEY="TRE" ENTRY="Recette" LENGTH="17 "/>
    <textElement ID="R" ENTRY="Contrôle Version de(s) (l&apos;)Objet(s)" LENGTH="35 "/>
    <textElement ID="S" KEY="S_OBJECT" ENTRY="D       ." LENGTH="9 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_A_OBJECT_CHECK_VERSION
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*
REPORT z_a_object_check_version.

***==================================================================***
**                         SELECTION-SCREEN                           **
***==================================================================***

&quot; -----------------------------------------------------------
&quot; Critère de sélection
&quot; -----------------------------------------------------------

TABLES : e071.

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-tb1.

&quot; Objet
SELECT-OPTIONS : s_object FOR e071-obj_name NO INTERVALS.

SELECTION-SCREEN END OF BLOCK b1.

***==================================================================***
**                           INITIALIZATION                           **
***==================================================================***
INITIALIZATION.


***==================================================================***
**                         AT SELECTION-SCREEN                        **
***==================================================================***
AT SELECTION-SCREEN.


***==================================================================***
**                     AT SELECTION-SCREEN OUTPUT                     **
***==================================================================***
AT SELECTION-SCREEN OUTPUT.

***==================================================================***
**                AT SELECTION-SCREEN ON VALUE REQUEST                **
***==================================================================***


***==================================================================***
**                         START-OF-SELECTION                         **
***==================================================================***
START-OF-SELECTION.

  TYPES :
    BEGIN OF ts_object_ot,
      object                    TYPE e071-obj_name,
      trkorr                    TYPE e071-trkorr,
      trkorr_main               TYPE e070-strkorr,
      as4text                   TYPE e07t-as4text,
      transport_recette         TYPE xsdboolean,
      transport_recette_icon    TYPE icon_d,
      transport_production      TYPE xsdboolean,
      transport_production_icon TYPE icon_d,
    END OF   ts_object_ot.

  TYPES : tt_object_ot TYPE STANDARD TABLE OF ts_object_ot
                          WITH NON-UNIQUE KEY primary_key COMPONENTS object trkorr_main.

***------------------------------------------------------------------***
**                             TABLES                                 **
***------------------------------------------------------------------***
  DATA :
      lt_object_ot TYPE tt_object_ot.

***------------------------------------------------------------------***
**                            INSTANCES                               **
***------------------------------------------------------------------***
  DATA :
    lo_salv    TYPE REF TO cl_salv_table,
    lo_column  TYPE REF TO cl_salv_column,
    lo_columns TYPE REF TO cl_salv_columns.

***------------------------------------------------------------------***
**                            VARIABLES                               **
***------------------------------------------------------------------***
  DATA :
    lv_strlen               TYPE lvc_outlen,
    lv_object_length_output TYPE lvc_outlen.

***==================================================================***
**                             TRAITEMENT                             **
***==================================================================***

  &quot; -----------------------------------------------------------
  &quot; Contrôle
  &quot; -----------------------------------------------------------

  IF s_object[] IS INITIAL.
    &quot; Aucun Objet
    &quot;&quot;  --&gt; Faut en mettre
    MESSAGE s000(zbc) WITH &apos;Faut&apos; &apos;des&apos; &apos;objets&apos; &apos;!&apos; DISPLAY LIKE if_msg_output=&gt;msgtype_error. ##NO_TEXT
    RETURN.

  ENDIF.

  &quot; -----------------------------------------------------------
  &quot; Récupération des OTs constituant
  &quot; -----------------------------------------------------------

  &quot; Récupération des OTs contenant l&apos;Objet
  SELECT
    e071~obj_name AS object, e071~trkorr AS trkoor,
    CASE WHEN main~strkorr NE @space THEN main~strkorr ELSE main~trkorr END AS trkorr_main
    FROM e071 INNER JOIN e070 AS main ON e071~trkorr EQ main~trkorr
   WHERE e071~obj_name IN @s_object[] AND e071~trkorr NOT LIKE &apos;DE1_P%&apos;
    INTO TABLE @lt_object_ot.
  IF sy-subrc NE 0.
    &quot; Aucun OT sélectionné
    &quot;&quot;  --&gt; Arrêt du traitement
    MESSAGE s000(zbc) WITH text-e02 space space space DISPLAY LIKE if_msg_output=&gt;msgtype_error.
    RETURN.

  ENDIF.

  &quot; Suppression inutile et doublon
  DELETE lt_object_ot WHERE ( trkorr IS INITIAL OR trkorr_main IS INITIAL ).
  SORT : lt_object_ot BY object trkorr_main.
  DELETE ADJACENT DUPLICATES FROM lt_object_ot COMPARING object trkorr_main.

  &quot; Tri par Ordre décroissant
  SORT : lt_object_ot BY object trkorr_main DESCENDING.

  &quot; -----------------------------------------------------------
  &quot; Contrôle Version
  &quot; -----------------------------------------------------------

  LOOP AT lt_object_ot ASSIGNING FIELD-SYMBOL(&lt;lfs_s_object_ot&gt;).

    &quot; Désignation OT // pas mis dans le SELECT au-dessus car condition sur OT / Tâche
    SELECT SINGLE as4text FROM e07t
            WHERE trkorr EQ @&lt;lfs_s_object_ot&gt;-trkorr_main AND langu EQ &apos;F&apos;
             INTO @&lt;lfs_s_object_ot&gt;-as4text.

    &quot; OT transporté en Recette ?
    &lt;lfs_s_object_ot&gt;-transport_recette = zcl_transport_request=&gt;transport_request_check_import(
      iv_trkorr    = &lt;lfs_s_object_ot&gt;-trkorr_main
      iv_tarsystem = &apos;RE1&apos;                                  &quot;#EC NOTEXT
    ).

    &quot; Icône Transport Recette
    &lt;lfs_s_object_ot&gt;-transport_recette_icon = SWITCH #( &lt;lfs_s_object_ot&gt;-transport_recette
      WHEN abap_false     THEN text-e00
      WHEN abap_true      THEN text-s00
      WHEN abap_undefined THEN text-i00
    ).

    &quot; OT transporté en Production ?
    &lt;lfs_s_object_ot&gt;-transport_production = zcl_transport_request=&gt;transport_request_check_import(
      iv_trkorr    = &lt;lfs_s_object_ot&gt;-trkorr_main
      iv_tarsystem = &apos;PE1&apos;                                  &quot;#EC NOTEXT
    ).

    &quot; Icône Transport Production
    &lt;lfs_s_object_ot&gt;-transport_production_icon = SWITCH #( &lt;lfs_s_object_ot&gt;-transport_production
      WHEN abap_false     THEN text-e00
      WHEN abap_true      THEN text-s00
      WHEN abap_undefined THEN text-i00
    ).

    &quot; Taille affichage - Objet
    lv_strlen = strlen( &lt;lfs_s_object_ot&gt;-object ).
    IF lv_strlen GT lv_object_length_output.
      &quot; Taille objet plus grande
      &quot;&quot;  --&gt; Utilisation de cette taille
      lv_object_length_output = lv_strlen + 2.

    ENDIF.

  ENDLOOP.

  &quot; -----------------------------------------------------------
  &quot; Initialisation Affichage ALV
  &quot; -----------------------------------------------------------

  TRY.
      &quot; Création instance ALV
      cl_salv_table=&gt;factory(
        EXPORTING
          list_display = sy-batch
        IMPORTING
          r_salv_table = lo_salv
        CHANGING
          t_table      = lt_object_ot
      ).

      &quot; -----------------------------------------------------------
      &quot; Customization
      &quot; -----------------------------------------------------------

      lo_salv-&gt;get_functions( )-&gt;set_all( abap_true ).

      TRY.
          &quot; Modification FieldCat
          lo_columns = lo_salv-&gt;get_columns( ).

          TRY.
              &quot; Tâche
              lo_column = lo_columns-&gt;get_column( &apos;TRKORR&apos; ). &quot;#EC NOTEXT
              lo_column-&gt;set_visible( abap_false ).

            CATCH : cx_salv_not_found, cx_salv_data_error.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Tant pis ...
          ENDTRY.

          TRY.
              &quot; OT
              lo_column = lo_columns-&gt;get_column( &apos;TRKORR_MAIN&apos; ). &quot;#EC NOTEXT
              lo_column-&gt;set_output_length( 10 ).

            CATCH : cx_salv_not_found, cx_salv_data_error.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Tant pis ...
          ENDTRY.

          TRY.
              &quot; Récupération de la Colonne &quot;OBJECT&quot; - Nom d&apos;Objet
              lo_column = lo_columns-&gt;get_column( &apos;OBJECT&apos; ). &quot;#EC NOTEXT
              lo_column-&gt;set_output_length( lv_object_length_output ).

            CATCH : cx_salv_not_found, cx_salv_data_error.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Tant pis ...

          ENDTRY.

          TRY.
              &quot; Indicateur Transport Recette
              lo_column = lo_columns-&gt;get_column( &apos;TRANSPORT_RECETTE&apos; ). &quot;#EC NOTEXT
              lo_column-&gt;set_visible( abap_false ).

            CATCH : cx_salv_not_found, cx_salv_data_error.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Tant pis ...
          ENDTRY.
*
          TRY.
              &quot; Icone Transport Recette
              lo_column = lo_columns-&gt;get_column( &apos;TRANSPORT_RECETTE_ICON&apos; ). &quot;#EC NOTEXT
              lo_column-&gt;set_output_length( &apos;9&apos; ).
              lo_column-&gt;set_long_text( CONV #( text-tre ) ).
              lo_column-&gt;set_short_text( CONV #( text-tre ) ).
              lo_column-&gt;set_medium_text( CONV #( text-tre ) ).

            CATCH : cx_salv_not_found, cx_salv_data_error.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Tant pis ...
          ENDTRY.

          TRY.
              &quot; Indicateur Transport Production
              lo_column = lo_columns-&gt;get_column( &apos;TRANSPORT_PRODUCTION&apos; ). &quot;#EC NOTEXT
              lo_column-&gt;set_visible( abap_false ).

            CATCH : cx_salv_not_found, cx_salv_data_error.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Tant pis ...
          ENDTRY.

          TRY.
              &quot; Icone Transport Production
              lo_column = lo_columns-&gt;get_column( &apos;TRANSPORT_PRODUCTION_ICON&apos; ). &quot;#EC NOTEXT
              lo_column-&gt;set_output_length( &apos;9&apos; ).
              lo_column-&gt;set_long_text( CONV #( text-tpr ) ).
              lo_column-&gt;set_short_text( CONV #( text-tpr ) ).
              lo_column-&gt;set_medium_text( CONV #( text-tpr ) ).

            CATCH : cx_salv_not_found, cx_salv_data_error.
              &quot; Une erreur est survenue
              &quot;&quot;  --&gt; Tant pis ...
          ENDTRY.

        CATCH cx_root.
          &quot; Une erreur est survenue

      ENDTRY.

      &quot; -----------------------------------------------------------
      &quot; Affichage
      &quot; -----------------------------------------------------------

      &quot; Affichage
      lo_salv-&gt;display( ).

    CATCH cx_salv_msg.

  ENDTRY.


END-OF-SELECTION.</source>
 </PROG>
 <TABL TABNAME="ZTEC_TRKORR_EXC" DDLANGUAGE="F" TABCLASS="TRANSP" DATMIN="0000000000" DATMAX="0000000000" DATAVG="0000000000" DDTEXT="Transport - Liste OT à exclure" AUTHCLASS="00" MAINFLAG="X" CONTFLAG="L" PROZPUFF="000" EXCLASS="1">
  <dd09l TABNAME="ZTEC_TRKORR_EXC" AS4LOCAL="A" AS4VERS="0000" TABKAT="0" TABART="APPL1" PUFFERUNG="X" SCHFELDANZ="000" BUFALLOW="X" ROWORCOLST="C"/>
  <dd03p TABNAME="ZTEC_TRKORR_EXC" FIELDNAME="TRKORR" DDLANGUAGE="F" POSITION="0001" KEYFLAG="X" ROLLNAME="TRKORR" ADMINFIELD="0" INTTYPE="C" INTLEN="000040" NOTNULL="X" DOMNAME="TRKORR" ROUTPUTLEN="000000" HEADLEN="15" SCRLEN1="10" SCRLEN2="15" SCRLEN3="20" DTELMASTER="D" DATATYPE="CHAR" LENG="000020" OUTPUTLEN="000020" DECIMALS="000000" ENTITYTAB="E070" MASK="  CHARE" MASKLEN="0000" DDTEXT="Ordre/Tâche" REPTEXT="Ordre/Tâche" SCRTEXT_S="Ordre" SCRTEXT_M="Ordre/Tâche" SCRTEXT_L="Ordre/Tâche" DOMNAME3L="TRKORR" DEPTH="00" COMPTYPE="E" DEFFDNAME="AUFTRAGS-NUMMER" EXCLASS="0" DBPOSITION="0000" OUTPUTSTYLE="00" STRORLOCPOS="00"/>
 </TABL>
 <TRAN TCODE="ZTRANSPORT_CHECK" PGMNA="Z_A_BC_TRANSPORT_CHECK" DYPNO="1000" CINFO="80">
  <tstct SPRSL="F" TCODE="ZTRANSPORT_CHECK" TTEXT="Contrôle Transport"/>
  <tstcc TCODE="ZTRANSPORT_CHECK"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
 <TRAN TCODE="ZHANA_TRANSPORT" PGMNA="Z_BC_TRANSPORT_HANA" DYPNO="1000" CINFO="80">
  <tstct SPRSL="F" TCODE="ZHANA_TRANSPORT" TTEXT="Transport HANA"/>
  <tstcc TCODE="ZHANA_TRANSPORT" S_WEBGUI="1" S_WIN32="X" S_PLATIN="X"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
 <TRAN TCODE="ZTRANSPORT" PGMNA="Z_BC_TRANSPORT_REQUEST_CREATE" DYPNO="1000" CINFO="80">
  <tstct SPRSL="F" TCODE="ZTRANSPORT" TTEXT="Transport"/>
  <tstcc TCODE="ZTRANSPORT" S_WEBGUI="1" S_WIN32="X" S_PLATIN="X"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
 <TRAN TCODE="ZOBJECT_CHECK" PGMNA="Z_A_OBJECT_CHECK_VERSION" DYPNO="1000" CINFO="80">
  <tstct SPRSL="F" TCODE="ZOBJECT_CHECK" TTEXT="Contrôle Objet / OT"/>
  <tstcc TCODE="ZOBJECT_CHECK" S_WEBGUI="1" S_WIN32="X" S_PLATIN="X"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
</nugget>
